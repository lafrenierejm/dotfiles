#+TITLE: Eshell Initialization
#+AUTHOR: Joseph M LaFreniere (lafrenierejm)
#+EMAIL: joseph@lafreniere.xyz

* License
  All code sections in this file are licensed under [[https://gitlab.com/lafrenierejm/dotfiles/blob/master/LICENSE][an ISC license]] except when otherwise noted.
  All prose in this file is licensed under [[https://creativecommons.org/licenses/by/4.0/][CC BY 4.0]] except when otherwise noted.

* About This File
  This file contains configuration for [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][Eshell]].
  It is written in the [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style using [[http://orgmode.org/worg/org-contrib/babel/][Org-mode Babel]].

* Eshell Configuration
** Introductory Boilerplate					   :noexport:
   #+BEGIN_SRC emacs-lisp :tangle yes :padline no
     ;;; init-eshell.el --- Customization for Eshell

     ;;; Commentary:
     ;; This file is tangled from init-eshell.org.
     ;; Changes made here will be overwritten by changes to that Org-mode file.

     ;;; Code:
   #+END_SRC

** Specify Dependencies						   :noexport:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'general)
     (require 'use-package)
   #+END_SRC

** Load ~esh-mode~
   #+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
     (use-package esh-mode
       ;; This package is included in Emacs.
       :straight nil

       ;; Load this package eagerly.
       :demand

       :config
       <<esh-mode/config>>)
   #+END_SRC

*** Post-Load Execution
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref esh-mode/config
    :END:

**** Only Write the Current Command
     Because I am not interested in existing shell output, the only valid position where I want to insert text in an Eshell buffer is when composing the current command.
     The composition of the current command takes place in the last line of the buffer past Eshell's prompt.
     The following algorithm ensures that I am inserting in a valid position when added as a hook on entering insert mode:

     1. If =point= is not on the last line of the buffer then move =point= to =point-max=.
       	In Eshell =point-max= is always part of the current command.
     2. Otherwise if the text at =point= is read-only then move =point= to the character where that text property changes.

     I posted the following code as [[https://stackoverflow.com/a/46937891/8468492][an answer on StackOverflow]].
     As such, this code is licensed under [[https://creativecommons.org/licenses/by-sa/3.0/][CC BY-SA 3.0]].

     #+BEGIN_SRC emacs-lisp :tangle no
       (defun init-eshell/move-point-to-command ()
	 "Move point to the current command.
       If point is not on the last line, move point to the maximum position
       in the buffer.  Else if point is in the Eshell prompt, move it to the
       start of the command."
	 (interactive)
	 (let ((curline (line-number-at-pos))
	       (endline (line-number-at-pos (point-max))))
	   (if (= curline endline)
	       (if (not (eobp))
		   (let ((old (point)))        ; Get the current position as OLD.
		     (eshell-bol)              ; Move to beginning of current command.
		     (if (<= (point) old)      ; If point now before OLD...
			 (goto-char old)       ; ...move it back to OLD.
		       nil)))                  ; Otherwise keep as is.
	     (goto-char (point-max)))))

       (defun init-eshell/move-point-on-insert-to-command ()
	 "Move point to edit the current command when insert mode is entered."
	 (add-hook 'evil-insert-state-entry-hook
		   'init-eshell/move-point-to-command
		   nil
		   t))
     #+END_SRC

**** Define Eshell-Specific ~beginning-of-maybe-line~
     [[../minor-mode/init-evil.org][init-evil.org]] defines ~init/beginning-of-maybe-line~.
     That function acts as a do-what-I-mean alternative to the built-in =beginning-of-line= by incrementally jumping to the beginning of text sections within a line.

     =init-eshell/beginning-of-maybe-line= moves =point= toward the beginning of the current line incrementally by semantic region.
     1. If point is in the text of a command, point will be moved to the beginning of the command.
     2. If the current line has leading whitespace and point is somewhere after that whitespace, point will be moved to the first non-whitespace character.
     3. Point will be moved to the beginning of the line.

     #+BEGIN_SRC emacs-lisp :tangle no
       (defun init-eshell/beginning-of-maybe-line ()
         "Move point to the start of the command beginning of the line."
         (interactive)
         (let ((old-point (point)))   ; Get current position.
           (eshell-bol)               ; Move to beginning of current command.
           (when (or (<= old-point (point))
                     (= (point-at-bol) (point)))
             (back-to-indentation) ; Go to the first significant column
             ;; If already at or before the first significant column...
             (when (<= old-point (point))
               ;; Then go to the beginning of the line.
               (beginning-of-line)))))
     #+END_SRC

** Load Em Dirs

   #+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
     (use-package em-dirs
       :straight nil

       :config
       <<em-dirs/config>>)
   #+END_SRC

*** Post-Load Evaluation (~:config~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref em-dirs/config
    :END:

**** Abbreviate a Path
     #+BEGIN_SRC emacs-lisp :tangle no
       (defun init-eshell/pwd (directory)
	   "Use the Projectile root when displaying a path.

	 If DIRECTORY is not in a probject as determined by Projectile, use the
	 abbreviated name of DIRECTORY in the returned name.  If DIRECTORY is in a
	 Projectile project, use the path of DIRECTORY relative to the project's root."
	   (if-let ((projectile-loaded (featurep 'projectile))
		    (project-root (projectile-project-root directory))
		    (project-name (projectile-project-name project-root)))
	       ;; If in a project:
	       (if (string=
		    (file-name-as-directory (expand-file-name directory))
		    project-root)
		   ;; If at a project's root: use the project's name
		   project-name
		 ;; Else not at project's root: use path starting with project's root
		 (s-chop-suffix
		  "/"
		  (concat project-name "/"
			  (file-relative-name (expand-file-name directory) project-root))))
	     ;; Else not in project: use abbreviated path
	     (abbreviate-file-name directory)))
     #+END_SRC

**** Create Eshell Buffer Names
     #+BEGIN_SRC emacs-lisp :tangle no
       (defun init-eshell/name-buffer (directory)
	 "Create a name for an Eshell buffer in DIRECTORY."
	 (concat "*eshell "
		 (init-eshell/pwd directory)
		 "*"))
     #+END_SRC

**** Prefer Changing Buffers to Changing Directories
     Redefine ~eshell/cd~ to prefer switching to an Eshell buffer in the new directory (if such a buffer exists) over changing the directory of the buffer where ~eshell/cd~ was called.
     Whether or not an Eshell buffer exists at the specified location is determined by the name of existing Eshell buffers.

     The following code is derived directly from code in GNU Emacs's Em Dirs and Files packages.
     As such, it is licensed under GPLv3.

     #+BEGIN_SRC emacs-lisp :tangle no
       (defun eshell/cd (&rest args)           ; all but first ignored
	 "Alias to extend the behavior of `cd'.

       If an Eshell buffer already exists at the target directory, switch to that
       buffer.  Otherwise, change the working directory of the current buffer to the
       target directory then rename the current buffer to reflect its new working
       directory.

       The presence of an existing Eshell buffer at the new location is determined by
       comparing the name of buffers to the result of `init-eshell/name-buffer'."
	 (setq args (eshell-flatten-list args))
	 (let ((path (car args))
	       (subpath (car (cdr args)))
	       (case-fold-search (eshell-under-windows-p))
	       handled)
	   (if (numberp path)
	       (setq path (number-to-string path)))
	   (if (numberp subpath)
	       (setq subpath (number-to-string subpath)))
	   (cond
	    (subpath
	     (let ((curdir (eshell/pwd)))
	       (if (string-match path curdir)
		   (setq path (replace-match subpath nil nil curdir))
		 (error "Path substring `%s' not found" path))))
	    ((and path (string-match "^-\\([0-9]*\\)$" path))
	     (let ((index (match-string 1 path)))
	       (setq path
		     (ring-remove eshell-last-dir-ring
				  (if index
				      (string-to-number index)
				    0)))))
	    ((and path (string-match "^=\\(.*\\)$" path))
	     (let ((oldpath (eshell-find-previous-directory
			     (match-string 1 path))))
	       (if oldpath
		   (setq path oldpath)
		 (let ((len (ring-length eshell-last-dir-ring))
		       (index 0))
		   (if (= len 0)
		       (error "Directory ring empty"))
		   (eshell-init-print-buffer)
		   (while (< index len)
		     (eshell-buffered-print
		      (concat (number-to-string index) ": "
			      (ring-ref eshell-last-dir-ring index) "\n"))
		     (setq index (1+ index)))
		   (eshell-flush)
		   (setq handled t)))))
	    (path
	     (setq path (eshell-expand-multiple-dots path))))
	   (unless handled
	     (let* ((cd-path (or (parse-colon-path (getenv "CDPATH"))
				 (list "./")))
		    (curdir (eshell/pwd))
		    (newdir (expand-file-name (file-name-as-directory (or path "~"))))
		    (newname (init-eshell/name-buffer newdir)))
	       (unless (equal curdir newdir)
		 (eshell-add-to-dir-ring curdir))
	       ;; If an Eshell buffer already exists in the new directory...
	       (if-let ((newbuf (get-buffer newname)))
		   ;; Then switch to the existing Eshell buffer.
		   (switch-to-buffer newbuf)
		 ;; Else change to the new directory.
		 (let ((result (cd newdir)))
		   ;; Change the buffer's name.
		   (rename-buffer newname)
		   ;; If `eshell-cd-shows-directory' is non-nil...
		   (when eshell-cd-shows-directory
		     ;; Then print the new directory.
		     (eshell-printn result))))
	       (run-hooks 'eshell-directory-change-hook)
	       (if eshell-list-files-after-cd
		   ;; Let-bind eshell-last-command around this?
		   (eshell-plain-command "ls" (cdr args)))
	       nil))))
     #+END_SRC

** Load ~eshell~
   #+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
     (use-package eshell
       :straight nil

       ;; Load this package eagerly.
       :demand

       ;; Load this package after the following packages.
       :after (em-hist evil ivy)

       ;; Inform the bytecode compiler of the following functions.
       :commands
       (init-eshell/add-visual-commands
	init-eshell/beginning-of-maybe-line
	init-eshell/find-eshell
	init-eshell/find-eshell-here
	init-eshell/move-point-on-insert-to-command)

       ;; Add the following keybindings.
       :general
       <<eshell/general>>

       ;; Add the following non-autoloading hooks.
       :gfhook
       <<eshell/gfhook>>

       ;; Customize the following variables.
       :custom
       <<eshell/custom>>

       ;; Execute the following code before loading this package.
       :init
       <<eshell/init>>

       ;; Execute the following code after loading this package.
       :config
       <<eshell/config>>)
   #+END_SRC

*** Keybindings (~:general~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref eshell/general
    :END:

    Map the opening an Eshell buffer to =C-x z=.
    This keybinding mirrors the defaults for ~find-file~ and ~dired~.

    #+BEGIN_SRC emacs-lisp :tangle no
      ("C-x z" #'init-eshell/find-eshell)
    #+END_SRC

    Map ~init-eshell/find-eshell-here~ to =C-z=.
    This imitates the behavior of *NIX terminal applications.
    In most terminal applications, =C-z= is the key combination to suspend the current process which usually results in the user being returned to their shell.

    #+BEGIN_SRC emacs-lisp :tangle no
      ("C-z" #'init-eshell/find-eshell-here)
    #+END_SRC

    Account for the prompt's read-only text when moving the point to the beginning of the line.

    #+BEGIN_SRC text :tangle no
      (:keymaps 'eshell-mode-map :state 'motion
		"H" #'init-eshell/beginning-of-maybe-line)
    #+END_SRC

    Unbind =C-d= to make room for ~bury-buffer~.

    #+BEGIN_SRC emacs-lisp :tangle no
      (:keymaps 'eshell-mode-map :state (list 'emacs 'insert 'motion 'normal 'operator 'replace 'visual)
		"C-d" #'bury-buffer)
    #+END_SRC

*** Non-Autoloading Hooks (~:gfhook~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref eshell/gfhook
    :END:

    Enable ~init-eshell/move-point-on-insert-to-command~.

    #+BEGIN_SRC emacs-lisp :tangle no
      (nil #'init-eshell/move-point-on-insert-to-command)
    #+END_SRC

    Make the list of commands to be run in Term mode buffers.

    #+BEGIN_SRC emacs-lisp :tangle no
      (nil #'init-eshell/add-visual-commands)
    #+END_SRC

    Bury the Eshell buffer with =C-d=.
    This is reminiscent of how terminal applications respond to =sigkill=

    #+BEGIN_SRC emacs-lisp :tangle no
      (nil '(lambda ()
	      (general-define-key
	       :keymaps 'eshell-mode-map
	       :state (list 'emacs 'insert 'motion 'normal 'operator 'replace 'visual)
	       "C-d" #'bury-buffer)))
    #+END_SRC

*** Customize Variables (~:custom~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref eshell/custom
    :END:

    #+BEGIN_SRC emacs-lisp :tangle no
      (eshell-prefer-lisp-functions t "Use built-in commands.")
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle no
      (eshell-prefer-lisp-variables t "Use built-in commands.")
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle no
      (eshell-prompt-function
       (function (lambda ()
		   (concat
		    (when-let ((remote-host (file-remote-p default-directory 'host)))
		      (concat
		       (eshell-user-name) "@"
		       remote-host ":"))
		    (init-eshell/pwd default-directory)
		    (if (= (user-uid) 0) " # " " $ "))))
       "Prefix \"$USER@$(hostname):\" if on remote host.")
    #+END_SRC

*** Pre-Load Execution (~:init~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref eshell/init
    :END:

**** Set =$PAGER=
     Because Eshell runs entirely within an Emacs buffer, Eshell does not need an external pager.
     Instead, text can be dumped directly into the buffer.
     This is accomplished by setting ~PAGER~ to ~cat~.

     #+BEGIN_SRC emacs-lisp :tangle no
       (setenv "PAGER" "cat")
     #+END_SRC

**** Use Magit for Some ~git~ Commands
     The code in this section is copyright Gergely Nagy [[mailto:algernon@bonehunter.rulez.org][<algernon@bonehunter.rulez.org>]] and shared under GPLv3.

     #+BEGIN_SRC emacs-lisp :tangle no
       (with-eval-after-load 'magit
	 (defun eshell/git (command &rest args)
	   (pcase command
	     ;; Use magit's log.
	     ("log" (apply #'algernon/git-log args))
	     ;; Use magit's status.
	     ("status" (progn
			 (magit-status)
			 (eshell/echo)))
	     ;; Run all other commands directly in `git'.
	     (_ (let ((command (s-join " " (append (list "git" command) args))))
		  (message command)
		  (shell-command-to-string command))))))
     #+END_SRC

     Run ~magit-log~ after determining if the argument to ~git log~ was a file or branch.

     #+BEGIN_SRC emacs-lisp :tangle no
       (with-eval-after-load 'magit
	 (defun algernon/git-log (&rest args)
	   (let* ((branch-or-file (car args))
		  (file-list (if (and branch-or-file (f-file-p branch-or-file))
				 args
			       (cdr args)))
		  (branch (if (and branch-or-file (f-file-p branch-or-file))
			      "HEAD"
			    branch-or-file)))
	     (message branch-or-file)
	     (if branch-or-file
		 (magit-log (list branch)
			    '()
			    (mapcar
			     (lambda (f) (concat (file-name-as-directory (eshell/pwd)) f))
			     file-list))
	       (magit-log-head)))
	   (eshell/echo)))
     #+END_SRC

*** Post-Load Execution (~:config~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref eshell/config
    :END:

**** "Visual" Commands
     Run the following commands in a =term= buffer:
     #+NAME: visual-commands
     - alsamixer
     - ssh
     - top
     - tail

      #+BEGIN_SRC emacs-lisp :tangle no
	(defun init-eshell/add-visual-commands ()
          "Add commands to `eshell-visual-commands'."
          (let ((commands (list "alsamixer" "ssh" "top" "tail")))
            (dolist (command commands)
                    (add-to-list 'eshell-visual-commands command))))
      #+END_SRC

**** Custom Functions
***** Open Eshell in a Given Directory
      Open or switch to an Eshell buffer in a given directory.

      #+BEGIN_SRC emacs-lisp :tangle no
	(defun init-eshell/find-eshell (directory)
	  "Open Eshell in DIRECTORY.

	If an Eshell instance for the directory already exists, switch to it.
	If no such instance exists, start a new instance whose name includes the directory."
	  (interactive
	   (let ((cwd (if (buffer-file-name)
			  (file-name-directory (buffer-file-name))
			default-directory))
		 (must-exist t))
	     (list (read-directory-name "Open Eshell in: " cwd cwd must-exist))))
	  ;; Set the directory to open Eshell in.
	  (let ((eshell-buffer-name (init-eshell/name-buffer directory))
		(default-directory directory))
	    ;; Start Eshell.
	    (eshell)))
      #+END_SRC

***** Open Eshell in the Current Directory
      Define a function to open an Eshell instance in the current directory.
      If an Eshell instance already exists in that directory, switch to its buffer.

      #+BEGIN_SRC emacs-lisp :tangle no
	(defun init-eshell/find-eshell-here ()
          "Open Eshell in the current working directory.

	If an Eshell instance for the directory already exists, switch to it.
	If no such instance exists, start a new instance whose name includes the directory."
          (interactive)
          (let ((cwd (abbreviate-file-name (if (buffer-file-name)
                                               (file-name-directory (buffer-file-name))
                                             default-directory))))
            (init-eshell/find-eshell cwd)))
      #+END_SRC

** Load ~esh-module~
   #+BEGIN_SRC emacs-lisp :tangle yes :noweb no-export
     (use-package esh-module
       ;; This package is included in Emacs.
       :straight nil

       ;; Load this package eagerly.
       :demand

       ;; Load this package after the following packages.
       :after (validate)

       ;; Evaluate the following code after loading this package.
       :config
       <<esh-module/config>>)
   #+END_SRC

*** Post-Load Execution (~:config~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref esh-module/config
    :END:
    
    Disable the greeting banner.

    #+BEGIN_SRC emacs-lisp :tangle no
      (validate-setq eshell-modules-list (delq 'eshell-banner eshell-modules-list))
    #+END_SRC

** Load ~em-tramp~
   ~em-tramp~ provides Eshell features that require TRAMP.

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package em-tramp
       ;; This package is included in Emacs.
       :straight nil

       ;; Load this package eagerly.
       :demand)
   #+END_SRC

** Load ~em-rebind~
   #+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
     (use-package em-rebind
       ;; This package is included in Emacs.
       :straight nil

       ;; Load this package eagerly.
       :demand

       ;; Evaluate the following code after loading this package.
       :config
       <<em-rebind/config>>)
   #+END_SRC

*** Post-Load Evaluation (~:config~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref em-rebind/config
    :DESCRIPTION: The code to be evaluated after ~em-rebind~ has been loaded.
    :END:

    Rebind Emacs's vertical movement keys to search through history.
    Normal buffer movement is performed using keybindings provided by ~evil~.

    #+BEGIN_SRC emacs-lisp :tangle no
      (add-to-list '([(control ?n)] . init-esh-mode/ivy-esh-history) 'eshell-rebind-keys-alist)
    #+END_SRC

** Load ~em-cmpl~
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package em-cmpl
       ;; This package is included in Emacs.
       :straight nil

       :demand

       ;; Load `em-cmpl' after the following packages.
       :after (validate)

       ;; Evaluate the following code after loading `em-cmpl'.
       :config
       ;; Use zsh-like completion.
       (validate-setq eshell-cmpl-cycle-completions nil))
   #+END_SRC

** Load ~em-hist~
   #+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
     (use-package em-hist
       ;; This package is included in Emacs.
       :straight nil

       ;; Load eagerly.
       :demand

       ;; Load after the following packages.
       :after (ivy validate)

       ;; Evaluate the following code after loading.
       :config
       <<em-hist/config>>)
   #+END_SRC

*** Post-Load Evaluation (~:config~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref em-hist/config
    :DESCRIPTION: The code to be evaluated after ~em-hist~ has been loaded.
    :END:

    Skip duplicates when traversing command history.

    #+BEGIN_SRC emacs-lisp :tangle no
      (validate-setq eshell-hist-ignoredups t)
    #+END_SRC

** Ending Boilerplate						   :noexport:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (provide 'init-eshell)
     ;;; init-eshell.el ends here
   #+END_SRC
