#+TITLE: Eshell Initialization
#+AUTHOR: Joseph M LaFreniere (lafrenierejm)
#+EMAIL: joseph@lafreniere.xyz

* License
  All code sections in this file are licensed under [[https://gitlab.com/lafrenierejm/dotfiles/blob/master/LICENSE][an ISC license]] except when otherwise noted.
  All prose in this file is licensed under [[https://creativecommons.org/licenses/by/4.0/][CC BY 4.0]] except when otherwise noted.

* About This File
  This file contains configuration for [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][Eshell]].
  It is written in the [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style using [[http://orgmode.org/worg/org-contrib/babel/][Org-mode Babel]].

* Eshell Configuration
** Introductory Boilerplate					   :noexport:
   #+BEGIN_SRC emacs-lisp :tangle yes :padline no
     ;;; init-eshell.el --- Customization for Eshell

     ;;; Commentary:
     ;; This file is tangled from init-eshell.org.
     ;; Changes made here will be overwritten by changes to that Org-mode file.

     ;;; Code:
   #+END_SRC

** Specify Dependencies						   :noexport:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'evil)
     (require 'ivy)
     (require 'magit)
     (require 'use-package)
   #+END_SRC

** Load ~esh-mode~
   #+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
     (use-package esh-mode
       ;; This package is included in Emacs.
       :straight nil

       :bind
       (:map eshell-mode-map
	("C-d" . bury-buffer))

       :config
       <<esh-mode/config>>)
   #+END_SRC

*** Post-Load Execution
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref esh-mode/config
    :END:

**** Only Write the Current Command
     Because I am not interested in existing shell output, the only valid position where I want to insert text in an Eshell buffer is when composing the current command.
     The composition of the current command takes place in the last line of the buffer past Eshell's prompt.
     The following algorithm ensures that I am inserting in a valid position when added as a hook on entering insert mode:

     1. If =point= is not on the last line of the buffer then move =point= to =point-max=.
       	In Eshell =point-max= is always part of the current command.
     2. Otherwise if the text at =point= is read-only then move =point= to the character where that text property changes.

     I posted the following code as [[https://stackoverflow.com/a/46937891/8468492][an answer on StackOverflow]].
     As such, this code is licensed under [[https://creativecommons.org/licenses/by-sa/3.0/][CC BY-SA 3.0]].

     #+BEGIN_SRC emacs-lisp
       (defun init-eshell/move-point-to-command ()
	 "Move point to the current command.
       If point is not on the last line, move point to the maximum position
       in the buffer.  Else if point is in the Eshell prompt, move it to the
       start of the command."
	 (interactive)
	 (let ((curline (line-number-at-pos))
	       (endline (line-number-at-pos (point-max))))
	   (if (= curline endline)
	       (if (not (eobp))
		   (let ((old (point)))        ; Get the current position as OLD.
		     (eshell-bol)              ; Move to beginning of current command.
		     (if (<= (point) old)      ; If point now before OLD...
			 (goto-char old)       ; ...move it back to OLD.
		       nil)))                  ; Otherwise keep as is.
	     (goto-char (point-max)))))

       (defun init-eshell/move-point-on-insert-to-command ()
	 "Move point to edit the current command when insert mode is entered."
	 (add-hook 'evil-insert-state-entry-hook
		   'init-eshell/move-point-to-command
		   nil
		   t))
     #+END_SRC

**** Define Eshell-Specific ~beginning-of-maybe-line~
     [[../minor-mode/init-evil.org][init-evil.org]] defines ~init/beginning-of-maybe-line~.
     That function acts as a do-what-I-mean alternative to the built-in =beginning-of-line= by incrementally jumping to the beginning of text sections within a line.

     =init-eshell/beginning-of-maybe-line= moves =point= toward the beginning of the current line incrementally by semantic region.
     1. If point is in the text of a command, point will be moved to the beginning of the command.
     2. If the current line has leading whitespace and point is somewhere after that whitespace, point will be moved to the first non-whitespace character.
     3. Point will be moved to the beginning of the line.

     #+BEGIN_SRC emacs-lisp :noweb-ref esh-mode/config
       (defun init-eshell/beginning-of-maybe-line ()
         "Move point to the start of the command beginning of the line."
         (interactive)
         (let ((old-point (point)))   ; Get current position.
           (eshell-bol)               ; Move to beginning of current command.
           (when (or (<= old-point (point))
                     (= (point-at-bol) (point)))
             (back-to-indentation) ; Go to the first significant column
             ;; If already at or before the first significant column...
             (when (<= old-point (point))
               ;; Then go to the beginning of the line.
               (beginning-of-line)))))
     #+END_SRC

** Load ~eshell~
   #+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
     (use-package eshell
       :straight nil

       ;; Load eshell after the following packages.
       :after (evil ivy magit)

       ;; Execute the following code before eshell has been loaded.
       :init
       <<eshell/init>>

       ;; Execute the following code after eshell has been loaded.
       :config
       <<eshell/config>>)
   #+END_SRC

*** Pre-Load Execution (~:init~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref eshell/init
    :END:

**** Set =$PAGER=
     Because Eshell runs entirely within an Emacs buffer it does not need any external pager.
     Instead, all text can be dumped directly into the Eshell buffer.
     This is accomplished by setting the value of =$PAGER= to =cat=.

     #+BEGIN_SRC emacs-lisp
       (setenv "PAGER" "cat")
     #+END_SRC

*** Post-Load Execution (~:config~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref eshell/config
    :END:

    Add to the list of commands to run in a term buffer.

     #+BEGIN_SRC emacs-lisp
       (defun init-eshell/add-visual-commands ()
         "Add commands to `eshell-visual-commands'."
         (let ((commands (list "alsamixer" "ssh" "top" "tail")))
           (dolist (command commands)
                   (add-to-list 'eshell-visual-commands command))))
       (add-hook 'eshell-mode-hook
                 #'init-eshell/add-visual-commands)
     #+END_SRC

    #+BEGIN_SRC emacs-lisp
      ;; Only write into the current command.
      (add-hook 'eshell-mode-hook 'init-eshell/move-point-on-insert-to-command)
      (add-hook 'eshell-mode-hook (lambda ()
                                    (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)))
      ;; Account for the read-only prompt text when moving to the beginning of the line.
      (evil-define-key 'motion eshell-mode-map
        "H" #'init-eshell/beginning-of-maybe-line)
    #+END_SRC

**** Keybinding
     Have to rebind in hooks.

***** Bury Eshell Buffer
      Bury the current buffer with =C-d=.

      #+BEGIN_SRC emacs-lisp
	(defun init-eshell/keybinding/bury-buffer ()
	  (define-key eshell-mode-map (kbd "C-d") #'bury-buffer))
      #+END_SRC

      #+BEGIN_SRC emacs-lisp
	(add-hook 'eshell-mode-hook #'init-eshell/keybinding/bury-buffer)
      #+END_SRC

**** Open Eshell in a Given Directory
     Define a function to start an Eshell instance in a given directory.

     #+BEGIN_SRC emacs-lisp
       (defun init-eshell/find-eshell (directory)
         "Open Eshell in DIRECTORY.

       If an Eshell instance for the directory already exists, switch to it.
       If no such instance exists, start a new instance whose name includes the directory."
         (interactive
          (let ((cwd (if (buffer-file-name)
                         (file-name-directory (buffer-file-name))
                       default-directory))
                (must-exist t))
            (list (read-directory-name "Open Eshell in: " cwd cwd must-exist))))
         ;; Set the directory to open Eshell in.
         (let ((eshell-buffer-name (concat "*eshell: "
                                           (abbreviate-file-name directory)
                                           "*"))
               (default-directory directory))
           ;; Start Eshell.
           (eshell)))
     #+END_SRC

     Map the above function to =C-x z=.
     This keybinding mirrors the defaults for ~find-file~ and ~dired~.

     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "C-x z") #'init-eshell/find-eshell)
     #+END_SRC

**** Open Eshell in the Current Directory
     Define a function to open an Eshell instance in the current directory.
     If an Eshell instance already exists in that directory, switch to its buffer.

     #+BEGIN_SRC emacs-lisp
       (defun init-eshell/find-eshell-here ()
         "Open Eshell in the current working directory.

       If an Eshell instance for the directory already exists, switch to it.
       If no such instance exists, start a new instance whose name includes the directory."
         (interactive)
         (let ((cwd (abbreviate-file-name (if (buffer-file-name)
                                              (file-name-directory (buffer-file-name))
                                            default-directory))))
           (init-eshell/find-eshell cwd)))
     #+END_SRC

     Map the above ~init-eshell/find-eshell-here~ function to =C-z=.
     This imitates the behavior of terminal usage, where =C-z= is the key combination to suspend the current process, usually resulting in the user being returned to their shell.

     #+BEGIN_SRC emacs-lisp
       (let ((states (list 'emacs 'insert 'motion 'normal 'operator 'replace 'visual)))
         (dolist (state states)
           (evil-global-set-key state (kbd "C-z") #'init-eshell/find-eshell-here)))
     #+END_SRC

**** Advise ~eshell/cd~ to Rename Buffer
     ~eshell/cd~ is advised to rename the buffer.
     The new name contains the abbreviated path of the new directory.

     This is useful in distinguishing multiple Eshell buffers, e.g. when switching buffers.
     It also works in tandem with ~init-eshell/find-eshell-here~ to prefer existing Eshell instances over creating new buffers.

     #+BEGIN_SRC emacs-lisp
       (defadvice eshell/cd (after init-eshell-cd-rename-buffer)
         "Rename the buffer with the abbreviation of the new directory."
         (let ((cwd (abbreviate-file-name default-directory)))
           (rename-buffer (concat "*eshell: " cwd "*"))))
     #+END_SRC

**** Use Magit for Some ~git~ Commands
     The code in this section is copyright Gergely Nagy [[mailto:algernon@bonehunter.rulez.org][<algernon@bonehunter.rulez.org>]] and shared under GPLv3.

     #+BEGIN_SRC emacs-lisp
       (defun eshell/git (command &rest args)
         (pcase command
           ;; Use magit's log.
           ("log" (apply #'algernon/git-log args))
           ;; Use magit's status.
           ("status" (progn
                       (magit-status)
                       (eshell/echo)))
           ;; Run all other commands directly in `git'.
           (_ (let ((command (s-join " " (append (list "git" command) args))))
                (message command)
                (shell-command-to-string command)))))
     #+END_SRC

     Run ~magit-log~ after determining if the argument to ~git log~ was a file or branch.

     #+BEGIN_SRC emacs-lisp
       (defun algernon/git-log (&rest args)
	 (let* ((branch-or-file (car args))
		(file-list (if (and branch-or-file (f-file-p branch-or-file))
			       args
			     (cdr args)))
		(branch (if (and branch-or-file (f-file-p branch-or-file))
			    "HEAD"
			  branch-or-file)))
	   (message branch-or-file)
	   (if branch-or-file
	       (magit-log (list branch)
			  '()
			  (mapcar
			   (lambda (f) (concat (file-name-as-directory (eshell/pwd)) f))
			   file-list))
	     (magit-log-head)))
	 (eshell/echo))
     #+END_SRC

** Load ~esh-module~
   #+BEGIN_SRC emacs-lisp :tangle yes :noweb no-export
     (use-package esh-module
       ;; This package is included in Emacs.
       :straight nil

       ;; Load `esh-module' after the following packages.
       :after
       (validate)

       :config
       <<esh-module/config>>)
   #+END_SRC

*** Post-Load Execution (~:config~)
    :PROPERTIES:
    :HEADER-ARGS: :noweb-ref esh-module/config
    :END:
    
    Disable the greeting banner.

    #+BEGIN_SRC emacs-lisp
      (validate-setq eshell-modules-list (delq 'eshell-banner eshell-modules-list))
    #+END_SRC

** Load ~em-tramp~
   ~em-tramp~ provides Eshell features that require TRAMP.

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package em-tramp
       ;; This package is included in Emacs.
       :straight nil
   #+END_SRC

** Load em-cmpl
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package em-cmpl
       ;; This package is included in Emacs.
       :straight nil

       ;; Load `em-cmpl' after the following packages.
       :after (validate)

       ;; Evaluate the following code after loading `em-cmpl'.
       :config
       ;; Use zsh-like completion.
       (validate-setq eshell-cmpl-cycle-completions nil))
   #+END_SRC

** Load em-hist
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package em-hist
       ;; This package is included in Emacs.
       :straight nil

       ;; Load `em-hist' after the following packages.
       :after (validate)

       ;; Evaluate the following code after loading `em-hist'.
       :config
       ;; Skip duplicates when traversing command history.
       (validate-setq eshell-hist-ignoredups t))
   #+END_SRC

** Ending Boilerplate						   :noexport:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (provide 'init-eshell)
     ;;; init-eshell.el ends here
   #+END_SRC
