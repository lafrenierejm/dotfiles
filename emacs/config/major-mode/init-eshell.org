#+TITLE: Eshell Initialization
#+AUTHOR: Joseph M LaFreniere (lafrenierejm)
#+EMAIL: joseph@lafreniere.xyz

* License
  All code sections in this =.org= file are licensed under [[https://gitlab.com/lafrenierejm/dotfiles/blob/master/LICENSE][an ISC license]] except when otherwise noted.
  All prose in this file is licensed under [[https://creativecommons.org/licenses/by/4.0/][CC BY 4.0]] except when otherwise noted.

* About This File
  This file contains configuration for [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][Eshell]].
  It is written in the [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style using [[http://orgmode.org/worg/org-contrib/babel/][Org-mode Babel]].

* Eshell Configuration
** Introductory Boilerplate
   #+BEGIN_SRC emacs-lisp :tangle yes :padline no
     ;;; init-eshell.el --- Customization for Eshell

     ;;; Commentary:
     ;; This file is tangled from init-eshell.org.
     ;; Changes made here will be overwritten by changes to that Org-mode file.

     ;;; Code:
   #+END_SRC

** Specify Dependencies
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'use-package)
   #+END_SRC

** Set =$PAGER=
   The fact that Eshell runs entirely within an Emacs buffer negates the need for any external pager.
   All text can instead be dumped directly into the Eshell buffer.

   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; Set $PAGER to cat.
     (setenv "PAGER" "cat")
   #+END_SRC

** Load esh-module
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package esh-module
       :demand                               ; do not defer loading

       :straight nil                    ; do not download using straight.el

       :after        ; load the parent package after the following packages
       (eshell validate)

       :config
       ;; Disable the greeting banner.
       (setq eshell-modules-list (delq 'eshell-banner eshell-modules-list)))
   #+END_SRC

** Load esh-mode
   #+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
     (use-package esh-mode
       :demand

       :straight nil

       :after
       (esh-util esh-module esh-cmd esh-io esh-var)

       :config
       <<esh-mode-config>>
       )
   #+END_SRC

*** Post-Load Execution
    :PROPERTIES:
    :noweb-ref: esh-mode-config
    :END:

**** Only Write the Current Command
     Because I am not interested in existing shell output, the only valid position where I want to insert text in an Eshell buffer is when composing the current command.
     The composition of the current command takes place in the last line of the buffer past Eshell's prompt.
     The following algorithm ensures that I am inserting in a valid position when added as a hook on entering insert mode:

     1. If =point= is not on the last line of the buffer then move =point= to =point-max=.
       	In Eshell =point-max= is always part of the current command.
     2. Otherwise if the text at =point= is read-only then move =point= to the character where that text property changes.

     I posted the following code as [[https://stackoverflow.com/a/46937891/8468492][an answer on StackOverflow]].
     As such, this code is licensed under [[https://creativecommons.org/licenses/by-sa/3.0/][CC BY-SA 3.0]].

     #+BEGIN_SRC emacs-lisp
       (defun init-eshell/move-point-to-command ()
	 "Move point to the current command.
       If point is not on the last line, move point to the maximum position
       in the buffer.  Else if point is in the Eshell prompt, move it to the
       start of the command."
	 (interactive)
	 (let ((curline (line-number-at-pos))
	       (endline (line-number-at-pos (point-max))))
	   (if (= curline endline)
	       (if (not (eobp))
		   (let ((old (point)))        ; Get the current position as OLD.
		     (eshell-bol)              ; Move to beginning of current command.
		     (if (<= (point) old)      ; If point now before OLD...
			 (goto-char old)       ; ...move it back to OLD.
		       nil)))                  ; Otherwise keep as is.
	     (goto-char (point-max)))))

       (defun init-eshell/move-point-on-insert-to-command ()
	 "Move point to edit the current command when insert mode is entered."
	 (add-hook 'evil-insert-state-entry-hook
		   'init-eshell/move-point-to-command
		   nil
		   t))
     #+END_SRC

**** Define Eshell-Specific ~beginninG-of-maybe-line~
     [[../minor-mode/init-evil.org][init-evil.org]] defines ~init/beginning-of-maybe-line~.
     That function acts as a do-what-I-mean alternative to the built-in =beginning-of-line= by incrementally jumping to the beginning of text sections within a line.

     =init-eshell/beginning-of-maybe-line= moves =point= toward the beginning of the current line incrementally by semantic region.
     1. If point is in the text of a command, point will be moved to the beginning of the command.
     2. If the current line has leading whitespace and point is somewhere after that whitespace, point will be moved to the first non-whitespace character.
     3. Point will be moved to the beginning of the line.

     #+BEGIN_SRC emacs-lisp :tangle yes
       (defun init-eshell/beginning-of-maybe-line ()
         "Move point to the start of the command beginning of the line."
         (interactive)
         (let ((old-point (point)))   ; Get current position.
           (eshell-bol)               ; Move to beginning of current command.
           (when (or (<= old-point (point))
                     (= (point-at-bol) (point)))
             (back-to-indentation) ; Go to the first significant column
             ;; If already at or before the first significant column...
             (when (<= old-point (point))
               ;; Then go to the beginning of the line.
               (beginning-of-line)))))
     #+END_SRC

** Load eshell
   #+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
     (use-package eshell
       :demand                               ; do not defer loading

       :straight                        ; recipe for straight.el
       nil

       :after        ; load the parent package after the following packages
       (esh-mode evil ivy)

       :defines   ; variables provided by the parent package and used below
       (eshell-banner
        eshell-cmpl-cycle-completions
        eshell-mode-hook
        eshell-modules-list)

       :config   ; code to execute after the parent package has been loaded
       <<eshell/config>>)
   #+END_SRC

*** Post-Load Execution
    :PROPERTIES:
    :noweb-ref: eshell/config
    :END:

    Add to the list of commands to run in a term buffer.

     #+BEGIN_SRC emacs-lisp
       (defun init-eshell/add-visual-commands ()
         "Add commands to `eshell-visual-commands'."
         (let ((commands (list "alsamixer" "ssh" "top" "tail")))
           (dolist (command commands)
                   (add-to-list 'eshell-visual-commands command))))
       (add-hook 'eshell-mode-hook
                 #'init-eshell/add-visual-commands)
     #+END_SRC

    #+BEGIN_SRC emacs-lisp
      ;; Only write into the current command.
      (add-hook 'eshell-mode-hook 'init-eshell/move-point-on-insert-to-command)
      (add-hook 'eshell-mode-hook (lambda ()
                                    (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)))
      ;; Account for the read-only prompt text when moving to the beginning of the line.
      (evil-define-key 'motion eshell-mode-map
        "H" #'init-eshell/beginning-of-maybe-line)
    #+END_SRC

    Define a function to open an Eshell instance in the current directory.
    If an Eshell instance already exists in that directory, switch to its buffer.

    #+BEGIN_SRC emacs-lisp
      (defun init-eshell/here ()
        "Open an eshell in the current working directory.
      If an eshell instance for the directory already exists, switch to it.
      If no such buffer exists, start a new eshell and rename its buffer to include the directory."
        (interactive)
        (let* ((cwd (abbreviate-file-name (if (buffer-file-name)
                                              (file-name-directory (buffer-file-name))
                                            default-directory)))
               (eshell-buffer-name (concat "*eshell: " cwd "*")))
          (eshell)))
    #+END_SRC

    Map the above ~init-eshell/here~ function to =C-z=.
    This imitates the behavior of terminal usage, where =C-z= is the key combination to suspend the current process, usually resulting in the user being returned to their shell.

    #+BEGIN_SRC emacs-lisp
      (let ((states (list 'emacs 'insert 'motion 'normal 'operator 'replace 'visual)))
        (dolist (state states)
          (evil-global-set-key state (kbd "C-z") #'init-eshell/here)))
    #+END_SRC

**** Advise ~eshell/cd~ to Rename Buffer
     ~eshell/cd~ is advised to rename the buffer.
     The new name contains the abbreviated path of the new directory.

     This is useful in distinguishing multiple Eshell buffers, e.g. when switching buffers.
     It also works in tandem with ~init-eshell/here~ to prefer existing Eshell instances over creating new buffers.

     #+BEGIN_SRC emacs-lisp
       (defadvice eshell/cd (after init-eshell-cd-rename-buffer)
         "Rename the buffer with the abbreviation of the new directory."
         (let ((cwd (abbreviate-file-name default-directory)))
           (rename-buffer (concat "*eshell: " cwd "*"))))
     #+END_SRC

**** Use Magit for Some ~git~ Commands
     The code in this section is copyright Gergely Nagy <algernon@bonehunter.rulez.org> and shared under GPLv3.

     #+BEGIN_SRC emacs-lisp
       (defun eshell/git (command &rest args)
         (pcase command
           ;; Use magit's log.
           ("log" (apply #'algernon/git-log args))
           ;; Use magit's status.
           ("status" (progn
                       (magit-status)
                       (eshell/echo)))
           ;; Run all other commands directly in `git'.
           (_ (let ((command (s-join " " (append (list "git" command) args))))
                (message command)
                (shell-command-to-string command)))))
     #+END_SRC

     Run ~magit-log~ after determining if the argument to ~git log~ was a file or branch.

     #+BEGIN_SRC emacs-lisp
       (defun algernon/git-log (&rest args)
         (let* ((branch-or-file (car args))
                (file-list (if (and branch-or-file (f-file-p branch-or-file))
                               args
                             (cdr args)))
                (branch (if (and branch-or-file (f-file-p branch-or-file))
                            "HEAD"
                          branch-or-file)))
           (message branch-or-file)
           (if branch-or-file
               (magit-log (list branch)
                          '()
                          (mapcar
                           (lambda (f) (concat (file-name-as-directory (eshell/pwd)) f))
                           file-list))
             (magit-log-head)))
         (eshell/echo))
     #+END_SRC

** Load em-tramp
   em-tramp provides Eshell features that require TRAMP.

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package em-tramp
       :demand                               ; do not defer loading

       :straight nil                    ; do not download using straight.el

       :after        ; load the parent package after the following packages
       (eshell tramp)

       :config
       (add-to-list 'eshell-modules-list 'eshell-tramp))
   #+END_SRC

** Load em-cmpl
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package em-cmpl
       :demand                               ; do not defer loading

       :straight nil                       ; do not manage with straight.el

       :after        ; load the parent package after the following packages
       (eshell validate)

       ;; :defines        ; variables used below defined by the parent package
       ;; (eshell-cmpl-cycle-completions)

       :config           ; code to execute after loading the parent package
       ;; Use zsh-like completion.
       (validate-setq eshell-cmpl-cycle-completions nil))
   #+END_SRC

** Load em-hist
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package em-hist
       :demand                               ; do not defer loading

       :straight nil             ; included as part of the ~eshell' package

       :after        ; load the parent package after the following packages
       (eshell validate)

       ;; :defines        ; variables used below defined by the parent package
       ;; (eshell-hist-ignoredups)

       :config          ; code to execute after loading the parent package
       ;; Skip duplicates when traversing command history.
       (validate-setq eshell-hist-ignoredups t))
   #+END_SRC

** Ending Boilerplate
   #+BEGIN_SRC emacs-lisp :tangle yes
     (provide 'init-eshell)
     ;;; init-eshell.el ends here
   #+END_SRC
