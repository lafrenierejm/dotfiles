#+TITLE: Emacs Configuration
#+AUTHOR: Joseph LaFreniere (lafrenierejm)
#+EMAIL: joseph@lafreniere.xyz
#+PROPERTY: header-args+ :noweb yes

#+BEGIN_SRC emacs-lisp :tangle yes
;;; init.el --- Configure Emacs  -*- lexical-binding: t; -*-

;; Copyright (C) 2018 Joseph LaFreniere

;; Author: Joseph LaFreniere <joseph@lafreniere.xyz>
;; Version 0.1

;; <<license>>

;;; Commentary:
;; <<commentary>>

;;; Code:
<<bootstrapping>>

;;; Dependencies:
<<dependencies>>

;;; Customization:
<<customization>>

;;; Visual Interface:
<<interface>>

;;; Buffer Organization:
<<buffer-organization>>

;;; Literate Programming:
<<literate-programming>>

;;; Keybindings:
<<keybindings>>

;;; Minibuffer:
<<minibuffer>>

;;; TRAMP:
<<tramp>>

;;; Version Control:
<<version-control>>

;;; Completion
<<completion>>

;;; Containers:
<<containers>>

;;; Diff:
<<diff>>

;;; Directories:
<<directories>>

;;; Command Interpretation:
<<command-interpretation>>

;;; Static Analysis:
<<static-analysis>>

;;; Feeds:
<<feeds>>

;;; PDF:
<<pdf>>

;;; Programming Languages:
<<programming-languages>>

;;; RESTful APIs:
<<restful-apis>>

;;; Project Management:
<<project-management>>

;;; Windows and Frames
<<windows-and-frames>>

;;; Secret Management:
<<secret-management>>

(provide 'init)
;;; init.el ends here
#+END_SRC

* License
** Code
All source code in this file is licensed under the [[http://www.gnu.org/licenses/gpl-3.0.html][GNU Public License v3]] or later.
#+BEGIN_SRC text :noweb-ref license
This file is not part of GNU Emacs.

Init is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

Init is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with GNU Emacs.
If not, see <https://www.gnu.org/licenses/>.
#+END_SRC

** Prose

All prose in this file is licensed under the [[http://www.gnu.org/licenses/fdl-1.3.html][GNU Free Documentation License (FDL) v1.3]].
#+BEGIN_SRC text
Copyright (C) 2019 Joseph LaFreniere.
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
#+END_SRC

* Commentary
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref commentary
:END:

#+BEGIN_SRC text
This is tangled source of Joseph LaFreniere (lafrenierejm)'s literate Emacs initialization file.
Please refer to `init.org' in this same directory for full commentary.
#+END_SRC

* Bootstrapping
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref bootstrapping
:END:

GNU Emacs does not have the capability to use an Org file directly as its initialization file.
As such, this file needs to be tangled manually for its first use on a new system.
The following code ensures that this step is only needed once.

** Package Management

#+BEGIN_SRC emacs-lisp
(cond
 ((executable-find "guix")
  <<bootstrapping/guix>>)
 (t
  <<bootstrapping/straight>>))
#+END_SRC

*** Guix
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref bootstrapping/guix
:END:

Emacs packages can be managed as any other package with Guix.
As such, Emacs's native package management tools can be used.
Before any other installed packages can be configured, /Package/ must be loaded and initialized.
#+BEGIN_SRC emacs-lisp
(require 'package)
(package-initialize)
#+END_SRC

**** ~:straight~ keyword in \src_emacs-lisp{use-package}
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref use-package/guix
:END:

Because I also use /Straight/ to manage packages on non-Guix systems, I need to account for instances where I use the ~:straight~ keyword in \src_emacs-lisp{use-package} macros.
This is accomplished by requesting \src_emacs-lisp{use-package} to just ignore any unkown keywords rather than raise errors.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'use-package-core
  (setq use-package-ignore-unknown-keywords t))
#+END_SRC

*** Straight
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref bootstrapping/straight
:END:

Specify the branch to download /Straight/ from.
#+BEGIN_SRC emacs-lisp
(setq straight-repository-branch "develop")
#+END_SRC

Download and load /Straight/.
#+BEGIN_SRC emacs-lisp
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         (format
          "https://raw.githubusercontent.com/raxod502/straight.el/%s/install.el"
          straight-repository-branch)
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC

**** Use Package
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref use-package/straight
:END:

Download /Use Package/.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
#+END_SRC

Configure \src_emacs-lisp{use-package} to download packages with /Straight/ by default.
#+BEGIN_SRC emacs-lisp
(setq straight-use-package-by-default t)
#+END_SRC

** Use Package

#+BEGIN_SRC emacs-lisp
(when (not (executable-find "guix"))
  <<use-package/straight>>)
#+END_SRC

Next, /Use Package/ is loaded.
This package provides the \src_emacs-lisp{use-package} macro for declarative loading of other packages.
#+BEGIN_SRC emacs-lisp
(require 'use-package)
#+END_SRC

Loading every package during Emacs's initialization is unnecessary and increases load time.
Instead, packages should only be loaded when a feature they provide is actually needed.
/Use Package/ provides a feature to lazy-load packages by default:
#+BEGIN_SRC emacs-lisp
(setq use-package-always-defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (executable-find "guix")
  <<use-package/guix>>)
#+END_SRC

** Org
:PROPERTIES:
:CUSTOM_ID: bootstrap/org
:END:

After /Use Package/ has been loaded, we can use it to configure all other packages.
Tangling this Org file for use as Emacs's initialization file requires features from the /Org/ package.
As such, the below function is specified to belong to the =:config= section of /Org/'s \src_emacs-lisp{use-package} declaration.
The process of tangling this file is to
1. Compare the modification time of this file to its tangled source, =./init.el=.
2. If this file is the more recent of the two, tangle this file then byte compile and load the result.
3. Otherwise the tangled file is the more recent, so byte compile and load it directly.

#+BEGIN_SRC emacs-lisp :noweb-ref org/config
(defun org-babel-tangle-init ()
  "Tangle Emacs's init file."
  (let ((el-file user-init-file)
        (org-file "~/.config/emacs/init.org")
        (load-byte-compile t))
    (if (not (file-exists-p el-file))
        ;; If the Emacs Lisp file does not exist, tangle the Org file.
        (org-babel-tangle-file org-file)
      ;; If the Emacs Lisp file does exist, compare the modification times.
      (let* ((org-modify (modify-time org-file))
             (el-modify (modify-time el-file)))
        ;; If the Org file was modified more recently, tangle it.
        (when (< el-modify org-modify)
          (org-babel-tangle-file org-file))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :noweb-ref org/config
(defun modify-time (file)
  (-> (file-attributes file)
      (file-attribute-modification-time)
      (float-time)))
#+END_SRC

** General
/General/ provides convenience wrappers for setting keybindings and adding hooks.
It is highly compatible with /Use Package/ and provides additional keywords to the \src_emacs-lisp{use-package} macro.
/General/ is loaded now just so it can be used in all further \src_emacs-lisp{use-package} declarations.
The ~:demand~ keyword is used to ensure General is loaded eagerly.
#+BEGIN_SRC emacs-lisp
(use-package general
  :demand)
#+END_SRC

* Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref customization
:END:

Emacs has a customization system distinct from simply \src_emacs-lisp{setq}-ing variables.
By default, any customizations made using that system are appended to the bottom of Emacs's init file.
This is controlled by the value of the \src_emacs-lisp{custom-file} variable.
That variable is provided as part of the Cus Edit package, so we will perform modifications inside the \src_emacs-lisp{use-package} declaration of Cus Edit.

Viewing the help documentation for \src_emacs-lisp{custom-file} (via =C-h v custom-file RET=) tells us
#+BEGIN_QUOTE
The default is nil, which means to use your init file as specified by \src_emacs-lisp{user-init-file}.
If the value is not \src_emacs-lisp{nil}, it should be an absolute file name.

You can set this option through Custom, if you carefully read the last paragraph below.
However, usually it is simpler to write something like the following in your init file:

#+BEGIN_EXAMPLE emacs-lisp
(setq custom-file "~/.emacs-custom.el")
(load custom-file)
#+END_EXAMPLE
#+END_QUOTE

That \src_emacs-lisp{setq} and \src_emacs-lisp{load} need to be evaluated /after/ Cus Edit has been loaded, so the expressions should go in the ~:config~ block of the \src_emacs-lisp{use-package} declaration.
Additionally, \src_emacs-lisp{custom-file} needs to exist before it is loaded.
The file can be created with the function \src_emacs-lisp{f-touch}.

\src_emacs-lisp{f-touch}, in turn, is provided by the package F.
Since we are relying a function from an external package when we're loading Cus Edit, we need to inform \src_emacs-lisp{use-package} of that fact and tell it to load Cus Edit only after F has been loaded.
This is done with the ~:after~ keyword of \src_emacs-lisp{use-package}.

Additionally, we want Cus Edit to always be loaded (not just when we interactively use something it provides).
\src_emacs-lisp{use-package} needs to told to load Cus Edit eagerly (as opposed to lazily), which is accomplished with the ~:demand~ keyword.

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :straight (:type built-in)

  :after f

  :demand

  :config
  (let ((path (expand-file-name
               "custom.el"
               (file-name-directory user-init-file))))
    (f-touch path)
    (setq custom-file path)
    (load custom-file)))
#+END_SRC

/F/ is not built-in to GNU Emacs, so it must be downloaded by some package manager separately.
Further \src_emacs-lisp{f-touch} is not marked as an auto-loaded function in /F/ (this too can be discovered by viewing the function's help), so /F/ must also be loaded eagerly.

#+BEGIN_SRC emacs-lisp
(use-package f
  :demand)
#+END_SRC

** XDG

/XDG/ provides functions for working with XDG standards and specifications.
It is loaded to override \src_emacs-lisp{xdg-line-regexp}.
By default, that variable only allows reading a few of the most common directory types even though the XDG spec allows setting an arbitrary number of directories in =$XDG_CONFIG_DIR/user-dirs.dirs=.

#+BEGIN_SRC emacs-lisp
(use-package xdg
  :straight (:type built-in)

  :demand

  :config
  (setq xdg-line-regexp
        (rx line-start
            "XDG_" (group (one-or-more upper)) "_DIR="
            "\"" (group (minimal-match (one-or-more anything))) "\""
            line-end)))
#+END_SRC

* Visual Interface
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref interface
:END:

Emacs is fundamentally a user interface built around plain text.
Given the focus on plain text, several of Emacs's default modes can be disabled.
These are
- \src_emacs-lisp{menu-bar-mode},
- \src_emacs-lisp{tool-bar-mode}, and
- \src_emacs-lisp{scroll-bar-mode}.


#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

The splash screen, startup message, and scratch message also serve little use, so they too can be disabled.
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      inhibit-startup-message t
      initial-scratch-message nil)
#+END_SRC

** Font
What are colloquially known as "fonts" Emacs refers to "faces".
Google's Noto family of has the best glyph coverage that I am aware of, so I try to use it everywhere I can.
Alan Third has a nice write-up in his [[https://idiocy.org/emacs-fonts-and-fontsets.html]["Emacs, fonts and fontsets" post on idiocy.org]] of how to enable Noto fonts everywhere and simultaneously reduce Emacs's need to scour the system for fallback font sets.
The /Faces/ package provides this functionality, so all font setup can can occur within /Faces/'s \src_emacs-lisp{use-package}.

#+BEGIN_SRC emacs-lisp
(use-package faces
  :straight (:type built-in)

  :demand

  :config
  (when (member "Noto Sans" (font-family-list))
    (set-face-attribute 'default nil :font "Noto Sans Mono")
    (set-fontset-font t 'latin "Noto Sans")

    ;; East Asia: 你好, 早晨, こんにちは, 안녕하세요
    (set-fontset-font t 'han "Noto Sans CJK SC Regular")
    (set-fontset-font t 'kana "Noto Sans CJK JP Regular")
    (set-fontset-font t 'hangul "Noto Sans CJK KR Regular")
    (set-fontset-font t 'cjk-misc "Noto Sans CJK KR Regular")

    ;; South East Asia: ជំរាបសួរ, ສະບາຍດີ, မင်္ဂလာပါ, สวัสดีครับ
    (set-fontset-font t 'khmer "Noto Sans Khmer")
    (set-fontset-font t 'lao "Noto Sans Lao")
    (set-fontset-font t 'burmese "Noto Sans Myanmar")
    (set-fontset-font t 'thai "Noto Sans Thai")

    ;; Africa: ሠላም
    (set-fontset-font t 'ethiopic "Noto Sans Ethiopic")

    ;; Middle/Near East: שלום, السّلام عليكم
    (set-fontset-font t 'hebrew "Noto Sans Hebrew")
    (set-fontset-font t 'arabic "Noto Sans Arabic")

    ;;  South Asia: નમસ્તે, नमस्ते, ನಮಸ್ಕಾರ, നമസ്കാരം, ଶୁଣିବେ,
    ;;              ආයුබෝවන්, வணக்கம், నమస్కారం, བཀྲ་ཤིས་བདེ་ལེགས༎
    (set-fontset-font t 'gujarati "Noto Sans Gujarati")
    (set-fontset-font t 'devanagari "Noto Sans Devanagari")
    (set-fontset-font t 'kannada "Noto Sans Kannada")
    (set-fontset-font t 'malayalam "Noto Sans Malayalam")
    (set-fontset-font t 'oriya "Noto Sans Oriya")
    (set-fontset-font t 'sinhala "Noto Sans Sinhala")
    (set-fontset-font t 'tamil "Noto Sans Tamil")
    (set-fontset-font t 'telugu "Noto Sans Telugu")
    (set-fontset-font t 'tibetan "Noto Sans Tibetan")))
#+END_SRC

When working with prose, I prefer to use a variable-pitch (as opposed to monospace) face.
Frequently, though, some aspects of a mostly-prose document are better presented in monospace.
An example of this is the code blocks in this Org file.
For mixing the two pitches I use the /Mixed Pitch/ package by Alex Branham.

#+BEGIN_SRC emacs-lisp
(use-package mixed-pitch
  :ghook
  ('(org-mode-hook text-mode-hook) #'mixed-pitch-mode))
#+END_SRC

** Rainbow Identifiers
Rainbow Identifiers provides a minor mode that highlights identifiers based on their names.
The highlight color of each identifier is chosen based on the hash of the identifier's name.
The package's source is available at [[https://github.com/Fanael/rainbow-identifiers][github.com/Fanael/rainbow-identifiers]].

I want this package to be enabled when programming, so I enable it for \src_emacs-lisp{prog-mode} and all major modes that inherit from \src_emacs-lisp{prog-mode}, which effectively covers all programming language major modes.
This is done by adding \src_emacs-lisp{rainbow-identifiers-mode} to \src_emacs-mode{prog-mode-hook}, performed below by the arguments to the ~:ghook~ keyword[fn:1].

#+BEGIN_SRC emacs-lisp
(use-package rainbow-identifiers
  :ghook
  ('prog-mode-hook #'rainbow-identifiers-mode)

  :custom
  <<rainbow-identifiers/custom>>)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref rainbow-identifiers/custom
:END:

Only use Rainbow Identifiers to highlight (read: color) variable names.

#+BEGIN_SRC emacs-lisp
(rainbow-identifiers-faces-to-override
 '(font-lock-constant-face
   font-lock-type-face
   font-lock-function-name-face
   font-lock-variable-name-face
   font-lock-keyword-face
   font-lock-builtin-face))
#+END_SRC

** Rainbow Delimiters
Rainbow Delimters provides a minor mode that highlights delimeters such as parantheses based on their depth.
The highlight color of each level is distinct.
The package's source is available at [[https://github.com/Fanael/rainbow-delimiters][github.com/Fanael/rainbow-delimeters]].

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  ;; Load this package eagerly.
  :demand

  :ghook
  ('prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Loaddefs

#+BEGIN_SRC emacs-lisp
(use-package loaddefs
  :straight (:type built-in)

  :demand

  :config
  (show-paren-mode +1))
#+END_SRC

** Line Wrapping
Out of the box, Emacs will fill paragraph to 72 characters.
Most projects that care about line width adhere to an 80 character (79 + line feed) maximum width, so to reduce the amount of per-project customization we can set the default value to 80.
#+BEGIN_SRC emacs-lisp
(custom-set-default 'fill-column 80)
#+END_SRC

** Display Line Numbers

#+BEGIN_SRC emacs-lisp
(use-package display-line-numbers
  :straight (:type built-in)

  ;; Only load this package if the following code evaluates to non-nil.
  :if
  <<display-line-numbers/if>>

  ;; Add the following auto-loading hooks.
  :ghook
  ('prog-mode-hook #'display-line-numbers-mode))
#+END_SRC

*** Conditional Loading
:PROPERTIES:
:DESCRIPTION: Define condition for loading ~display-line-numbers~.
:HEADER-ARGS+: :noweb-ref display-line-numbers/if
:END:

~display-line-numbers~ was added in GNU Emacs 26.1.

#+BEGIN_SRC emacs-lisp
(version< "26.1" emacs-version)
#+END_SRC

* Buffer Organization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref buffer-organization
:END:

** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  <<projectile/general>>

  ;; Customize the following variables.
  :custom
  <<projectile/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<projectile/config>>)
#+END_SRC

*** Auto-Loading Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref projectile/general
:END:

#+BEGIN_SRC emacs-lisp
(:keymaps 'projectile-mode-map
 "C-c p" 'projectile-command-map
 "C-x g" #'projectile-vc)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref projectile/custom
:END:

Enable ~projectile-mode~ globally.
#+BEGIN_SRC emacs-lisp
(projectile-mode t)
#+END_SRC

When switching projects, default to opening the ~vc-dir~ at the root of the project.
#+BEGIN_SRC emacs-lisp
(projectile-switch-project-action #'projectile-vc)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref projectile/config
:END:

Use Ivy's integration.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ivy
  (setq projectile-completion-system 'ivy))
#+END_SRC

** Counsel Projectile

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  ;; Load this package after the following packages.
  :after (:all counsel projectile)

  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  (:keymaps 'projectile-mode-map
   "C-x C-f" #'counsel-projectile-find-file
   "C-x C-b" #'counsel-projectile-switch-to-buffer
   "C-x C-d" #'counsel-projectile-find-dir)

  ;; Customize the following variables.
  :custom
  <<counsel-projectile/custom>>)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref counsel-projectile/custom
:END:

Enable ~counsel-projectile-mode~ globally.
#+BEGIN_SRC emacs-lisp
(counsel-projectile-mode t)
#+END_SRC

Do not display the current project when switching projects.
#+BEGIN_SRC emacs-lisp
(counsel-projectile-remove-current-project t)
#+END_SRC

Do not display the current buffer when switching buffers..
#+BEGIN_SRC emacs-lisp
(counsel-projectile-remove-current-buffer t)
#+END_SRC

** Perspective

/Perspective/ provides tagged workspaces.
#+BEGIN_SRC emacs-lisp
(use-package perspective
  ;; Load this package eagerly.
  :demand

  ;; Customize variables.
  :custom
  (persp-mode t "Enable perspective mode globally"))
#+END_SRC

** Operations on Current Buffer

*** Get Arguments for Interactive Call

**** Get a Buffer to Use

#+BEGIN_SRC emacs-lisp
(defun current-buffer~obj-to-buffer (&optional buffer)
  "Get the buffer to use.

If BUFFER is nil, use the current buffer.
Else if BUFFER is a string, use that string as the name of the buffer.
Else throw an error."
  (cond
   ;; If no BUFFER was provided...
   ((not buffer)
    ;; Return the current buffer.
    (get-buffer (buffer-name)))
   ;; Else if BUFFER is an editor buffer...
   ((bufferp buffer)
    ;; Return BUFFER as-is.
    buffer)
   ;; Else if BUFFER is a string...
   ((stringp buffer)
    ;; Return the corresponding buffer object.
    (get-buffer buffer))
   ;; Else...
   (t
    ;; Throw an error.
    (error "Invalid BUFFER argument %s of type %s passed"
           buffer
           (type-of buffer)))))
   #+END_SRC

**** Buffer to Rename

If called as part of an interactive function with a prefix argument, prompt the user to provide a buffer.
Otherwise use the current buffer.

#+BEGIN_SRC emacs-lisp
(defun current-buffer~get-buffer (verb)
  (if current-prefix-arg
      (get-buffer (read-buffer (format "Buffer to %s with visiting file: "
                                       verb)
                               (get-buffer (buffer-name))))))
#+END_SRC

**** New File Name

The user shall be prompted for the new file path.

#+BEGIN_SRC emacs-lisp
(defun current-buffer~read-file-name (verb buffer-name)
  "Prompt the user for the destination of applying VERB to BUFFER-NAME's visiting file."
  (read-file-name (format "%s the file visited by buffer %s to: "
                          verb
                          buffer-name)))
#+END_SRC

*** Rename
:PROPERTIES:
:DESCRIPTION: Rename a buffer and its visited file, if any.
:END:

#+BEGIN_SRC emacs-lisp
(defun current-buffer/rename (new-file-name &optional buffer ok-if-already-exists)
  "Rename a buffer and the file it's visiting, if any, to NEW-FILE-NAME.

If BUFFER is not provided, use the current buffer.
If BUFFER is a string, use that string as the name of the buffer to rename.
If BUFFER is a buffer object, use it as the subject of the rename.

OK-IF-ALREADY-EXISTS is passed directly to `rename-file'."
  ;; If called interactively...
  (interactive (let* ((buffer (current-buffer~get-buffer "rename"))
                      (new-file-name
                       (current-buffer~read-file-name "rename"
                                                      (buffer-name buffer)))
                      (ok-if-already-exists 1)) ; Request confirmation before overwrite.
                 (list new-file-name buffer ok-if-already-exists)))
  (let* ((buffer (current-buffer~obj-to-buffer buffer))
         (file (buffer-file-name buffer))
         (orig-buffer-name (buffer-name buffer))
         (new-buffer-name nil))
    (cond
     ;; If FILE is tracked in VC...
     ((vc-backend file)
      ;; Rename FILE through VC.
      (vc-rename-file file new-file-name))
     ;; Else if FILE exists at all...
     ((file-exists-p file)
      ;; Rename FILE normally.
      (rename-file file new-file-name ok-if-already-exists)))
    ;; Rename BUFFER, using `generate-new-buffer-name' if necessary.
    ;; Record the name actually assigned.
    (setq new-buffer-name (rename-buffer new-file-name t))
    (set-visited-file-name new-file-name t t)
    (message "Renamed buffer %s to %s and its file to %s."
             orig-buffer-name new-buffer-name
             new-file-name)))
#+END_SRC

Now bind the above function.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-r") #'current-buffer/rename)
#+END_SRC

*** Delete
:PROPERTIES:
:DESCRIPTION: Delete a buffer and its visited file, if any.
:END:

#+BEGIN_SRC emacs-lisp
(defun current-buffer/delete (&optional buffer)
  "Delete the file a buffer is visiting, if any, then kill the buffer.

If no optional BUFFER is provided, use the current buffer.
If the optional BUFFER is a string, use that string as the name of the buffer to use.
If the optional BUFFER is a symbol, prompt the user for the name of the buffer to use."
  ;; If called interactively...
  (interactive (list (current-buffer~get-buffer "delete")))
  (let* ((buffer (current-buffer~obj-to-buffer buffer))
         (file (buffer-file-name buffer)))
    (when file
      (cond
       ;; If FILE is tracked in VC, delete it through VC.
       ((vc-backend file)
        (vc-delete-file file))
       ;; Else if FILE exists, delete it normally.
       ((file-exists-p file)
        (delete-file file 'trash)))
      (message "Deleted file %s" file))
    (kill-buffer buffer)))
#+END_SRC

Now bind the above function.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-S-d") #'current-buffer/delete)
#+END_SRC

*** Copy

#+BEGIN_SRC emacs-lisp
(defun current-buffer/copy
    (new-file-name
     &optional buffer confirm-overwrite keep-time preserve-uid-gid perserve-permissions)
  "Copy the file a buffer is visiting, if any, to NEW-FILE-NAME and open the copy in a new buffer.

If BUFFER is not provided, use the current buffer.
If BUFFER is a string, use that string as the name of the buffer to rename.
If BUFFER is a buffer object, use it as the subject of the rename.

If the specified buffer is not visiting a file, write the buffer's contents to NEW-FILE-NAME.

If CONFIRM-OVERWRITE is non-nil, this function asks for confirmation before overwiting an existing file at NEW-FILE-NAME.
Interactively, confirmation is required unless a prefix argument is supplied.

KEEP-TIME, PRESERVE-UID-GID, and PRESERVE-PERMISSIONS are passed directly to `copy-file'."
  ;; If called interactively...
  (interactive (let* ((buffer (current-buffer~get-buffer "copy"))
                      (new-file-name (current-buffer~read-file-name "copy" (buffer-name buffer)))
                      ;; Request confirmation before overwriting an existing file, unless called with a prefix argument.
                      (confirm-overwrite (if current-prefix-arg t 1)))
                 (list new-file-name buffer confirm-overwrite)))
  (let* ((buffer (current-buffer~obj-to-buffer buffer))
         (file (buffer-file-name buffer))
         (new-buffer-name (buffer-name buffer)))
    ;; If BUFFER is not visiting a file...
    (if (not (file-exists-p file))
        ;; Write the content of BUFFER to NEW-FILE-NAME.
        (write-file new-file-name confirm-overwrite)
      ;; Else...
      ;; Copy the visited file FILE to NEW-FILE-NAME.
      (copy-file file
                 new-file-name
                 ;; If CONFIRM-OVERWRITE is non-nil...
                 (if confirm-overwrite
                     ;; Ask for confirmation before overwriting.
                     1
                   ;; Else overwrite without prompting.
                   t)
                 keep-time
                 preserve-uid-gid
                 perserve-permissions)
      ;; Open NEW-FILE-NAME in a separate buffer.
      (setq new-buffer-name (buffer-name (find-file-noselect new-file-name))))
    (message "Wrote buffer %s to %s and opened the new file as %s."
             (buffer-name buffer) new-file-name new-buffer-name)))
#+END_SRC

Now bind the above function.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-c") #'current-buffer/copy)
#+END_SRC

*** Revert

#+BEGIN_SRC emacs-lisp
(defun current-buffer/revert (&optional noconfirm)
  "Replace current buffer text with the text of the visited file on disk.

If NOCONFIRM is nil, prompt the user before reverting a modified buffer.
NOCONFIRM is set to t when called interactively with a prefix argument."
  (interactive (list current-prefix-arg))
  (revert-buffer :ignore-auto (or noconfirm (not (buffer-modified-p)))))
#+END_SRC

Now bind the above function.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-g") #'current-buffer/revert)
#+END_SRC

*** Kill

**** Define Function
:PROPERTIES:
:DESCRIPTION: Kill the current buffer.
:END:

#+BEGIN_SRC emacs-lisp
(defun current-buffer/kill (&optional ignore-buffer-modified-p)
  "Kill the current buffer.

If IGNORE-BUFFER-MODIFIED-P is nil, prompt the user before killing a modified buffer.
IGNORE-BUFFER-MODIFIED-P is set to t when called interactively with a prefix argument."
  (interactive (list current-prefix-arg))
  (when ignore-buffer-modified-p
    (set-buffer-modified-p nil))
  (kill-this-buffer))
#+END_SRC

**** Bind Function

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-k") #'current-buffer/kill)
#+END_SRC

*** Place Visited File Name on Kill Ring

**** Define Function

#+BEGIN_SRC emacs-lisp
(defun current-buffer/yank-path ()
  "Place the path of the current buffer's visited file on the kill ring."
  (interactive)
  (when-let* ((filepath (or (buffer-file-name) default-directory))
              (expanded-filename (expand-file-name filepath)))
    (kill-new expanded-filename)
    (message "Copied buffer path '%s' to the clipboard." expanded-filename)))
#+END_SRC

**** Bind Function

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-y") #'current-buffer/yank-path)
#+END_SRC

*** Visit Current Directory in Dired

**** Define Function

#+BEGIN_SRC emacs-lisp
(defun current-buffer/dired ()
  "Open the current directory in Dired."
  (interactive)
  (when-let* ((file-path (or (buffer-file-name) default-directory))
              (directory-path (file-name-directory file-path)))
    (dired directory-path)))
#+END_SRC

**** Bind Function

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-d") #'current-buffer/dired)
#+END_SRC

* Literate Programming
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref literate-programming
:END:

The [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] programming is a programming paradigm introduced by Donald Knuth in which the standard precedence of code and explanatory prose are flipped.
Whereas the standard programming paradigm has a source documents' text "defaulting" to source code, literate programming assumes that text is intended for human consumption (the role normally filled by comments) unless it is explicitly demarcated as source code.
A literate document can then be /tangled/ into a source-only file.

** Polymode
:PROPERTIES:
:CUSTOM_ID: polymode
:END:

Polymode is a framework for supporting multiple major modes (MMM) inside a single Emacs buffer.
This can benefit both literate and traditional programming by allowing one to code blocks and docstrings, respectively, with the full features of dedicated major modes.

#+BEGIN_SRC emacs-lisp
(use-package polymode
  :demand

  :mode
  <<polymode/mode>>

  ;; Evaluate the following code after loading this package.
  :config
  <<polymode/config>>)
#+END_SRC

** Org Mode
Strong support for literate programming is provided by Org mode's features.

*** Org
:PROPERTIES:
:CUSTOM_ID: bootstrap/org
:END:

Note that although \src_emacs-lisp{use-package} is used below, the /Org/ package should already be loaded due to the \src_emacs-lisp{require} call in [[#bootstrap/org]].

#+BEGIN_SRC emacs-lisp
(use-package org
  :straight (:type built-in)

  :demand

  :gfhook
  <<org/gfhook>>

  :custom
  <<org/custom>>

  :config
  <<org/config>>)
#+END_SRC

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref org/gfhook
:END:

Enable the following minor modes in all Org buffers:
- \src_emacs-lisp{flyspell-mode} for on-the-fly spell checking.
- \src_emacs-lisp{org-indent-mode} to indent text according to outline structure.
- \src_emacs-lisp{visual-line-mode} to naturally wrap long lines.


#+BEGIN_SRC emacs-lisp
('org-mode-hook (list #'flyspell-mode #'org-indent-mode #'visual-line-mode))
#+END_SRC

**** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref org/custom
:END:

Determine how leading whitespace characters in source blocks are treated.
#+BEGIN_SRC emacs-lisp
(org-src-preserve-indentation t "Preserve source blocks' indentation.")
(org-edit-src-content-indentation 0 "Do not add any additional indentation to source blocks in Org buffers.")
#+END_SRC

Determine where source blocks are opened.
Note that this is effectively deprecated by Polymode;  I set it here only as a fallback.
#+BEGIN_SRC emacs-lisp
(org-src-window-setup 'current-window "Edit source blocks in the current window.")
#+END_SRC

Determine what is required to follow links.
#+BEGIN_SRC emacs-lisp
(org-return-follows-link t "Follow links with just RET.")
#+END_SRC

Set whether confirmation is required before evaluating source blocks.
#+BEGIN_SRC emacs-lisp
(org-confirm-babel-evaluate nil "Do not require confirmation before evaluating source blocks.")
#+END_SRC

Set the workflow states.
#+BEGIN_SRC emacs-lisp
(org-todo-keywords '((sequence "TODO" "FEEDBACK" "VERIFY" "|"
                               "DELEGATED" "DONE(d!/!)" "|"
                               "CANCELED")))
#+END_SRC

*** Poly Org

/Poly Org/ provides Polymode definitions for Org buffers.
#+BEGIN_SRC emacs-lisp
(use-package poly-org)
#+END_SRC

*** Ox LaTeX

/Ox/ (Org eXport) allows exporting Org files such as this one.
/Ox LaTeX/ builds uses that framework to export to (La)TeX.

#+BEGIN_SRC emacs-lisp
(use-package ox-latex
  :straight (:type built-in)
  :config
  <<ox-latex/config>>)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ox-latex/config
:END:

If =latexmk= and its Perl dependency exist in =PATH=, use =latexmk= with a LuaLaTeX backend to compile TeX files.
#+BEGIN_SRC emacs-lisp
(when (and (executable-find "latexmk")
           (executable-find "perl"))
  (general-setq-default org-latex-pdf-process '("latexmk -lualatex -f %f")))
#+END_SRC

*** Smartparens
:PROPERTIES:
:HEADER-ARGS+: smartparents/config
:END:

The equals sign (\=), tilde (\~), and forward slash (/) are used by Org syntax to wrap inline monospace, code, text, and italics respectively.
I want them to be automatically paired in Org buffers.
#+BEGIN_SRC emacs-lisp
(sp-local-pair 'org-mode "=" "=")
(sp-local-pair 'org-mode "~" "~")
(sp-local-pair 'org-mode "/" "/")
#+END_SRC

Meanwhile, when writing prose I tend to use the single prime (') primarily as an apostrophe in English prose so I want it to /not/ be paired.
#+BEGIN_SRC emacs-lisp
(sp-local-pair 'org-mode "'" nil :actions nil)
#+END_SRC

*** Evil Org

/Evil Org/ adds a minor mode that provides [[Evil]] keybindings for common Org mode actions.
#+BEGIN_SRC emacs-lisp
(use-package evil-org
  ;; Load this package after the following packages.
  :after (:all evil org)

  ;; Add the following auto-loading hooks.
  :ghook
  <<evil-org/ghook>>

  ;; Add the following non-auto-loading hooks.
  :gfhook
  <<evil-org/gfhook>>

  ;; Inform the bytecode compiler of the following functions.
  :functions
  (evil-org-set-key-theme)

  ;; Apply the following variable customizations.
  :custom
  <<evil-org/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<evil-org/config>>)
#+END_SRC

**** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/ghook
:END:

Enable Evil Org mode in all Org mode buffers.
#+BEGIN_SRC emacs-lisp
('( org-agenda-mode-hook org-mode-hook) #'evil-org-mode)
#+END_SRC

**** Non-Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/gfhook
:END:

Set keys for \src_emacs-lisp{org-mode} and \src_emacs-lisp{org-agenda-mode}.
#+begin_src emacs-lisp
('evil-org-mode-hook #'evil-org-set-key-theme)
#+end_src

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/custom
:END:

Specify the key themes to enable.
#+BEGIN_SRC emacs-lisp
(evil-org-key-theme
 '(calendar
   navigation
   insert
   textobjects))
#+END_SRC

Retain selection after typing =<= or =>= in visual state.
#+BEGIN_SRC emacs-lisp
(evil-org-retain-visual-state-on-shift t)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/config
:END:

Apply the keybindings specified in ~evil-org-key-theme~.
#+BEGIN_SRC emacs-lisp
(evil-org-agenda-set-keys)
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  ;; Inform the bytecode compiler of the following variables.
  :defines markdown-mode-hook

  ;; Inform the bytecode compiler of the following functions.
  :functions markdown-mode-spaces-only

  ;; Established deferred binding within `auto-mode-alist'.
  :mode
  (("README\\.md\\'" . gfm-mode)
   ("\\.md\\'" . markdown-mode))

  ;; Add the following non-autoloading hooks.
  :gfhook
  ('markdown-mode-hook #'markdown-mode-spaces-only)

  :config
  (defun markdown-mode-spaces-only ()
    (setq indent-tabs-mode nil)))
#+END_SRC

* Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref keybindings
:END:

** macOS-specific

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq mac-option-modifier 'super))
#+END_SRC

** "Yes Or No" Selection

Avoid having to type out "yes" and "no" by replacing them with "y" and "n", respectively.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Evil

/Evil/ aims to implement Vi's user features, most notably Vi's modal keyboard interface, in Emacs Lisp for use in Emacs.
I prefer Vi's keybindings to Emacs's, so I enable Evil everywhere I can.
#+BEGIN_SRC emacs-lisp
(use-package evil
  ;; Load this package eagerly.
  :demand

  ;; Add the following autoloading hooks.
  :ghook
  <<evil/ghook>>

  ;; Apply the following variable customizations.
  :custom
  <<evil/custom>>

  ;; Set the following keybindings.
  :general
  <<evil/general>>

  ;; Evaluate the following code before loading this package.
  :init
  <<evil/init>>

  ;; Evaluate the following code after loading this package.
  :config
  <<evil/config>>)
#+END_SRC

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/custom
:END:

Determine whether to enable Evil in minibuffers.
#+BEGIN_SRC emacs-lisp
(evil-want-minibuffer t "Enable Evil in minibuffers.")
#+END_SRC

**** Set Keybindings (~:general~)
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/general
:END:

Do not allow =C-z= to enter Emacs mode.
Instead, make it a noop as far as Evil is concerned.
#+BEGIN_SRC emacs-lisp
(:states (list 'normal 'insert 'visual 'replace 'operator 'motion)
 "C-z" nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(:states '(motion normal visual)
 "H" #'init-evil/beginning-of-maybe-line
 "L" #'init-evil/end-of-maybe-line
 (kbd "SPC") #'evil-toggle-fold)
#+END_SRC

Bind =:= to ~eval-expression~ to evaluate one-off Emacs Lisp expressions.

#+BEGIN_SRC emacs-lisp
(:states '(motion normal replace visual)
 ":" #'eval-expression)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(:states 'normal
 "Y" #'init-evil/evil-yank-to-end-of-line)
#+END_SRC

**** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/init
:END:

Allow use of Evil Collection.
#+BEGIN_SRC emacs-lisp
(setq-default evil-want-integration t)
(setq-default evil-want-keybinding nil)
#+END_SRC

**** Post-Load Evaluation (~:config~)
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/config
:END:

Enable Evil by default in all modes.
#+BEGIN_SRC emacs-lisp
(evil-mode 1)
#+END_SRC

***** Define =evil-yank-to-end-of-line=
#+BEGIN_SRC emacs-lisp
(defun init-evil/evil-yank-to-end-of-line ()
  "Yank the characters from point to the end of the current line."
  (interactive)
  (evil-yank (point) (point-at-eol)))
#+END_SRC

***** Semantic Movement Within Lines
****** Define ~back-to-comment~
The following code is based on [[http://stackoverflow.com/a/14245964%0A][a StackOverflow answer]] by user [[https://stackoverflow.com/users/387076/gilles][Gilles]].
All code posted to StackOverflow.com is licensed under CC BY-SA 3.0, so the following derived code is also CC BY-SA 3.0-licensed.

#+BEGIN_SRC emacs-lisp
(defun init-evil/back-to-comment ()
  "Move point to the beginning of the comment in the current line.

If the current line does not contain a comment, then point will stay
in place and the function will return nil.  Otherwise the function
will return t."
  (interactive "^")
  (save-match-data
    ;; Record the position of the beginning of the line.
    (let ((old-point (point))
          (bol (progn
                 (beginning-of-line)
                 (point))))
      ;; Go to the end of the line.
      (end-of-line)
      ;; Look backward from there for a comment.
      (if (and comment-start-skip
               (comment-search-backward bol 'noerror))
          (progn
            (message "Comment found")
            ;; Go to the start of the comment's delimeter.
            (search-backward-regexp comment-start-skip bol 'noerror)
            ;; Go the start of any immediately prior whitespace.
            (skip-syntax-backward " \t" bol)
            ;; Return t.
            t)
        ;; Return point to its previous location.
        (goto-char old-point)
        ;; Return nil.
        nil))))
#+END_SRC

****** Define ~init-evil/back-totext~
#+BEGIN_SRC emacs-lisp
(defun init-evil/back-totext ()
  "Move point to the last non-whitespace character on this line."
  (interactive)
  ;; Move point to the last character on this line.
  (move-end-of-line nil)
  ;; Move backward for non-whitesapce character.
  (re-search-backward "^\\|[^[:space:]]")
  ;; Move forward one character.
  (forward-char))
#+END_SRC

****** Define ~beginning-of-maybe-line~
~beginning-of-maybe-line~ moves ~point~ toward the beginning of the current line incrementally by semantic region.
The following semantic elements are considered:
1. Comment
2. Source code
3. Indentation (leading whitespace)

The following code is based on [[https://stackoverflow.com/a/145359/8468492][a StackOverflow answer]] by user [[https://stackoverflow.com/users/8355/cjm][cjm]].
All code posted to StackOverflow.com is licensed under CC BY-SA 3.0, so the following derived code is also CC BY-SA 3.0-licensed.

#+BEGIN_SRC emacs-lisp
(defun init-evil/beginning-of-maybe-line ()
  "Move point to first non-whitespace character or beginning of the line.

Move point to the first non-whitespace character on the line.  If the
point was already at that position, move point to the beginning of the
line."
  (interactive)
  (let ((old-point (point)))            ; current position
    ;; Go to the beginning of a comment.  If there is not comment or
    ;; if point is already at or to the left of the comment...
    (when (or (not (init-evil/back-to-comment))
              (<= old-point (point)))
      ;; Go to the first non-whitespace column.
      (back-to-indentation)
      ;; If already at or to the left of the first non-whitespace character...
      (when (<= old-point (point))
        ;; Go to the beginning of the line.
        (beginning-of-line)))))
#+END_SRC

****** Define ~end-of-maybe-line~
~end-of-maybe-line~ incrementally moves ~point~ to the right within a line by semantic region.
The following semantic elements are considered in ~end-of-maybe-line~'s movement:
1. Source code
2. Comments
3. Trailing whitespace


The following is licensed CC BY-SA 3.0-licensed by StackOverflow user [[https://stackoverflow.com/users/387076/gilles][Gilles]].
It is based on [[http://stackoverflow.com/a/14245964][Gilles's StackOverflow answer]].

#+BEGIN_SRC emacs-lisp
(defun init-evil/end-of-maybe-line ()
  "Incrementally move point to the ends of syntactic blocks within the line.

The syntactic blocks are as follows, ordered from right to left:
1. Source code
2. Inline comment"
  (interactive "^")
  ;; Record point's current position.
  (let ((old-point (point)))
    ;; Go to the beginning of an inline comment (if any).
    (init-evil/back-to-comment)
    ;; If already at or after the start of the comment...
    (when (>= old-point (point))
      ;; ...then go to the beginning of trailing whitespace.
      (init-evil/back-totext))))
#+END_SRC

*** Evil Collection

/Evil Collection/ offers a collection of Evil keybindings for modes that Evil does not support by default.

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  ;; Load this package eagerly.
  :demand

  ;; Load this package afer the following packages.
  :after evil

  ;; Apply the following variable customizations.
  :custom
  <<evil-collection/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<evil-collection/config>>)
#+END_SRC

**** Apply Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-collection/custom
:END:

Set up autocompletion to be similar to Vim's YouCompleteMe.
#+BEGIN_SRC emacs-lisp
(evil-collection-company-use-tng t)
#+END_SRC

Enable =TAB=-based bindings in Outline mode.
#+BEGIN_SRC emacs-lisp
(evil-collection-outline-bind-tab t)
#+END_SRC

Synchronize insert and normal states with char and line modes, respectively, in Term mode.
#+BEGIN_SRC emacs-lisp
(evil-collection-term-sync-state-and-mode-p t)
#+END_SRC

Set up Vim-style keybindings in the minibuffer.
#+BEGIN_SRC emacs-lisp
(evil-collection-setup-minibuffer t)
#+END_SRC

Set up debugger keys.
#+BEGIN_SRC emacs-lisp
(evil-collection-setup-debugger-keys t)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-collection/config
:END:

Enable Evil Collection globally.
#+BEGIN_SRC emacs-lisp
(evil-collection-init)
#+END_SRC

*** Evil Matchit

[[https://github.com/redguardtoo/evil-matchit][Evil Matchit]] is a port of Tim Pope's [[http://www.vim.org/scripts/script.php?script_id%3D39][matchit.vim]] to Evil.
It enables jumping between matched tags, e.g. =<div>= and =</div>=.
#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  (:keymaps 'evil-matchit-mode-map
   :states 'motion
   "%" #'evilmi-jump-items)

  :config
  (global-evil-matchit-mode 1))
#+END_SRC

*** Evil Surround

[[https://github.com/emacs-evil/evil-surround][Evil Surround]] is a port of [[https://github.com/tpope/vim-surround][vim-surround]] to Evil.
It adds a "surround" verb to Evil's modal editing.
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  ;; Load eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  (global-evil-surround-mode 1))
#+END_SRC

*** Evil Indent Plus
=[[https://github.com/TheBB/evil-indent-plus]]= adds indentation levels as a text object for Evil.

- =i= is same or higher indentation.
- =I= is same or higher indentation, including the first line above with less indentation.
- =J= is same or higher indentation, including the first line above and below with less indentation.


#+BEGIN_SRC emacs-lisp
(use-package evil-indent-plus
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  (evil-indent-plus-default-bindings))
#+END_SRC
** Smartparens

[[https://github.com/Fuco1/smartparens][Matus Goljer (Fuco1)'s package]] provides a minor mode "that deals with parens pairs and tries to be smart about it".

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  ;; Load this package eagerly.
  :demand

  :preface
  <<smartparens/preface>>

  :custom
  <<smartparens/custom>>

  :config
  <<smartparens/config>>)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref smartparens/custom
:END:

Enable ~smartparens-mode~ globally.

#+BEGIN_SRC emacs-lisp
(smartparens-global-mode t)
#+END_SRC

*** Post-Load Evluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref smartparens/config
:END:

Allow ~smartparens-mode~ to be enabled in ~minibuffer-inactive-mode~.

#+BEGIN_SRC emacs-lisp
(setq sp-ignore-modes-list (delete 'minibuffer-inactive-mode sp-ignore-modes-list))
#+END_SRC

** Smartparens Config

Smartparens Config configures Smartparens for various programming languages.

#+BEGIN_SRC emacs-lisp
(use-package smartparens-config
  :straight smartparens

  ;; Load this package after the following packages.
  :after smartparens

  ;; Load this package eagerly.
  :demand)
#+END_SRC

** /Smart Dash/

/Smart Dash/ a minor mode which redefines the dash key ("-") to insert an underscore within C-style identifiers and a dash otherwise.
#+begin_src emacs-lisp
(use-package smart-dash
  :demand)
#+end_src

* Minibuffer
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref minibuffer
:END:

The minibuffer is a persistent buffer in Emacs that is used for interactive input and messages.

** Recursive Minibuffers

Allowing one to have more than one minibuffer active allows for more sophisticated workflows.
#+BEGIN_SRC emacs-lisp
(setq enable-recursive-minibuffers t)
#+END_SRC

Once having multiple active minibuffers is possible, it is helpful to keep track of the depth of recursion.
#+BEGIN_SRC emacs-lisp
(minibuffer-depth-indicate-mode +1)
#+END_SRC

** Flx

/Flx/ provides fuzzy searching algorithms.
Ivy's fuzzy finding will use Flx's scoring mechanism if /Flx/ is loaded.

#+BEGIN_SRC emacs-lisp
(use-package flx
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code before loading this package.
  :init
  <<flx/config>>)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref flx/config
:DESCRIPTION: Code to evaluated after ~flx~ has been loaded.
:END:

Run Emacs's garbage collector only when at least 20 MB have been allocated.
Doing so greatly improves ~flx~'s performance when working with large sets.

#+BEGIN_SRC emacs-lisp
(when (> 20000000 gc-cons-threshold)
  (setq gc-cons-threshold 20000000))
#+END_SRC

** Ivy

From the project's readme:
#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs.
While it operates similarly to other completion schemes such as =icomplete-mode=, Ivy aims to be more efficient, smaller, simpler, and smoother to use yet highly customizable.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package ivy
  ;; Load this package after the following packages.
  :after (flx)

  ;; Load this package eagerly.
  :demand

  ;; Inform the byte-compiler of the following interactive functions.
  :commands
  (ivy-mode)

  ;; Inform the byte-code compiler of the following non-interactive functions.
  :functions
  (ivy-format-function-line)

  ;; Add the following keybindings.
  :general
  <<ivy/general>>

  ;; Apply the following customizations.
  :custom
  <<ivy/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<ivy/config>>)
#+END_SRC

*** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy/general
:END:

Shadow ~switch-to-buffer~ with ~ivy-switch-buffer~.
#+BEGIN_SRC emacs-lisp
("C-x C-b" #'ivy-switch-buffer)
#+END_SRC

When in an Ivy buffer:
- =M-<return>= sends the current input verbatim.
- =C-u= restarts the minibuffer with a prefix argument.


#+BEGIN_SRC emacs-lisp
(:keymaps 'ivy-minibuffer-map
 "M-<return>" #'ivy-immediate-done
 "C-u" #'init-minibuffer/restart-with-prefix)
#+END_SRC

When in the minibuffer:
- =C-u= restarts the minibuffer with a prefix argument.


#+BEGIN_SRC emacs-lisp
(:keymaps 'minibuffer-inactive-mode-map
 "C-u" #'init-minibuffer/restart-with-prefix)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy/custom
:END:

Determine how matched parts of the options are highlighted.
#+BEGIN_SRC emacs-lisp
(ivy-display-style
 'fancy
 "Highlight the matching parts of the regexp in the minibuffer.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-use-virtual-buffers
 t
 "Show recently killed buffers when calling `ivy-switch-buffer'.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-re-builders-alist
 '((t . ivy--regex-plus))
 "Use `ivy--regex-plus' as the default matching function.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-extra-directories
 nil
 "Do not show './' or '../' in the filename completion list.")
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to evaluate after ~ivy~ has been loaded.
:HEADER-ARGS+: :noweb-ref ivy/config
:END:

Enable ~ivy-mode~ globally.
#+BEGIN_SRC emacs-lisp
(ivy-mode +1)
#+END_SRC

Do not include TRAMP buffers in Ivy's buffer lists.
#+BEGIN_SRC emacs-lisp
(setq ivy-ignore-buffers
      (cons (rx line-start "*tramp/"
                (one-or-more (not whitespace))
                whitespace
                (one-or-more anything)
                "*" line-end)
            ivy-ignore-buffers))
#+END_SRC

**** Restart the Minibuffer with a Prefix Argument
:PROPERTIES:
:AUTHOR:   Clemens Radermacher (clemera) <clemera@posteo.net>
:COPYRIGHT: Copyright (C) 2019 Clemens Radermacher
:END:

Out of the box, Emacs does not provide a graceful way to add a prefix argument after the user has already started entering a command.
The following code posted by u/clemera on Reddit provides a workaround by restarting the minibuffer with same text.

First, a variable is defined to hold the minibuffer contents that were typed before entering a prefix.
#+BEGIN_SRC emacs-lisp
(defvar init-minibuffer/original-command nil
  "Command the minibuffer was started with.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun init-minibuffer/restart-with-prefix ()
  "Restart the minibuffer with a prefix argument."
  (interactive)
  (let ((input (ivy--input)))
    (cond ((memq #'ivy--queue-exhibit post-command-hook)
           (ivy-quit-and-run
             (let ((current-prefix-arg '(4))
                   (ivy-initial-inputs-alist `((,(ivy-state-caller ivy-last) . ,input))))
               (call-interactively (ivy-state-caller ivy-last))))
           (t
            (ivy-quit-and-run
              (let ((current-prefix-arg '(4)))
                (minibuffer-with-setup-hook
                    (lambda ()
                      (insert input)
                      (minibuffer-message "C-u"))
                  (call-interactively init-minibuffer/current-command)))))))))
#+END_SRC

** Counsel
#+BEGIN_SRC emacs-lisp
(use-package counsel

  ;; Load this package after the following packages.
  :after (ivy)

  ;; Load this package eagerly.
  :demand

  ;; Perform the following keybindings.
  :general
  ("C-h k" #'counsel-descbinds)
  ("C-x C-4 C-b" #'switch-to-buffer-other-window)
  ("C-x C-4 C-f" #'find-file-other-window)
  ("C-x C-4 b" #'switch-to-buffer-other-window)
  ("C-x C-f" #'counsel-find-file)
  ("C-x f" #'counsel-find-file)
  ("M-x" #'counsel-M-x)
  (:keymaps '(minibuffer-local-map minibuffer-inactive-mode-map)
   :states '(insert movement)
   "C-r" #'counsel-minibuffer-history)
  (:keymaps '(comint-mode-map shell-mode-map)
   "C-r" #'counsel-shell-history))
#+END_SRC

** Swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper
  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after ivy

  ;; Perform the following keybindings.
  :general
  ("C-s" #'swiper-isearch)
  (:keymaps '(normal movement visual)
   "/" #'swiper-isearch))
#+END_SRC

** Ivy Rich
#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  ;; Load this package after the following packages.
  :after ivy

  ;; Load this package eagerly.
  :demand

  ;; Apply the following customizations.
  :custom
  <<ivy-rich/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<ivy-rich/config>>)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy-rich/custom
:END:

#+BEGIN_SRC emacs-lisp
(ivy-virtual-abbreviate
 'abbreviate
 "Abbreviate virtual buffer names.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-rich-path-style
 'relative
 "Show paths relative their the project home.")
#+END_SRC

Reduce the amount of information displayed for remote buffers (i.e. buffers whose contents were accessed via TRAMP).
This improves performance of operations that involve Ivy Rich.
#+BEGIN_SRC emacs-lisp
(ivy-rich-parse-remote-buffer nil)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to evaluate after loading ~ivy-rich~.
:HEADER-ARGS+: :noweb-ref ivy-rich/config
:END:

Enable ~ivy-rich-mode~ globally.
#+BEGIN_SRC emacs-lisp
(ivy-rich-mode 1)
#+END_SRC

Add support for ~counsel-projectile-switch-to-buffer~, mirroring that of ~ivy-switch-buffer~.
#+BEGIN_SRC emacs-lisp
(setq ivy-rich--display-transformers-list
      (plist-put
       ivy-rich--display-transformers-list
       'counsel-projectile-switch-to-buffer
       (plist-get ivy-rich--display-transformers-list 'ivy-switch-buffer)))
#+END_SRC

** Minibuffer Line
:PROPERTIES:
:DESCRIPTION: Display status info in the minibuffer
:END:

From /Minibuffer Line/'s readme:
#+BEGIN_QUOTE
This package lets you display various status information in the minibuffer window instead of the mode-line.
Of course, this is only displayed when the minibuffer window is not already used for other things (e.g. a minibuffer or an each area message).
The contents and aspect is controlled by the src_emacs-lisp{minibuffer-line-format} variable and the src_emacs-lisp{minibuffer-line} face.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package minibuffer-line
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code before loading this package.
  :init
  <<minibuffer-line/init>>

  ;; Inform the bytecode compiler of the following non-autoloading functions.
  :functions
  (format-time-string-8601 minibuffer-line-align)

  ;; Inform the bytecode compiler of the following autoloading functions.
  :commands
  minibuffer-line-mode

  ;; Apply the following variable customizations.
  :custom
  <<minibuffer-line/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  (minibuffer-line-mode))
#+END_SRC

*** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref minibuffer-line/init
:DESCRIPTION: Code to evaluate before loading src_emacs-lisp{minibuffer-line}
:END:

Define a function to print the date and time in ISO 8601 format.
#+BEGIN_SRC emacs-lisp
(defun format-time-string-minibuffer-line ()
  "Print the current date and time in ISO 8601-like format."
  (format-time-string "%Y-%m-%d %T"))
#+END_SRC

Define a function to left- and right-align elements using mode-line formatting.
#+BEGIN_SRC emacs-lisp
(defun minibuffer-line-align (left right)
  "Return a string containing LEFT and RIGHT aligned across the frame."
  (let* ((width-total (frame-text-cols))
         (width-space (- width-total
                         (+ (string-width (format-mode-line left))
                            (string-width (format-mode-line right))))))
    (append left
            (list (propertize
                   (format (format "%%%ds" width-space) "")
                   'face 'default))
            right)))
#+END_SRC

Define a the format to use for displaying battery information in the minibuffer.
#+BEGIN_SRC emacs-lisp
(defvar minibuffer-line-battery-format
  "battery %L %p%%"
  "Control string formatting the battery status to display in the minibuffer.")
#+END_SRC

*** Variable Customization
:PROPERTIES:
:DESCRIPTION: Variable customizations to apply when loading src_emacs-lisp{minibuffer-line}
:HEADER-ARGS+: :noweb-ref minibuffer-line/custom
:END:

Determine how frequently the string in src_emacs-lisp{minibuffer-line-format} is recalculated.
#+BEGIN_SRC emacs-lisp
(minibuffer-line-refresh-interval
 1
 "Refresh the minibuffer-line every second.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(minibuffer-line-format
 '((:eval
    (minibuffer-line-align
     '()
     '((:eval (propertize
               (battery-format
                minibuffer-line-battery-format
                (funcall battery-status-function))
               'face 'default))
       (:eval (propertize " | " 'face 'default))
       (:eval (propertize system-name 'face 'default))
       (:eval (propertize " | " 'face 'default))
       (:eval (propertize (format-time-string-minibuffer-line) 'face 'default)))))))
#+END_SRC

** McFly
:PROPERTIES:
:COPYRIGHT_YEAR: 2019
:COPYRIGHT_AUTHOR: Vincent Zhang (seagle0128)
:COPYRIGHT_EMAIL: seagle0128@gmail.com
:LICENSE:  GPLv3+
:END:

#+BEGIN_SRC emacs-lisp
(defvar my-ivy-fly-commands '(query-replace-regexp
                              flush-lines
                              keep-lines
                              ivy-read
                              swiper
                              swiper-backward
                              swiper-all
                              swiper-isearch
                              swiper-isearch-backward
                              counsel-grep-or-swiper
                              counsel-grep-or-swiper-backward
                              counsel-grep
                              counsel-ack
                              counsel-ag
                              counsel-rg
                              counsel-pt))

(defun my-ivy-fly-back-to-present ()
  ;; (remove-hook 'pre-command-hook 'my-ivy-fly-back-to-present t)
  (cond ((and (memq last-command my-ivy-fly-commands)
              (equal (this-command-keys-vector) (kbd "M-p")))
         ;; repeat one time to get straight to the first history item
         (setq unread-command-events
               (append unread-command-events
                       (listify-key-sequence (kbd "M-p")))))
        ((or (memq this-command '(self-insert-command
                                  yank
                                  ivy-yank-word
                                  counsel-yank-pop))
             (equal (this-command-keys-vector) (kbd "M-n")))
         (delete-region (point)
                        (point-max)))))

(defun my-ivy-fly-time-travel ()
  (when (memq this-command my-ivy-fly-commands)
    (let* ((kbd (kbd "M-n"))
           (cmd (key-binding kbd))
           (future (and cmd
                        (with-temp-buffer
                          (when (ignore-errors
                                  (call-interactively cmd) t)
                            (buffer-string))))))
      (when future
        (save-excursion
          (insert (propertize (replace-regexp-in-string
                               "\\\\_<" ""
                               (replace-regexp-in-string
                                "\\\\_>" ""
                                future))
                              'face 'shadow)))
        (add-hook 'pre-command-hook 'my-ivy-fly-back-to-present nil t)))))

(add-hook 'minibuffer-setup-hook #'my-ivy-fly-time-travel)
#+END_SRC

* TRAMP
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref tramp
:END:

TRAMP allows Emacs to transparently access remote files as if they were local files.

** TRAMP

#+BEGIN_SRC emacs-lisp
(use-package tramp
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Apply the following variable customizations.
  :custom
  <<tramp/custom>>)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref tramp/custom
:END:

Determine where Emacs creates backups for files edited via TRAMP.
#+BEGIN_SRC emacs-lisp
(tramp-backup-directory-alist backup-directory-alist "Create TRAMP backups locally.")
#+END_SRC

** Counsel Tramp

#+BEGIN_SRC emacs-lisp
(use-package counsel-tramp
  :general
  ("C-x t" #'counsel-tramp))
#+END_SRC

** Docker Tramp

/Docker Tramp/ provides a TRAMP method for accessing Docker containers.

#+BEGIN_SRC emacs-lisp
(use-package docker-tramp
  ;; Only load Docker Tramp if the following code evaluates to non-nil.
  :if
  <<docker/if>>

  ;; Load Docker Tramp package after the following packages.
  :after tramp

  ;; Load Docker Tramp eagerly.
  :demand)
#+END_SRC

* Version Control
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref version-control
:END:

** Backup Files

Emacs has built-in functionality to create backup files.
By default, such files are created in the same directory as the actual file and simply have a tilde appended to the filename.
This is functional, but results in messy directories.

#+BEGIN_SRC emacs-lisp
(use-package files
  :straight (:type built-in)

  :custom
  <<files/custom>>)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref files/custom
:END:

\src_emacs-lisp{backup-directory-alist} determines where backup files are created.
By using mapping a wildcard filename to a single directory, all backup files will be created in that directory.
#+BEGIN_SRC emacs-lisp
(backup-directory-alist
 `((".*" . ,temporary-file-directory)))
#+END_SRC

** Autorevert

#+BEGIN_SRC emacs-lisp
(use-package autorevert
  :straight (:type built-in)

  ;; Add the following auto-loading hooks.
  :ghook
  ('pdf-tools-mode-hook #'auto-revert-mode)

  ;; Customize the following variables.
  :custom
  (auto-revert-verbose nil "Do not display messages when buffers are reverted."))
#+END_SRC

** /VC/

/VC/ is a built-in package that provides an interface for generic version control operations, abstracting over many different version control systems.
The only action performed below is changing the binding of \src_emacs-lisp{vc-revert}.
The new binding is harder to accidentally press and opens up a convenient binding for /Brose at Remote/'s command.

#+BEGIN_SRC emacs-lisp
(use-package vc
  :straight (:type built-in)

  ;; Load VC eagerly.
  :demand

  ;; Bind the following keys.
  :general
  (:keymaps 'vc-prefix-map
   "U" #'vc-revert
   "u" nil))
#+END_SRC

** Diff HL

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  ;; Only load this package if the following condition is met.
  :if
  <<diff-hl/if>>

  ;; Load this package eagerly.
  :demand

  ;; Add the following auto-loading hooks.
  :ghook
  <<diff-hl/ghook>>

  ;; Inform the bytecode compiler about the following functions.
  :commands
  (global-diff-hl-mode)

  ;; Evaluate the following code before loading this package.
  :init
  <<diff-hl/init>>

  ;; Evaluate the following code after loading this package.
  :config
  <<diff-hl/config>>)
#+END_SRC

*** Conditional Loading
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/if
:END:

Diff HL depends on features added in Emacs 24.3.
#+BEGIN_SRC emacs-lisp
(version<= "24.3" emacs-version)
#+END_SRC

*** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/ghook
:END:

Enable Diff HL in Dired buffers.
#+BEGIN_SRC emacs-lisp
('dired-mode-hook #'diff-hl-dired-mode)
#+END_SRC

Update Diff HL's status when refreshing with modern versions of Magit.
#+BEGIN_SRC emacs-lisp
('magit-post-refresh-hook #'diff-hl-magit-post-refresh)
#+END_SRC

*** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/init
:END:

Enable Diff HL's base minor mode globally.
#+BEGIN_SRC emacs-lisp
(global-diff-hl-mode)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/config
:END:

Perform Diff HL highlighting on-the-fly.
#+BEGIN_SRC emacs-lisp
(diff-hl-flydiff-mode)
#+END_SRC

** Git
*** Git Attributes Mode

#+BEGIN_SRC
(use-package gitattributes-mode)
#+END_SRC

*** Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  ;; Load this package if the following code evaluates to non-nil.
  :if
  <<magit/if>>

  ;; Load this package eagerly.
  :demand

  ;; Inform the bytecode compiler of the following autoloaded functions.
  :commands magit-clone-to-xdg-source

  ;; Perform the following customizations.
  :custom
  <<magit/custom>>

  ;; Evaluate the following code after loading `magit'.
  :config
  <<magit/config>>)
#+END_SRC

**** Conditional Loading
:PROPERTIES:
:DESCRIPTION: Only load ~magit~ if this code evaluates to non-~nil~.
:HEADER-ARGS+: :noweb-ref magit/if
:END:

/Magit/ provides an interface for Git.
As such, the package is unusable is worthless if =git= is not in the user's ~PATH~.
#+BEGIN_SRC emacs-lisp
(executable-find "git")
#+END_SRC

**** Customize Variables
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref magit/custom
:END:

Set the list of messages Magit should not display.
#+BEGIN_SRC emacs-lisp
(magit-no-message '("Turning on magit-auto-revert-mode...") "Suppress messages")
#+END_SRC

Hide the stash and ignored file sections by default in status buffers.
#+BEGIN_SRC emacs-lisp
(magit-section-initial-visibility-alist
 '((ignored . hide)
   (stashes . hide)
   (untracked . hide)))
#+END_SRC

Set the sections to be displayed in status buffers.
#+BEGIN_SRC emacs-lisp
(magit-status-sections-hook
 '(magit-insert-status-headers
   magit-insert-merge-log
   magit-insert-rebase-sequence
   magit-insert-am-sequence
   magit-insert-sequencer-sequence
   magit-insert-bisect-output
   magit-insert-bisect-rest
   magit-insert-bisect-log
   magit-insert-ignored-files
   magit-insert-untracked-files
   magit-insert-unstaged-changes
   magit-insert-staged-changes
   magit-insert-stashes
   magit-insert-unpushed-to-pushremote
   magit-insert-unpushed-to-upstream-or-recent
   magit-insert-unpulled-from-pushremote
   magit-insert-unpulled-from-upstream))
#+END_SRC

**** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref magit/init
:DESCRIPTION: Code to evaluate before loading Magit.
:END:

Store the usernames used by the current user.
#+BEGIN_SRC emacs-lisp
(defconst magit-push-usernames '("lafrenierejm")
  "The Git forge usernames whose repos this Emacs user has push access to.")
#+END_SRC

Store the domains where this user has global Git push access.
#+BEGIN_SRC emacs-lisp
(defconst magit-push-domains '()
  "The domains where this Emacs user has global Git push access.")
#+END_SRC

**** Post-Load Execution
:PROPERTIES:
:DESCRIPTION: The code in this section shall be evaluated after ~magit~ has been loaded.
:HEADER-ARGS+: :noweb-ref magit/config
:END:

***** Return After Commit Message

Return to the main Magit window after closing a commit message, regardless of whether that message is committed or aborted.
#+BEGIN_SRC emacs-lisp
(advice-add 'git-commit-commit :after #'delete-window)
(advice-add 'git-commit-abort :after #'delete-window)
#+END_SRC

***** Automatically Register Repositories with Projectile

Define a function to perform the registration.
#+BEGIN_SRC emacs-lisp
(defun init-version-control/magit-add-known-project (&rest _)
  "Register the current repository's root with Projectile."
  (interactive)
  (when (and (fboundp #'projectile-add-known-project)
             magit--default-directory)
    (projectile-add-known-project magit--default-directory)))
#+END_SRC

Add the above function to be run after ~magit-status~.
#+BEGIN_SRC emacs-lisp
(advice-add
 'magit-status-internal
 :after
 #'init-version-control/magit-add-known-project)
#+END_SRC

***** Comparable Version Number

The function ~magit-version~ provided by Magit does not return a version string that is comparable using Emacs's built-in ~version<~.
However, Magit's semver is /par/ of the string returned by ~magit-version~;
it is everything before the first hyphen.

#+BEGIN_SRC emacs-lisp
(defun init-magit/version ()
  "Return Magit's version for use in comparisons."
  (car (split-string (magit-version) "-")))
#+END_SRC

***** Current Branch Name

Magit has built-in functions \src_emacs-lisp{magit-copy-section-value} and \src_emacs-lisp{magit-copy-buffer-revision} for placing values on the kill ring.
I often want to refer to the name of the current branch, so I define a counterpart to the above commands that accomplishes this.
#+BEGIN_SRC emacs-lisp
(defun magit-lafrenierejm-copy-branch-name ()
  "Save the name of the current branch for later use.

Save the section value to the `kill-ring'."

  (interactive)
  (let ((branch-name (magit-get-current-branch)))
    (message "%s" branch-name)
    (kill-new (magit-get-current-branch))))
#+END_SRC

Alias the above command to remove my username "namespace".
#+BEGIN_SRC emacs-lisp
(defalias 'magit-copy-branch-name #'magit-lafrenierejm-copy-branch-name)
#+END_SRC

*** Forge
From the project's README:
#+BEGIN_QUOTE
Work with Git forges, such as Github and Gitlab, from the comfort of Magit and the rest of Emacs.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package forge
  ;; Load this package after the following packages.
  :after magit

  ;; Load this package eagerly.
  :demand)
#+END_SRC

*** Evil Magit
~[[https://github.com/emacs-evil/evil-magit][evil-magit]]~ configures [[Evil]] and [[Magit]] to play well together.

#+BEGIN_SRC emacs-lisp
(use-package evil-magit
  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after (:all evil magit)

  :general
  (:keymaps 'magit-mode-map
   :states 'motion
   "C-d" nil
   "C-z" nil
   [escape] nil)

  :ghook
  <<evil-magit/ghook>>

  :custom
  <<evil-magit/custom>>

  :config
  <<evil-magit/config>>)
#+END_SRC

**** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-magit/ghook
:END:

#+BEGIN_SRC emacs-lisp
('magit-mode-hook #'evil-local-mode)
#+END_SRC

**** Customize Variables
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-magit/custom
:END:

Determine which Evil state Evil Magit starts in.
#+BEGIN_SRC emacs-lisp
(evil-magit-state 'motion "Start `evil-magit' in the motion state.")
#+END_SRC

Determine whether Evil Magit uses Evil's movement keys.
#+BEGIN_SRC emacs-lisp
(evil-magit-want-horizontal-movement t "Enable Evil's horizontal movement in Magit buffers.")
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-magit/config
:END:

Add new sequences for copying Git information.
#+BEGIN_SRC emacs-lisp
(evil-define-key* evil-magit-state magit-mode-map "yb" #'magit-copy-branch-name)
(evil-define-key* evil-magit-state magit-mode-map "yc" #'magit-copy-buffer-revision)
#+END_SRC

*** SSH Agency

#+BEGIN_SRC emacs-lisp
(use-package ssh-agency
  :after magit

  :demand

  :custom
  (ssh-agency-add-executable (executable-find "ssh-add"))
  (ssh-agency-agent-executable (executable-find "ssh-agent"))
  (ssh-agency-agent-exe-names '("ssh-agent")))
#+END_SRC

*** Determine Year Added

Define a function to determine when a file was first created.
This is useful when adding determining information.
#+BEGIN_SRC emacs-lisp
(defun git-lafrenierejm-year-added (filename)
  (interactive "f")
  "Determine the year when FILENAME was added to a Git repository.

If the file has not been added to the repository, use the current year."
  (if-let (((not (string-empty-p filename)))
           (git-output
            (shell-command-to-string
             (format "%s | tail -1 | head -c 4 -z"
                     (s-join " " `("git" "log"
                                   "--diff-filter=A"
                                   "--follow"
                                   "--format=%aI"
                                   "--"
                                   ,filename
                                   ,(format "2>%s" null-device))))))
           ((not (string-empty-p git-output))))
      git-output
    (format-time-string "%Y")))
#+END_SRC

Alias the above function to remove my username.
#+BEGIN_SRC
(defalias 'git-year-added #'git-lafrenierejm-year-added)
#+END_SRC

*** /Browse at Remote/

The command provided by /Browse at Remote /to copy the URL is added to /VC/'s leaf keymap.
This has the effect of making that command easily accessible alongside other /VC/ commands.

#+BEGIN_SRC emacs-lisp
(use-package browse-at-remote
  :general
  (:keymaps 'vc-prefix-map
   "u"  #'browse-at-remote-kill))
#+END_SRC

** Mercurial (Hg)

*** /Monky/

#+begin_src emacs-lisp
(use-package monky
  :demand)
#+end_src

* Completion
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref completion
:END:

** Company

#+BEGIN_SRC emacs-lisp
(use-package company
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading.
  :config
  <<company/config>>)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to be evaluated after Company has been loaded.
:HEADER-ARGS+: :noweb-ref company/config
:END:

Enable ~company-mode~ globally.
#+BEGIN_SRC emacs-lisp
(global-company-mode)
#+END_SRC

*** /Company Posframe/

Use child frames for /Company/'s candidate menus.
#+begin_src emacs-lisp
(use-package company-posframe
  :demand
  :after company
  :config
  (company-posframe-mode +1)
  (with-eval-after-load 'desktop
    (push '(company-posframe-mode . nil)
          desktop-minor-mode-table)))
#+end_src

** YASnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<yasnippet/config>>)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref yasnippet/config
:END:

Enable \src_emacs-lisp{yas-global-mode}.
#+BEGIN_SRC emacs-lisp
(yas-global-mode 1)
#+END_SRC

**** Guix Package /emacs-yasnippet-snippets/

Add the snippets from the Guix package /emacs-yasnippet-snippets/.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'guix-profiles
  (when-let* (guix-user-profile
              (emacs-yasnippet-snippets-dir (expand-file-name
                                             "share/emacs/yasnippet-snippets"
                                             guix-user-profile))
              ((file-accessible-directory-p emacs-yasnippet-snippets-dir)))
    (add-to-list 'yas-snippet-dirs emacs-yasnippet-snippets-dir)))
#+END_SRC

** Ivy YASnippet

#+BEGIN_SRC emacs-lisp
(use-package ivy-yasnippet
  ;; Load this package after the following packages.
  :after (ivy yasnippet)

  ;; Load this package eagerly.
  :demand)
#+END_SRC

* Containers
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref containers
:END:

** Docker

#+BEGIN_SRC emacs-lisp
(use-package docker
  ;; Only load Docker if the following code evaluates to non-nil.
  :if
  <<docker/if>>

  ;; Add the following auto-loading keybindings.
  :general
  ("C-c d" #'docker))
#+END_SRC

*** Conditional Loading
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref docker/if
:END:

/Docker/'s features are only usable if the =docker= command is present in =$PATH=.
#+BEGIN_SRC emacs-lisp
(executable-find "docker")
#+END_SRC

* Diff
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff
:END:

** Ediff

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :straight (:type built-in)

  ;; Evaluate the following code after loading this package.
  :custom
  <<ediff/custom>>)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ediff/custom
:END:

Determine how Ediff windows are setup.
#+BEGIN_SRC emacs-lisp
(ediff-window-setup-function
 #'ediff-setup-windows-plain
 "Use a single frame for all buffers including the control panel.")
#+END_SRC

** Whitespace

*** WS Butler

From the package's description:
#+BEGIN_QUOTE
- Only lines touched get trimmed.
  If the white space at end of buffer is changed, then blank lines at the end of buffer are truncated respecting require-final-newline.
- Trimming only happens when saving.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<ws-butler/config>>)
#+END_SRC

**** Post-Load Evluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ws-butler/config
:DESCRIPTION: Code to be evaluated after loading ~ws-butler~.
:END:

Enable ws-butler globally.

#+BEGIN_SRC emacs-lisp
(ws-butler-global-mode)
#+END_SRC

* Directories
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref directories
:END:

Emacs is a robust tool for operating on directory objects.
The built-in package provided for doing so is /Dired/.
Most other directory-centric packages provide functionality on top of /Dired/.

** Dired

#+BEGIN_SRC emacs-lisp
(use-package dired
  :straight (:type built-in)

  ;; Load Dired eagerly.
  :demand

  ;; Inform the bytecode compiler of the following interactive functions.
  :commands dired-here

  ;; Add the following auto-loading keybindings.
  :general
  (:states '(motion normal visual)
   "C-d" #'dired-here)
  (:keymaps 'dired-mode-map
   "G" #'evil-goto-line)
  (:keymaps 'dired-mode-map
   :states '(motion normal visual)
   "g g" #'evil-goto-first-line)

  ;; Perform the following variable customizations.
  :custom
  (dired-listing-switches
   (string-join
    '("-l" ; use a long listing format
      "-A" ; do not list implied . and ..
      "-h" ; with -l and -s, print sizes like 1K 234M 2G etc.
      "-v" ; natural sort of (version) numbers within text
      )
    " "))
  (dired-dwim-target t)

  ;; Evaluate the following code after loading Dired.
  :config
  <<dired/config>>)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref dired/config
:END:

Define a function to create an empty file.
This behaves as a subset of =touch=;
it will not update the modified time of existing files.
#+BEGIN_SRC emacs-lisp
(defun dired-lafrenierejm-touch (filename)
  "Create a new, empty file."
  (interactive "FFile to create: ")
  (let (filename-expanded (expand-file-name filename))
    (if (file-exists-p filename-expanded)
        (error "File '%s' already exists" filename-expanded)
      (with-temp-buffer (write-file filename-expanded)))))
#+END_SRC

Define a function to open the current directory in a Dired buffer.
#+BEGIN_SRC emacs-lisp
(defun dired-here ()
  "\"Edit\" the current directory."
  (interactive)
  (dired default-directory))
#+END_SRC

** Writable Dired

#+BEGIN_SRC emacs-lisp
(use-package wdired
  :straight (:type built-in)

  :custom
  (wdired-allow-to-change-permissions t))
#+END_SRC

** Dired Collapse

/Dired Collapse/ provides a minor mode \src_emacs-lisp{dired-collapse-mode} that provides visibility into directories with a single child.
This visibility is provided recursively, so the view provided will extend arbitrarily deep provided each directory in the view has exactly one child.

#+BEGIN_SRC emacs-lisp
(use-package dired-collapse
  ;; Load Dired Collapse after the following packages.
  :after dired

  ;; Add the following auto-loading hooks.
  :ghook
  ('dired-mode-hook #'dired-collapse-mode))
#+END_SRC

** Dired Narrow

#+BEGIN_SRC emacs-lisp
(use-package dired-narrow
  ;; Inform the bytecode compiler of the following interactive functions.
  :commands dired-narrow

  ;; Add the following auto-loading keybindings.
  :general
  (:keymaps 'dired-mode-map
   "C-x n n" #'dired-narrow))
#+END_SRC

* Command Interpretation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref command-interpretation
:END:

** Comint

#+BEGIN_SRC emacs-lisp
(use-package comint
  :straight (:type built-in)

  :demand

  :commands
  (init-comint/clear-buffer)

  :general
  <<comint/general>>

  :config
  <<comint/config>>)
#+END_SRC

*** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref comint/general
:END:

Use =C-l= to clear the current buffer.
#+BEGIN_SRC emacs-lisp
(:keymaps 'comint-mode-map
 "C-l" #'init-comint/clear-buffer)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref comint/config
:END:

**** Clear Buffers

The following code is taken verbatim from [[https://emacsredux.com/blog/2015/01/18/clear-comint-buffers/]["Clear Comint Buffers"]] on /Emacs Redux/.
The only addition is the doc string.
#+BEGIN_SRC emacs-lisp
(defun init-comint/clear-buffer ()
  "Clear all scrollback for the current buffer."
  (interactive)
  (let ((comint-buffer-maximum-size 0))
    (comint-truncate-buffer)))
#+END_SRC

** Emacs Shell
*** Esh Mode
#+BEGIN_SRC emacs-lisp
(use-package esh-mode
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  :preface
  <<esh-mode/preface>>

  :config
  <<esh-mode/config>>)
#+END_SRC

**** Pre-Evaluation Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref esh-mode/preface
:END:

Define the format of the timestamp to prefix prompts with.
By default, this follows ISO 8601.
#+NAME: esh-mode-prompt-timestamp-format-string
#+BEGIN_SRC emacs-lisp
(defcustom esh-mode-prompt-timestamp-format-string
  "%FT%T%z"
  "The format-string used for Eshell prompts' timestamps.

See `help format-time-string' for the definition of the constructs.
The default value follows ISO 8601."
  :type '(string))
#+END_SRC

Define the regexp to match the result of the above format string.
#+NAME: esh-mode-prompt-timestamp-regexp
#+BEGIN_SRC emacs-lisp
(defcustom esh-mode-prompt-timestamp-regexp
  (rx
   (repeat 4 digit) ?- (repeat 2 digit) ?- (repeat 2 digit)
   ?T (repeat 2 digit) (repeat 2 (and ?: (repeat 2 digit)))
   (or ?- ?+) (repeat 4 digit))
  "A regular expression that matches `esh-mode-prompt-timestamp-format-string'."
  :type '(regexp))
#+END_SRC

**** Post-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref esh-mode/config
:END:

***** Define Eshell-Specific ~beginning-of-maybe-line~
[[../minor-mode/init-evil.org][init-evil.org]] defines ~init/beginning-of-maybe-line~.
That function acts as a do-what-I-mean alternative to the built-in =beginning-of-line= by incrementally jumping to the beginning of text sections within a line.

=esh-mode-beginning-of-line-maybe= moves =point= toward the beginning of the current line incrementally by semantic region.
1. If point is in the text of a command, point will be moved to the beginning of the command.
2. If the current line has leading whitespace and point is somewhere after that whitespace, point will be moved to the first non-whitespace character.
3. Point will be moved to the beginning of the line.

#+BEGIN_SRC emacs-lisp
(defun esh-mode-beginning-of-line-maybe ()
  "Move point to the start of the command beginning of the line."
  (interactive)
  (let ((old-point (point)))   ; Get current position.
    (eshell-bol)               ; Move to beginning of current command.
    (when (or (<= old-point (point))
              (= (point-at-bol) (point)))
      (back-to-indentation) ; Go to the first significant column
      ;; If already at or before the first significant column...
      (when (<= old-point (point))
        ;; Then go to the beginning of the line.
        (beginning-of-line)))))
#+END_SRC

***** Accurate Prompt Timestamp
:PROPERTIES:
:DESCRIPTION: Before sending input, update the current prompt with a timestamp.
:END:

A common practice among users of command line interface (CLI) shells is to include timestamps in their shells' prompts.

In Bash, for example, timestamping one's prompt is frequently accomplished by using the ~date~ command as part of the prompt variable.
For example, the prompt src_sh[:exports code]{PS1="(\$date +%H:%M:%S) $"} would result in a prompt such as =21:43:41 $=.

I find the information by such a prompt to be misleading, however.

****** The Problem

My motivation for timestamping my prompts was to be able to easily answer the question, "When did I run this command?"
But rather than providing context for when the corresponding command was submitted, most =PS1=-inserted timestamps actually indicate when the /previous/ command finished executing.

Answering the question about when an arbitrary command \(c_n\) was submitted, then, involves
1. ignoring the timestamp \(t_n\) that is next to \(c_n\);
2. scrolling down to where the next command \(c_{n+1}\) was entered;
3. removing the timestamp \(t_{n+1}\) that is next to \(c_{n+1}\) from the context conferred upon it by its proximity to \(c_{n+1}\); and
4. mentally linking \(t_{n+1}\) back to \(c_n\).

Clearly, the task is not so complicated as to be impossible.
It is far less efficient and more error-prone than it could be, though.
That inefficiency results from requiring the user to
- consciously splitting then re-pairing timestamps and
- visually --- and, if scrolling is required, phsyically --- navigate between two prompts.


****** The Solution

The primary difficulty in establishing accurate timestamps is that doing so requires modifying the prompt text /after/ its input has been sent.
Some shells have workaround for this, such as Zsh's ~preexec~.
Rather than implementing such a function for Eshell, we can instead take advantage of the fact that Eshell is written in Emacs Lisp and outputs directly to an Emacs buffer.

Define a function to update the most recent prompt's timestamp.
#+BEGIN_SRC emacs-lisp
(defun esh-mode-timestamp-prompt ()
  "Update the timestamp at the beginning of the current prompt."
  (interactive)
  (let ((cur-pos (point)))
    ;; Move to the end of the buffer.
    (goto-char (point-max))
    ;; Move POINT to the end of the previous prompt, then to end of the next prompt.
    ;; This handles cases of multi-line input and ensures POINT is at the most recent prompt.
    (eshell-previous-prompt 1)
    (eshell-next-prompt 1)
    ;; Move POINT to the beginning of the line.
    (forward-line 0)
    (let ((inhibit-read-only t)
          (prompt-properties
           (list 'font-lock-face 'eshell-prompt
                 'font-sticky '(font-lock-face 'read-only)
                 'read-only t
                 'rear-nonsticky '(font-lock-face read-only))))
      ;; Remove the existing timestamp.
      (when (re-search-forward esh-mode-prompt-timestamp-regexp)
        (replace-match ""))
      ;; Insert the timestamp, propertized to match the rest of the prompt.
      (insert (apply #'propertize
                     (format-time-string esh-mode-prompt-timestamp-format-string)
                     prompt-properties)))
    ;; Restore POINT to its original location.
    (goto-char cur-pos)))
#+END_SRC
Where ~esh-mode-prompt-timestamp-format-string~ and ~esh-mode-prompt-timestamp-regexp~ are defined in ref:esh-mode-prompt-timestamp-format-string and ref:esh-mode-prompt-timestamp-regexp, respectively.

Call the above function before sending input.
#+BEGIN_SRC emacs-lisp
(advice-add 'eshell-send-input :before #'esh-mode-timestamp-prompt)
#+END_SRC

***** Narrow to Command

Narrow the buffer to the context ~point~ is currently in:
- command output :: narrow to the preceding command and the current output
- last prompt/command :: do nothing
- other prompt/command :: narrow to the prompt, command, and the command's output

#+BEGIN_SRC emacs-lisp
(defun esh-mode-narrow-to-command ()
  "Make text outside the current command invisible.

- If `point' is in the last prompt or last command, do nothing.
- If `point' is in command output, narrow to the output and the corresponding
  prompt and command.
- if `point' is in a prompt or command that's not the last, narrow to that
  prompt, command, and the corresponding output."
  (interactive)
  (let ((orig (point))
        (line-orig (line-number-at-pos (point)))
        (line-later-prompt (progn (eshell-next-prompt 2)
                                  (line-number-at-pos (point)))))
    ;; Restore original position.
    (goto-char orig)
    ;; If not in the last command...
    (if (not (= line-orig line-later-prompt))
        (let* ((command-beg (progn (eshell-bol) (point)))
               (line-beg (progn (beginning-of-line) (point)))
               (start (cond
                       ;; If not in a command...
                       ((= command-beg line-beg)
                        (eshell-previous-prompt 1)
                        (beginning-of-line)
                        (point))
                       ;; Else in a command...
                       (t
                        line-beg)))
               (end (progn
                      (eshell-next-prompt 2) ; next prompt
                      (previous-line 1) ; up one line
                      (end-of-line) ; end of line
                      (point))))
          (narrow-to-region start end)))))
#+END_SRC

***** Delete Whole Line

****** Define the Function

#+BEGIN_SRC emacs-lisp
(defun eshell-kill-whole-line ()
  "Kill the whole Eshell buffer line."
  (interactive)
  (kill-region (progn (eshell-bol) (point)) (line-end-position)))
#+END_SRC

****** Define an Evil Operator
:PROPERTIES:
:COPYRIGHT_AUTHOR: Alexander Shukaev
:COPYRIGHT_YEAR: 2015
:COPYRIGHT_URL: https://emacs.stackexchange.com/a/14958
:END:


.emacs.d/init.el: ‘evil-called-interactively-p’ is an obsolete macro (as of Git commit 222b791); please use (called-interactively-p ’any) instead.

#+BEGIN_SRC emacs-lisp
(evil-define-operator eshell-delete  (beg end type register yank-handler)
  "Delete text from BEG to END with TYPE.

Save in REGISTER or in the kill-ring with YANK-HANDLER."
  (interactive "<R><x><y>")
  (if (eq type 'line)
      (progn
        (unless register
          (let ((text (filter-buffer-substring beg end)))
            (unless (string-match-p "\n" text)
              (evil-set-register ?- text))))
        (let ((evil-was-yanked-without-register nil))
          (evil-yank beg end type register yank-handler))
        (dotimes (var (count-lines beg end))
          (eshell-kill-whole-line)))
    (evil-delete beg end type register yank-handler))
  (when (and (evil-called-interactively-p)
             (eq type 'line))
    (evil-first-non-blank)))
#+END_SRC

*** Em Hist
#+BEGIN_SRC emacs-lisp
(use-package em-hist
  :straight (:type built-in)

  ;; Load eagerly.
  :demand

  ;; Customize the following variables.
  :custom
  <<em-hist/custom>>)
#+END_SRC

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-hist/custom
:END:

Determine whether duplicates are skipped when traversing command history.
#+BEGIN_SRC emacs-lisp
(eshell-hist-ignoredups t "Skip duplicates when traversing command history.")
#+END_SRC

Determine how many commands are saved in history.
The default is 128.
#+BEGIN_SRC emacs-lisp
(eshell-history-size 10000)
#+END_SRC

*** Em Dirs
#+BEGIN_SRC emacs-lisp
(use-package em-dirs
  :straight (:type built-in)

  :demand

  :config
  <<em-dirs/config>>

  :commands
  (em-dirs-name-buffer))
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-dirs/config
:END:

***** Return Path Relative to Project Root
#+BEGIN_SRC emacs-lisp
(defun em-dirs-pwd-relative-to-project (directory)
  "Print DIRECTORY relative to its Projectile root, if any.

If DIRECTORY is in a project as determined by Projectile, return DIRECTORY's
path starting starting at the project's root.

If DIRECTORY is _not_ in a project, return the abbreviated form of DIRECTORY's
path."
  (s-chop-suffix
   "/"
   (if-let (((fboundp #'projectile-project-name))
            ((fboundp #'projectile-project-root))
            (project-root (projectile-project-root directory))
            (project-name (projectile-project-name project-root)))
       ;; If in a project:
       (if (string=
            (file-name-as-directory (expand-file-name directory))
            project-root)
           ;; If at a project's root: use the project's name
           project-name
         ;; Else not at project's root: use path starting with project's root
         (concat (file-name-as-directory project-name)
                 (file-relative-name
                  (expand-file-name directory)
                  project-root)))
     ;; Else not in project: use abbreviated path
     (abbreviate-file-name directory))))
#+END_SRC

***** Abbreviate Path Elements
Printing the path to the current directory in the shell prompt helps me keep track of the context.
However, if the path is long this can result in unwieldy prompts.
The following functions can be used to abbreviate a path by shortening each element in the path to that element's first non-period character;
only the last directory in the path is shown in full.

#+BEGIN_SRC emacs-lisp
(defun em-dirs-abbreviate-dirname (filename)
  (cond
   ((string-empty-p filename)
    "")
   ((string= (substring filename 0 1) ".")
    (substring filename 0 2))
   (t
    (substring filename 0 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun em-dirs-abbreviate-path (path)
  "Abbreviate each element in PATH except for the last.

Abbreviated path elements are represented by their first non-period
character. For example, the path \"/home/user/.config/curdir\" will become
\"/h/u/.c/curdir\"."
  (let* ((split-path (split-string path "/")))
    (if (< (length split-path) 2)
        (or (car split-path) "")
      (concat
       (file-name-as-directory
        (cl-reduce
         (lambda (directory filename)
           (concat (if (string-empty-p directory)
                       "/"
                     (file-name-as-directory directory))
                   filename))
         (mapcar
          #'em-dirs-abbreviate-dirname
          split-path)
         :end (- (length split-path) 1)))
       (car (last split-path)))
      path)))
#+END_SRC

***** Create Eshell Buffer Names
#+BEGIN_SRC emacs-lisp
(defun em-dirs-name-buffer (directory &optional process-name)
  "Create a name for an Eshell buffer in DIRECTORY."
  (concat "*eshell "
          (em-dirs-pwd-relative-to-project directory)
          (when process-name
            (concat " <" process-name ">"))
          "*"))
#+END_SRC

***** Prefer Changing Buffers to Changing Directories
Redefine ~eshell/cd~ to prefer switching to an Eshell buffer in the new directory (if such a buffer exists) over changing the directory of the buffer where ~eshell/cd~ was called.
Whether or not an Eshell buffer exists at the specified location is determined by the name of existing Eshell buffers.

The following code is derived directly from code in GNU Emacs's Em Dirs and Files packages.
As such, it is licensed under GPLv3.

#+BEGIN_SRC emacs-lisp
(defun eshell/cd (&rest args)
  "Alias to extend the behavior of `cd'.

If an Eshell buffer already exists at the target directory, switch to that
buffer.  Otherwise, change the working directory of the current buffer to the
target directory then rename the current buffer to reflect its new working
directory.

The presence of an existing Eshell buffer at the new location is determined by
comparing the name of buffers to the result of `em-dirs-name-buffer'."
  (setq args (eshell-flatten-list args))
  (let ((path (car args))
        (subpath (car (cdr args)))
        (case-fold-search (eshell-under-windows-p))
        handled)
    (if (numberp path)
        (setq path (number-to-string path)))
    (if (numberp subpath)
        (setq subpath (number-to-string subpath)))
    (cond
     (subpath
      (let ((curdir (eshell/pwd)))
        (if (string-match path curdir)
            (setq path (replace-match subpath nil nil curdir))
          (error "Path substring `%s' not found" path))))
     ((and path (string-match "^-\\([0-9]*\\)$" path))
      (let ((index (match-string 1 path)))
        (setq path
              (ring-remove eshell-last-dir-ring
                           (if index
                               (string-to-number index)
                             0)))))
     ((and path (string-match "^=\\(.*\\)$" path))
      (let ((oldpath (eshell-find-previous-directory
                      (match-string 1 path))))
        (if oldpath
            (setq path oldpath)
          (let ((len (ring-length eshell-last-dir-ring))
                (index 0))
            (if (= len 0)
                (error "Directory ring empty"))
            (eshell-init-print-buffer)
            (while (< index len)
              (eshell-buffered-print
               (concat (number-to-string index) ": "
                       (ring-ref eshell-last-dir-ring index) "\n"))
              (setq index (1+ index)))
            (eshell-flush)
            (setq handled t)))))
     (path
      (setq path (eshell-expand-multiple-dots path))))
    (unless handled
      (let* ((cd-path (or (parse-colon-path (getenv "CDPATH"))
                          (list "./")))
             (curdir (eshell/pwd))
             (newdir (expand-file-name (file-name-as-directory (or path "~"))))
             (newname (em-dirs-name-buffer newdir)))
        (unless (equal curdir newdir)
          (eshell-add-to-dir-ring curdir))
        ;; If an Eshell buffer already exists in the new directory...
        (if-let ((newbuf (get-buffer newname)))
            ;; Then switch to the existing Eshell buffer.
            (switch-to-buffer newbuf)
          ;; Else change to the new directory.
          (let ((result (cd newdir)))
            ;; Change the buffer's name.
            (rename-buffer newname)
            ;; If `eshell-cd-shows-directory' is non-nil...
            (when eshell-cd-shows-directory
              ;; Then print the new directory.
              (eshell-printn result))))
        (run-hooks 'eshell-directory-change-hook)
        (if eshell-list-files-after-cd
            ;; Let-bind eshell-last-command around this?
            (eshell-plain-command "ls" (cdr args)))
        nil))))
    #+END_SRC

*** Eshell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after (:all evil ivy em-dirs em-hist)

  ;; Inform the bytecode compiler of the following functions.
  :commands
  (eshell-add-visual-commands
   esh-mode-beginning-of-line-maybe
   eshell-find-eshell
   eshell-find-eshell-here
   eshell-prompt)

  ;; Add the following keybindings.
  :general
  <<eshell/general>>

  ;; Add the following non-autoloading hooks.
  :gfhook
  <<eshell/gfhook>>

  ;; Customize the following variables.
  :custom
  <<eshell/custom>>

  ;; Execute the following code before loading this package.
  :init
  <<eshell/init>>

  ;; Execute the following code after loading this package.
  :config
  <<eshell/config>>)
#+END_SRC

**** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/general
:END:

Map the opening an Eshell buffer to =C-x z=.
This keybinding mirrors the defaults for ~find-file~ and ~dired~.

#+BEGIN_SRC emacs-lisp
("C-x z" #'eshell-find-eshell)
#+END_SRC

Map ~eshell-find-eshell-here~ to =C-z=.
This imitates the behavior of *NIX terminal applications.
In most terminal applications, =C-z= is the key combination to suspend the current process which usually results in the user being returned to their shell.

#+BEGIN_SRC emacs-lisp
("C-z" #'eshell-find-eshell-here)
#+END_SRC

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/gfhook
:END:

Build the list of commands to be run in Term mode buffers.

#+BEGIN_SRC emacs-lisp
(nil #'eshell-add-visual-commands)
#+END_SRC

Bind keys.
#+BEGIN_SRC emacs-lisp
(nil #'eshell-define-keys)
#+END_SRC

**** Customize Variables
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/custom
:END:

#+BEGIN_SRC emacs-lisp
(eshell-prefer-lisp-functions nil "Prefer external commands to Lisp functions.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(eshell-prefer-lisp-variables nil "Prefer environment variables to Lisp variables.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(eshell-prompt-function #'eshell-prompt)
#+END_SRC

**** Pre-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/init
:END:

***** Eshell Prompt
#+BEGIN_SRC emacs-lisp
(defun eshell-prompt ()
  "Prefix \"$USER@$(hostname):\" if on remote host."
  (concat
   (format-time-string
    (concat esh-mode-prompt-timestamp-format-string " "))
   (if (file-remote-p default-directory 'host)
       (with-parsed-tramp-file-name default-directory nil
         (concat
          (when user
            (concat user "@"))
          host ":"
          localname))
     (em-dirs-abbreviate-path
      (em-dirs-pwd-relative-to-project
       (expand-file-name default-directory))))
   (if (= (user-uid) 0)
       " # "
     " $ ")))
#+END_SRC

***** Set =$PAGER=
Because Eshell runs entirely within an Emacs buffer, Eshell does not need an external pager.
Instead, text can be dumped directly into the buffer.
This is accomplished by setting ~PAGER~ to ~cat~.

#+BEGIN_SRC emacs-lisp
(setenv "PAGER" "cat")
#+END_SRC

***** Use Magit for Some Git Commands
The code in this section is copyright Gergely Nagy [[mailto:algernon@bonehunter.rulez.org][<algernon@bonehunter.rulez.org>]] and shared under GPLv3.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'magit
  (defun eshell/git (command &rest args)
    (pcase command
      ;; Use magit's log.
      ("log" (apply #'algernon/git-log args))
      ;; Use magit's status.
      ("status" (progn
                  (magit-status)
                  (eshell/echo)))
      ;; Run all other commands directly in `git'.
      (_ (let ((command (s-join " " (append (list "git" command) args))))
           (message command)
           (shell-command-to-string command))))))
#+END_SRC

Run ~magit-log~ after determining if the argument to ~git log~ was a file or branch.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'magit
  (defun algernon/git-log (&rest args)
    (let* ((branch-or-file (car args))
           (file-list (if (and branch-or-file (f-file-p branch-or-file))
                          args
                        (cdr args)))
           (branch (if (and branch-or-file (f-file-p branch-or-file))
                       "HEAD"
                     branch-or-file)))
      (message branch-or-file)
      (if branch-or-file
          (magit-log (list branch)
                     '()
                     (mapcar
                      (lambda (f) (concat (file-name-as-directory (eshell/pwd)) f))
                      file-list))
        (magit-log-head)))
    (eshell/echo)))
#+END_SRC

**** Post-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/config
:END:

***** "Visual" Commands
Run the following commands in a =term= buffer:
#+NAME: visual-commands
- alsamixer
- ssh
- top
- tail

#+BEGIN_SRC emacs-lisp
(defun eshell-add-visual-commands ()
  "Add commands to `eshell-visual-commands'."
  (let ((commands (list "alsamixer" "ssh" "top" "tail")))
    (dolist (command commands)
      (add-to-list 'eshell-visual-commands command))))
#+END_SRC

***** Custom Functions
****** Open Eshell in a Given Directory
Open or switch to an Eshell buffer in a given directory.

#+BEGIN_SRC emacs-lisp
(defun eshell-find-eshell (directory)
  "Open Eshell in DIRECTORY.

If an Eshell instance for the directory already exists, switch to it.  If no
such instance exists, start a new instance whose name includes the directory."
  (interactive "DOpen Eshell in: ")
  (let* ((eshell-buffer-name (em-dirs-name-buffer directory))
         (buffer (get-buffer-create eshell-buffer-name)))
    (pop-to-buffer-same-window buffer)
    (cd directory)
    (unless (derived-mode-p 'eshell-mode)
      (eshell-mode))
    buffer))
#+END_SRC

****** Open Eshell in the Current Directory

Define a function to open an Eshell instance in the current directory.
If an Eshell instance already exists in that directory, switch to its buffer.

#+BEGIN_SRC emacs-lisp
(defun eshell-find-eshell-here ()
  "Open Eshell in the current working directory.

If an Eshell instance for the directory already exists, switch to it. If no such
instance exists, start a new instance whose name includes the directory."
  (interactive)
  (let ((cwd (abbreviate-file-name (if (buffer-file-name)
                                       (file-name-directory (buffer-file-name))
                                     default-directory))))
    (eshell-find-eshell cwd)))
    #+END_SRC

****** "Background" the Current Process

If a long-running process is started from an Eshell prompt without explicitly backgrounding the process, that process will block any further input to the prompt.
Because having access to long-running processes' stdout and stderr is useful, there is a need for an interactive function that can
1. preserve the buffer belonging to that long-running process;
2. rename the buffer belonging to the process; and
3. open a new Eshell buffer in the same directory.


#+BEGIN_SRC emacs-lisp
(defun eshell/background-process-maybe ()
  "Rename the Eshell BUFFER with its process and reopen the directory."
  (interactive)
  (when-let ((path default-directory)
             (process (get-buffer-process (current-buffer)))
             (process-name (process-name process)))
    (rename-buffer (em-dirs-name-buffer path process-name))
    (eshell-find-eshell path)))
#+END_SRC

UNIX shells use the chord =C-z= to background the current process.

#+BEGIN_SRC emacs-lisp
(defun eshell-bind-background-process-maybe ()
  "Add a keybinding for `eshell/background-process-maybe'."
  (general-define-key
   :keymaps 'eshell-mode-map
   "C-z" #'eshell/background-process-maybe))
#+END_SRC

****** Clear Buffer

#+BEGIN_SRC emacs-lisp
(defun eshell/clear-scrollback-keep-input ()
  "Clear the scrollback content of the eshell window but keep any current input."
  (interactive)
  (let ((input (eshell-get-old-input)))
    (eshell/clear-scrollback)
    (eshell-emit-prompt)
    (insert input)))
#+END_SRC

***** Keybindings

Add the following keybindings:
- =d= :: custom Evil deletion operator
- =C-l= :: clear the buffer's scrollback
- =C-x n c= :: narrow to the current command
- =C-z= :: "background" the current process

#+BEGIN_SRC emacs-lisp
(defun eshell-define-keys ()
  "Define keys for eshell."
  (with-eval-after-load 'general
    (general-define-key
     :keymaps 'eshell-mode-map
     "C-l" #'eshell/clear-scrollback-keep-input
     "C-x n c" #'esh-mode-narrow-to-command
     "C-z" #'eshell/background-process-maybe)
    (general-define-key
     :keymaps 'eshell-mode-map
     :states '(movement normal visual)
     "d" #'eshell-delete)
    (general-define-key
     :keymaps 'eshell-mode-map
     :states 'insert
     "C-r" #'counsel-esh-history)))
#+END_SRC

*** Esh Module

From the package group's docstring:
#+BEGIN_QUOTE
The ~eshell-module~ group is for Eshell extension modules, which provide optional behavior which the user can enable or disable by customizing the variable ~eshell-modules-list~.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package esh-module
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Customize the following variables.
  :custom
  <<esh-module/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<esh-module/config>>)
#+END_SRC

**** Post-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref esh-module/config
:END:

Disable the greeting banner.

#+BEGIN_SRC emacs-lisp
(setq eshell-modules-list (delq 'eshell-banner eshell-modules-list))
#+END_SRC

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref esh-module/custom
:END:

Determine whether input causes window to scroll.
#+BEGIN_SRC emacs-lisp
(eshell-scroll-to-bottom-on-input
 'this
 "On input, scroll the selected Eshell window to the bottom.")
#+END_SRC

*** Em Smart

Em Smart is an Eshell module that provides Eshell with Plan 9-like features.

#+BEGIN_SRC emacs-lisp
(use-package em-smart
  :straight (:type built-in)

  ;; Load this package after the following packages.
  :after (esh-module)

  :custom
  (eshell-where-to-jump 'begin)
  (eshell-review-quick-commands nil)

  :config
  <<em-smart/config>>)
#+END_SRC

**** Config
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-smart/config
:END:

#+BEGIN_SRC emacs-lisp
(add-to-list 'eshell-modules-list 'eshell-smart)
#+END_SRC

*** Em Tramp

Em Tramp is an Eshell modules that provides TRAMP features.

#+BEGIN_SRC emacs-lisp
(use-package em-tramp
  :straight (:type built-in)

  ;; Load this package after the following packages.
  :after (esh-module)

  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<em-tramp/config>>)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-tramp/config
:END:

Load Em Tramp as an Eshell module.

#+BEGIN_SRC emacs-lisp
(add-to-list 'eshell-modules-list 'eshell-tramp)
#+END_SRC

***** Redefine ~eshell/sudo~

For ease of use with Emacs's authentication mechanisms, the full hostname of the machine should be resolved in all cases, even when the Eshell prompt is running locally.

The following code is derived from the Em Tramp package distributed with GNU Emacs.
As such, it is licensed under the same conditions as GNU Emacs itself (namely, GPLv3 or later).

#+BEGIN_SRC emacs-lisp
(defun eshell/sudo (&rest args)
  "Alias \"sudo\" to call Tramp.

Uses the system sudo through TRAMP's sudo method."
  (setq args (eshell-stringify-list (eshell-flatten-list args)))
  (let ((orig-args (copy-tree args)))
    (eshell-eval-using-options
     "sudo" args
     '((?h "help" nil nil "show this usage screen")
       (?u "user" t user "execute a command as another USER")
       :show-usage
       :usage "[(-u | --user) USER] COMMAND
      Execute a COMMAND as the superuser or another USER.")
     (throw 'eshell-external
            (let ((user (or user "root"))
                  (host (or (file-remote-p default-directory 'host)
                            (system-name)))
                  (dir (file-local-name (expand-file-name default-directory)))
                  (prefix (file-remote-p default-directory)))
              ;; `eshell-eval-using-options' reads options of COMMAND.
              (while (and (stringp (car orig-args))
                          (member (car orig-args) '("-u" "--user")))
                (setq orig-args (cddr orig-args)))
              (let ((default-directory
                      (if (and prefix
                               (or
                                (not
                                 (string-equal
                                  "sudo"
                                  (file-remote-p default-directory 'method)))
                                (not
                                 (string-equal
                                  user
                                  (file-remote-p default-directory 'user)))))
                          (format "%s|sudo:%s@%s:%s"
                                  (substring prefix 0 -1) user host dir)
                        (format "/sudo:%s@%s:%s" user host dir))))
                (eshell-named-command (car orig-args) (cdr orig-args))))))))
#+END_SRC

*** Em Rebind

#+BEGIN_SRC emacs-lisp
(use-package em-rebind
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after (esh-module)

  ;; Apply the following variable customizations.
  :custom
  <<em-rebind/custom>>

  ;; Evaluate the following code before loading this package.
  :init
  <<em-rebind/init>>

  ;; Evaluate the following code after loading this package.
  :config
  <<em-rebind/config>>)
#+END_SRC

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-rebind/custom
:END:

Determine whether movement commands can cause the point to leave the current input.
#+BEGIN_SRC emacs-lisp
(eshell-confine-point-to-input
 nil
 "Allow movement commands to move `point' out of the current input.")
#+END_SRC

**** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-rebind/init
:END:

Add this module to the list of Eshell modules to load.

#+BEGIN_SRC emacs-lisp
(push 'eshell-rebind eshell-modules-list)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-rebind/config
:DESCRIPTION: The code to be evaluated after ~em-rebind~ has been loaded.
:END:

Rebind Emacs's vertical movement keys to search through history.
Normal buffer movement is performed using keybindings provided by ~evil~.

#+BEGIN_SRC emacs-lisp
(push '([(control ?n)] . eshell-previous-matching-input-from-input)
      eshell-rebind-keys-alist)
#+END_SRC

*** Em Cmpl

#+BEGIN_SRC emacs-lisp
(use-package em-cmpl
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Apply the following variable customizations.
  :custom
  (eshell-cmpl-cycle-completions nil "Use zsh-like completion."))
#+END_SRC

* Static Analysis
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref static-analysis
:END:

** Flyspell

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :straight (:type built-in)

  :ghook
  ('prog-mode-hook #'flyspell-prog-mode))
#+END_SRC

** Ispell

#+BEGIN_SRC emacs-lisp
(use-package ispell
  :straight (:type built-in)

  ;; Only load this package if the following code evaluates to non-nil.
  :if
  <<ispell/if>>

  ;; Do not load this package lazily.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<ispell/config>>)
#+END_SRC

*** Conditional Loading
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ispell/if
:DESCRIPTION: Define condition for loading Ispell.
:END:

Ispell provides interfaces for third-party spellchecking binaries.
If no such binaries exist, Ispell does not need to be downloaded.

#+BEGIN_SRC emacs-lisp
(executable-find "aspell")
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ispell/config
:DESCRIPTION: Code to be evaluated after Ispell has been loaded.
:END:

Set the executable to use for spellchecking.
If =aspell= is not available, disable Ispell.

#+BEGIN_SRC emacs-lisp
(cond
 ((executable-find "aspell")
  (setq ispell-program-name "aspell"))
 (t
  (setq ispell-program-name nil)))
#+END_SRC

** Flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  ;; Enable `flycheck-mode' globally.
  (global-flycheck-mode))
#+END_SRC

* Feeds
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref feeds
:END:

** Email
*** mu4e

#+BEGIN_SRC emacs-lisp
(use-package mu4e
  ;; Load `mu4e' after the following packages.
  :after (flyspell ispell s)

  ;; Inform the bytecode compiler of the following functions.
  :commands (mu4e-choose-msmtp-account mu4e-show-trailing-whitespace)

  ;; Apply the following variable customizations.
  :custom
  <<mu4e/custom>>

  ;; Add the following, non-autoloading hooks.
  :gfhook
  <<mu4e/gfhook>>

  ;; Add keybindings according to the following alist.
  :bind
  (("C-x m" . mu4e-compose-new))

  ;; Evaluate the following code after loading this package.
  :config
  <<mu4e/config>>)
#+END_SRC

**** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mu4e/custom
:END:

Use ISO-esque timestamps for ~:human-date~.

#+BEGIN_SRC emacs-lisp
(mu4e-headers-date-format "%Y-%m-%d %H:%M")
#+END_SRC

***** Account Contexts
Do not prompt for the context when starting mu4e.
Being in the proper context is unnecessary except when composing messages.

#+BEGIN_SRC emacs-lisp
(mu4e-context-policy 'pick-first "Do not be concerned about context on startup.")
#+END_SRC

If no context matches (using its match function) when beginning to compose a message, prompt the user to manually select a context.

#+BEGIN_SRC emacs-lisp
(mu4e-compose-context-policy 'ask)
#+END_SRC

***** Fetching and Indexing
Display the update status in the modeline.
This helps keep track of the current update status.

#+BEGIN_SRC emacs-lisp
(mu4e-display-update-status-in-modeline t "Display the update status in the modeline.")
#+END_SRC

Do not display messages related to updating or indexing.
These messages are generally uninteresting.

#+BEGIN_SRC emacs-lisp
(mu4e-hide-index-messages t "Do not display messages related to updating or indexing.")
#+END_SRC

***** Sending
#+BEGIN_SRC emacs-lisp
(message-sendmail-envelope-from 'header "Use the value from the mail's header as the FROM field.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(message-kill-buffer-on-exit t "Close the message buffer after sending its message.")
#+END_SRC

***** Composing
Use [[https://joeclark.org/ffaq.htm][format\=flowed]] for nicer viewing of plaintext mail.

#+BEGIN_SRC emacs-lisp
(mu4e-compose-format-flowed t "Use format=flowed when composing mail.")
#+END_SRC

Replace the current frame when writing mail.

#+BEGIN_SRC emacs-lisp
(mu4e-compose-in-new-frame nil "Do not open a new frame when composing mail.")
#+END_SRC

If a signature is set, automatically include it.

#+BEGIN_SRC emacs-lisp
(mu4e-compose-signature-auto-include t "Automatically include signatures.")
#+END_SRC

***** Message View
Show senders' full addresses.

#+BEGIN_SRC emacs-lisp
(mu4e-view-show-addresses t "Show senders' full addresses.")
#+END_SRC

View messages in their own window.

#+BEGIN_SRC emacs-lisp
(mu4e-split-view 'single-window)
#+END_SRC

***** Header View
Display the following fields in the headers buffer:
- date
- mailing list
- =FROM:= or =TO:= address
- subject


#+BEGIN_SRC emacs-lisp
(mu4e-headers-fields
 '((:human-date . 16)
   (:flags . 8)
   (:mailing-list . 10)
   (:from-or-to . 20)
   (:subject . nil)))
#+END_SRC

Use Unicode box-drawing characters for the prefixes.

#+BEGIN_SRC emacs-lisp
(mu4e-headers-has-child-prefix '("-" . "─"))
(mu4e-headers-empty-parent-prefix '("-" . "─"))
(mu4e-headers-first-child-prefix '("-" . "─"))
(mu4e-headers-duplicate-prefix '("=" . "═"))
(mu4e-headers-default-prefix '("-" . "─"))
#+END_SRC

***** Mail Directory

Use the value of ~$MAILDIR~ as the path to the mail directory if that environment variable exists.
#+BEGIN_SRC emacs-lisp
(mu4e-maildir (xdg-user-dir "MAIL"))
#+END_SRC

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mu4e/gfhook
:END:

Enable Flyspell mode when composing mail.

#+BEGIN_SRC emacs-lisp
('mu4e-compose-mode-hook #'flyspell-mode)
#+END_SRC

Show trailing whitespace when composing mail.

#+BEGIN_SRC emacs-lisp
('mu4e-compose-mode-hook #'mu4e-show-trailing-whitespace)
#+END_SRC

Specify the SMTP account to use before sending mail.

#+BEGIN_SRC emacs-lisp
('message-send-mail #'mu4e-choose-msmtp-account)
#+END_SRC

**** Post-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mu4e/config
:END:

***** Fetching and Indexing
If isync is installed, use =mbsync= to fetch all mail and rename filenames when moving mail.

#+BEGIN_SRC emacs-lisp
(when (executable-find "mbsync")
  (setq mu4e-get-mail-command "mbsync -a")
  (setq mu4e-change-filenames-when-moving t))
#+END_SRC

***** Sending Mail
Choose how mail is sent, preferring =msmtp= to the built-in =smtpmail-send-it=.

#+BEGIN_SRC emacs-lisp
(cond ((executable-find "msmtp")
       <<mu4e/config/sending/msmtp>>)
      (t
       <<mu4e/config/sending/smtpmail-send-it>>))
#+END_SRC

****** =msmtp= Configuration
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mu4e/config/sending/msmtp
:END:

Use =msmtp= as the sender.

#+BEGIN_SRC emacs-lisp
(setq
 sendmail-program (executable-find "msmtp")
 message-send-mail-function #'message-send-mail-with-sendmail)
#+END_SRC

Supply an account label (option =-a=) to =msmtp= based on the mu4e context.

#+BEGIN_SRC emacs-lisp
(defun mu4e-choose-msmtp-account ()
  "Choose msmtp account label based on mu4e context name."
  (when (message-mail-p)
    (let ((account-name
           ;; Replace "@" with "." in the current context name.
           (s-replace "@" "." (mu4e-context-name (mu4e-context-current)))))
      (setq
       message-sendmail-extra-arguments (list '"-a" account-name)))))
#+END_SRC

****** ~smtpmail-send-it~ Configuration
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mu4e/config/sending/smtpmail-send-it
:END:

Provide settings for using ~smtpmail-send-it~ to send mail.

#+BEGIN_SRC emacs-lisp
(setq
 message-send-mail-function 'smtpmail-send-it
 send-mail-function 'smtpmail-send-it
 ;; Set the port number.
 smtpmail-smtp-service 587
 ;; Set the type of connection.
 smtpmail-stream-type 'starttls)
#+END_SRC

***** Multiple Accounts
#+BEGIN_SRC emacs-lisp
(setq
 mu4e-contexts `( ,(make-mu4e-context
                    ;; Name of the context
                    :name "edu.utdallas@jml140230"
                    ;; alist of variables to set for this context.
                    :vars '((user-full-name . "LaFreniere, Joseph")
                            (user-mail-address . "jml140230@utdallas.edu")
                            ;; SMTP
                            (smtpmail-smtp-server . "smtp.office365.com") ; hostname
                            (smtpmail-smtp-user . "jml140230@utdallas.edu") ; username
                            ;; Signature
                            (mu4e-compose-signature-auto-include . t)
                            (mu4e-compose-signature . "Joseph LaFreniere")
                            ;; Folders
                            (mu4e-archive-folder . "/edu.utdallas.jml140230/archive")
                            (mu4e-drafts-folder . "/edu.utdallas.jml140230/draft")
                            (mu4e-sent-folder .  "/edu.utdallas.jml140230/sent")
                            (mu4e-trash-folder . "/edu.utdallas.jml140230/trash"))
                    ;; =match-func= returns true when the passed message matches this context.
                    :match-func (lambda (msg)
                                  (when msg
                                    (mu4e-message-field msg :maildir)
                                    (string-prefix-p "/edu.utdallas.jml140230"
                                                     (mu4e-message-field msg :maildir)))))
                  ,(make-mu4e-context
                    ;; Name of the context
                    :name "xyz.lafreniere@joseph"
                    ;; alist of variables to set for this context.
                    :vars '((user-full-name . "LaFreniere, Joseph")
                            (user-mail-address . "joseph@lafreniere.xyz")
                            ;; Signature
                            (mu4e-compose-signature-auto-include . t)
                            (mu4e-compose-signature . "Joseph LaFreniere")
                            ;; SMTP
                            (smtpmail-smtp-server . "smtp.kolabnow.com") ; hostname
                            (smtpmail-smtp-user . "joseph@lafreniere.xyz") ; username
                            ;; Folders
                            (mu4e-archive-folder . "/xyz.lafreniere.joseph/archive")
                            (mu4e-drafts-folder . "/xyz.lafreniere.joseph/draft")
                            (mu4e-sent-folder .  "/xyz.lafreniere.joseph/sent")
                            (mu4e-trash-folder . "/xyz.lafreniere.joseph/trash"))
                    ;; =match-func= returns true when the passed message matches this context.
                    :match-func (lambda (msg)
                                  (when msg
                                    (mu4e-message-field msg :maildir)
                                    (string-prefix-p "/xyz.lafreniere.joseph"
                                                     (mu4e-message-field msg :maildir)))))
                  ,(make-mu4e-context
                    ;; Name of the context
                    :name "com.gmail@lafrenierejm"
                    ;; alist of variables to set for this context.
                    :vars '((user-full-name . "LaFreniere, Joseph")
                            (user-mail-address . "lafrenierejm@gmail.com")
                            ;; Signature
                            (mu4e-compose-signature-auto-include . t)
                            (mu4e-compose-signature . "Joseph LaFreniere")
                            ;; SMTP
                            (smtpmail-smtp-server . "smtp.gmail.com") ; hostname
                            (smtpmail-smtp-user . "lafrenierejm@gmail.com") ; username
                            ;; Folders
                            (mu4e-archive-folder . "/com.gmail.lafrenierejm/archive")
                            (mu4e-drafts-folder . "/com.gmail.lafrenierejm/draft")
                            (mu4e-sent-folder .  "/com.gmail.lafrenierejm/sent")
                            (mu4e-trash-folder . "/com.gmail.lafrenierejm/trash"))
                    ;; =match-func= returns true when the passed message matches this context.
                    :match-func (lambda (msg)
                                  (when msg
                                    (mu4e-message-field msg :maildir)
                                    (string-prefix-p "/com.gmail.lafrenierejm"
                                                     (mu4e-message-field msg :maildir)))))))
#+END_SRC

****** My Addresses
mu4e maintains a list of addresses whose presence in a message's From field means that the message was sent by me.
In such cases, display the To address(es).

#+BEGIN_SRC emacs-lisp
(setq
 mu4e-user-mail-address-list '("admin@lafreniere.xyz"
                               "jml140230@utdallas.edu"
                               "joseph.lafreniere@utdallas.edu"
                               "joseph@lafreniere.xyz"
                               "lafrenierejm@gmail.com"
                               "lafrenierejm@utdallas.edu"))
#+END_SRC

***** Composing Mail

Show trailing whitespace.
This is helpful when composing =format=flowed= mail.

#+BEGIN_SRC emacs-lisp
(defun mu4e-show-trailing-whitespace ()
  "Highlight trailing whitespace with face `trailing-whitespace'."
  (setq show-trailing-whitespace t))
#+END_SRC

*** Message

#+BEGIN_SRC emacs-lisp
(use-package message
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Non-autoloading hooks.
  :gfhook
  <<message/gfhook>>

  ;; Evaluate the following code after loading this package.
  :config
  <<message/config>>)
#+END_SRC

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref message/gfhook
:END:

Prompt the user before sending a message without an attachment.

#+BEGIN_SRC emacs-lisp
('message-send-hook #'mbork/message-warn-if-no-attachments)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref message/config
:END:

***** Attachment Reminders
The following code is taken from Marcin Borkowski's 2016-02-06 post [[http://mbork.pl/2016-02-06_An_attachment_reminder_in_mu4e]["An attachment reminder in mu4e"]].
Borkowski's post links to the [[https://github.com/mbork/message][mbork/message]] repository on GitHub as the host for the attachment reminder code.
Interestingly, the repository appears to contain neither the attachment code nor any commits that hint at the code having ever been committed into the repository's mbork-message package.
Despite the attachment code never having (publicly) been a part of mbork/message, the code is attributed here to Borkowsi under the same GPLv2 license as mbork-message.

#+BEGIN_SRC emacs-lisp
(defun mbork/message-attachment-present-p ()
  "Return t if an attachment is found in the current message."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      (when (search-forward "<#part" nil t)
        t))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defcustom mbork/message-attachment-intent-re
  (regexp-opt '("attachment" "attached"))
  "If this regex is matched then the message should have an attachment.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defcustom mbork/message-attachment-reminder
  "Are you sure you want to send this message without any attachment? "
  "The question asked when trying to send a message with a missing attachment.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun mbork/message-warn-if-no-attachments ()
  "Ask if the user wants to send even though the message has no attachment."
  (when (and (save-excursion
               (save-restriction
                 (widen)
                 (goto-char (point-min))
                 (re-search-forward mbork/message-attachment-intent-re nil t)))
             (not (mbork/message-attachment-present-p)))
    (unless (y-or-n-p mbork/message-attachment-reminder)
      (keyboard-quit))))
#+END_SRC

*** Mml

#+BEGIN_SRC emacs-lisp
(use-package mml
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<mml/config>>)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mml/config
:END:

***** Add Attachments at Ends of Buffers
~mml-attach-file~, the function used by ~mu4e-compose-mode~ to add attachments to mail, attaches the specified file wherever point happens to be.
[[http://emacs.1067599.n8.nabble.com/Why-does-mml-attach-file-put-the-attachment-at-the-very-end-of-the-message-td373798.html][This thread]], authored by Marcin Borkowski, explores the problems that attachments anywhere but the end of a message buffer can cause.
In light of that, it is desirable to only /ever/ insert attachments at the end of the buffer.
This can be accomplished by advising ~mml-attach-file~ to automatically move and restore ~point~.
Borkowsi provided code to do so in [[http://mbork.pl/2015-11-28_Fixing_mml-attach-file_using_advice][a blog post]]:

#+BEGIN_SRC emacs-lisp
(defun init-email/mml-attach-file-at-eob (orig-fun &rest args)
  "Go to the end of the buffer before attaching files."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-max))
      (apply orig-fun args))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(advice-add 'mml-attach-file :around #'init-email/mml-attach-file-at-eob)
#+END_SRC

The license of the code hosted on Borkowsi's blog does not appear to be specified anywhere in the blog.
I have reached out to Borkowski asking how he would like the code to be licensed.

** Atom and RSS

I Use Chris Wellons's /Elfeed/ for managing my web feeds.

*** /Elfeed/

#+BEGIN_SRC emacs-lisp
(use-package elfeed)
#+END_SRC

*** /Elfeed Org/

/Elfeed Org/ allows the use of an Org file to specify feeds for /Elfeed/.
I set it to load =elfeed.org= from my Emacs directory.
The primary advantage of doing so is that it allows me to version-control the file along with the rest of my Emacs configuration.

#+BEGIN_SRC emacs-lisp
(use-package elfeed-org
  :demand

  :custom
  (rmh-elfeed-org-files
   (list (expand-file-name "elfeed.org" user-emacs-directory)))

  :config
  ;; load feeds from `rmh-elfeed-org-files' when elfeed starts
  (elfeed-org))
#+END_SRC

* PDF
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref pdf
:END:

** PDF Tools

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  ;; Establish deferred binding within `auto-mode-alist'.
  :mode
  <<pdf-tools/mode>>

  ;; Create key maps and, if necessary, autoloads.
  :general
  <<pdf-tools/general>>

  ;; Evalutate the following code before loading this package.
  :init
  (pdf-tools-install t))
#+END_SRC

*** Filename Mapping
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref pdf-tools/mode
:END:

Create an alist whose keys are regexps matching filenames and whose values are the function to enable ~pdf-view-mode~.

#+BEGIN_SRC emacs-lisp
("\\.pdf\\'" . pdf-view-mode)
#+END_SRC

*** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref pdf-tools/general
:END:

#+BEGIN_SRC emacs-lisp
(:keymaps 'pdf-view-mode-map
 "h" #'left-char
 "j" #'pdf-view-next-line-or-next-page
 "k" #'pdf-view-previous-line-or-previous-page
 "l" #'right-char
 "q" nil
 "y" #'kill-region)
#+END_SRC

* Programming Languages
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref programming-languages
:END:

** Applescript

*** Apples Mode

#+BEGIN_SRC emacs-lisp
(use-package apples-mode
  :mode
  ("\\.\\(applescri\\|sc\\)pt\\'")

  :general
  (:keymap 'apples-mode-map
   "C-c C-c" #'apples-run-region/buffer))
#+END_SRC

** Lisps

It is desirable to have slightly different character matching behavior when editing Lisps.
The following is a list of the Lisp modes I edit in.

#+BEGIN_SRC emacs-lisp :noweb-ref smartparens/preface
(defconst lisp-major-modes
  '(cider-repl-mode
    clojure-mode
    emacs-lisp-mode
    hy-mode
    ielm-mode
    inferior-hy-mode
    lisp-mode
    minibuffer-inactive-mode
    scheme-mode)
  "A list of Lisp major modes.")
#+END_SRC

And the above modes' hooks:
#+BEGIN_SRC emacs-lisp :noweb-ref smartparens/preface
(defconst lisp-major-mode-hooks
  (mapcar #'derived-mode-hook-name lisp-major-modes)
  "A list of Lisp major mode hooks.")
#+END_SRC

The function \src_emacs-lisp{derived-mode-hook-name} is provided by /Derived/, which is a built-in package and can be \src_emacs-lisp{require}d.
#+BEGIN_SRC emacs-lisp :noweb-ref dependencies
(require 'derived)
#+END_SRC

For sexp-based languages it is also desirable to disallow tabs for line indentation.
#+BEGIN_SRC emacs-lisp
(defun use-spaces ()
  "Only use spaces (as opposed to tabs) for indentation."
  (setq indent-tabs-mode nil))
#+END_SRC

The above function should be added to all Lisp major mode hooks.
#+BEGIN_SRC emacs-lisp
(general-add-hook lisp-major-mode-hooks #'use-spaces)
#+END_SRC

*** Lisp Mode

#+BEGIN_SRC emacs-lisp
(use-package lisp-mode
  :straight (:type built-in)

  :demand

  :config
  <<lisp-mode/config>>)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref lisp-mode/config
:END:

***** Fuco1's Indentation
:PROPERTIES:
:COPYRIGHT_AUTHOR: Matus Goljer (Fuco1)
:COPYRIGHT_EMAIL: matus.goljer@gmail.com
:COPYRIGHT_URL: https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94
:COPYRIGHT_YEAR: 2015
:END:

Redefine Lisp Mode's indentation function.
#+BEGIN_SRC emacs-lisp
(defun lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.

INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.

If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:

-`defun', meaning indent `defun'-style
  \(this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);

- an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;

- a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.

This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))
#+END_SRC

*** Aggressive Indent
Aggressive Indent provides a minor mode to re-indent code after every change.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :ghook
  (lisp-major-mode-hooks #'aggressive-indent-mode))
#+END_SRC

*** Character Matching
**** Smartparens

***** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref smartparens/config
:END:

Lisps use the single quote (='=) for quoting, where it is not paired with a closing character.
#+BEGIN_SRC emacs-lisp
(sp-local-pair lisp-major-modes "'" nil :actions nil)
#+END_SRC

**** Evil Cleverparens
Author Llli Pieponnen (luxbock)'s describes Evil Cleverparens as providing an "Evil normal-state minor-mode for editing lisp-like languages".

#+BEGIN_SRC emacs-lisp
(use-package evil-cleverparens
  ;; Delay loading this package until after the following packages.
  :after
  (:all evil smartparens)

  ;; Inform the byte compiler of the following functions.
  :functions evil-move-beyond-eol

  ;; Add the following autoloading hooks.
  :ghook
  <<evil-cleverparens/ghook>>

  ;; Add the following non-autoloading hooks.
  :gfhook
  <<evil-cleverparens/gfhook>>

  :config
  <<evil-cleverparens/config>>)
#+END_SRC

***** Autoloading Hooks
:PROPERTIES:
:DESCRIPTION: Add auto-loading hooks related to Evil Cleverparens.
:HEADER-ARGS+: :noweb-ref evil-cleverparens/ghook
:END:

Enable ~evil-cleverparens-mode~ for Lisps.
#+BEGIN_SRC emacs-lisp
(lisp-major-mode-hooks #'evil-cleverparens-mode)
#+END_SRC

***** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-cleverparens/gfhook
:END:

Let the cursor move past the end of lines in Lisp source code.
#+BEGIN_SRC emacs-lisp
(lisp-major-mode-hooks #'evil-move-beyond-eol)
#+END_SRC

***** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-cleverparens/config
:END:

#+BEGIN_SRC emacs-lisp
(defun evil-move-beyond-eol ()
  "Allow the cursor to move beyond the end of the line."
  (setq evil-move-beyond-eol t))
#+END_SRC

*** Lisp-1

Lisp-1 languages have a single namespace for all names.

**** Geiser Guile

#+BEGIN_SRC emacs-lisp
(use-package geiser-guile
  :if (executable-find "guile")

  :straight nil

  :config
  (when-let ((path (expand-file-name
                    "org.gnu.savannah.git/guix"
                    (xdg-user-dir "SOURCE")))
             ((file-directory-p path)))
    (add-to-list 'geiser-guile-load-path path)))
#+END_SRC

**** Guix

From the package's commentary:
#+BEGIN_QUOTE
Emacs-Guix (aka "guix.el") provides featureful visual interface for the GNU Guix package manager.
It allows you:
- to search for packages and to look at their code (package recipes);
- to manage your Guix profile(s) by installing/removing packages;
- to look at, compare and remove profile generations;
- to look at system services and generations (if you use [Guix System]);
- to do many other things.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package guix
  ;; Load this package if the following code evaluates to non-nil.
  :if
  <<guix/if>>

  ;; Add the following auto-loading hooks.
  :ghook
  <<guix/ghook>>

  ;; Evaluate the following code after loading this package.
  :custom
  (guix-load-path
   (when-let ((path (expand-file-name
                     "org.gnu.savannah.git/guix/"
                     (or (getenv "XDG_SOURCE_DIR") "~/source")))
              ((file-directory-p path)))
     path)
   "Directory or directories to prepend to Guile's `%load-path' and `load-compiled-path'."))
#+END_SRC

***** Conditions for Loading
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref guix/if
:END:

The package relies on =guix= being available on =$PATH=.
#+BEGIN_SRC emacs-lisp
(executable-find "guix")
#+END_SRC

***** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref guix/ghook
:END:

Replace hash symbols with ellipses.
#+BEGIN_SRC emacs-lisp
('(dired-mode-hook shell-mode-hook) #'guix-prettify-mode)
#+END_SRC

**** Racket

#+BEGIN_SRC emacs-lisp
(use-package racket-mode)
#+END_SRC

**** Hy Mode

#+BEGIN_SRC emacs-lisp
(use-package hy-mode
  :mode
  ("\\.hy\\'" . hy-mode)

  :general
  (:keymaps 'hy-mode-map
   "C-c C-c" #'hy-shell-eval-buffer))
#+END_SRC

*** Lisp-2
Lisp-2 languages have a separate namespace for functions.

**** Superior Lisp Interaction Mode (SLIME)

#+BEGIN_SRC emacs-lisp
(use-package slime
  :init
  (defvar init-prog-lisp/slime-extra
    '(slime-indentation slime-fancy)
    "The contrib packages for SLIME to load")

  :config
  (setq slime-lisp-implementations
        '((sbcl ("sbcl" "--noinform"))))
  (slime-setup init-prog-lisp/slime-extra))
#+END_SRC

**** Emacs Lisp

***** /Elisp Mode/

#+BEGIN_SRC emacs-lisp
(use-package elisp-mode
  :straight (:type built-in)

  ;; Add the following keybindings.
  :general
  ("C-x C-e" #'elisp-eval-last-sexp)
  (:keymaps 'emacs-lisp-mode-map
   "C-c C-c" #'eval-buffer)

  :commands elisp-eval-last-sexp

  :config
  <<elisp-mode/config>>)
#+END_SRC

****** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref elisp-mode/config
:END:

Define a custom \src_emacs-lisp{eval-buffer}-like function that, when passed a prefix argument, replaces the expression being evaluated with the result of its evaluation.
#+BEGIN_SRC emacs-lisp
(defun elisp-eval-last-sexp (&optional replace)
  "Evaluate the preceding sexp, OPTIONally replacing it with its result."
  (interactive "P")
  (if (not replace)
      (eval-last-sexp replace)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0))))))
#+END_SRC

***** Helpful

From the package's README:
#+BEGIN_QUOTE
Helpful is an alternative to the built-in Emacs help that provides much more contextual information.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :general
  ("C-h c" #'helpful-command
   "C-h f" #'helpful-callable
   "C-h v" #'helpful-variable)

  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable))
#+END_SRC

**** Clojure

***** Clojure Mode

#+BEGIN_SRC emacs-lisp
(use-package clojure-mode)
#+END_SRC

***** Clojure Refactor

#+BEGIN_SRC emacs-lisp
(use-package clj-refactor
  :ghook
  ('clojure-mode-hook #'clj-refactor-mode)

  :gfhook
  ('clojure-mode-hook #'yas-minor-mode)

  :config
  (cljr-add-keybindings-with-prefix "C-c C-m"))
#+END_SRC

***** CIDER

#+BEGIN_SRC emacs-lisp
(use-package cider

  :commands
  cider-jack-in

  :general
  (:keymaps 'cider-repl-mode-map
   [remap current-buffer/kill] #'cider-quit
   "C-x C-k" #'cider-quit))
#+END_SRC

***** CIDER Hydra

#+BEGIN_SRC emacs-lisp
(use-package cider-hydra
  :ghook
  ('clojure-mode-hook #'cider-hydra-mode))
#+END_SRC

** UNIX Shell
*** Sh Script

#+BEGIN_SRC emacs-lisp
(use-package sh-script
  ;; Evaluate the following code before everything except `:disabled'.
  :preface
  <<sh-script/preface>>

  ;; Add the following non-autoloading hooks.
  :gfhook
  ('shell-script-mode #'sh-script-set-shell-type)

  ;; Inform the bytecode compiler of the following functions.
  :functions sh-script-set-shell-type

  ;; Evaluate the following code after loading `shell-script-mode'.
  :config
  <<sh-script/config>>)
#+END_SRC

*** Pre-Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref sh-script/preface
:END:

Describe a regexp that matches Zsh dotfile filenames.

#+BEGIN_SRC emacs-lisp
(defconst sh-script--zsh-dotfile-regexp
  (rx "/.z"
      (one-or-more (not (any ".")))
      string-end)
  "Regular expression matching Zsh dotfile filenames.")
#+END_SRC

Describe a regexp that matches Zsh script filenames.

#+BEGIN_SRC emacs-lisp
(defconst sh-script--zsh-script-regexp
  (rx ".zsh" string-end)
  "Regular expression matching Zsh script filenames.")
#+END_SRC

Define a list of regexps that match Zsh dotfiles and script filenames.

#+BEGIN_SRC emacs-lisp
(defconst sh-script--zsh-regexps
  '(sh-script--zsh-dotfile-regexp
    sh-script--zsh-script-regexp)
  "A list of regexps describing known Zsh filenames.")
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref sh-script/config
:END:

**** Set Shell Type

Define a function that sets the shell type to Zsh when working with a Zsh file.

#+BEGIN_SRC emacs-lisp
(defun sh-script-set-shell-type ()
  "Set the shell type based on variable `buffer-file-name'."
  ;; Loop over the list of Zsh filenames.
  (dolist (regexp sh-script--zsh-regexps)
    ;; If the regexp matches the name of the file the buffer is visiting...
    (when (string-match regexp buffer-file-name)
      ;; Then set the shell type to Zsh.
      (sh-set-shell "zsh"))))
#+END_SRC

** Python

*** /Python/

#+BEGIN_SRC emacs-lisp
(use-package python
  :straight (:type built-in)

  ;; Inform the bytecode compiler of the following functions.
  :functions python-set-comment-inline-offset

  ;; Add the following non-autoloading hooks.
  :gfhook
  <<python/gfhook>>

  ;; Evaluate the following code after loading `python'.
  :config
  <<python/config>>)
#+END_SRC

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref python/gfhook
:END:

#+BEGIN_SRC emacs-lisp
('python-mode-hook #'python-set-comment-inline-offset)
#+END_SRC

#+begin_src emacs-lisp
('python-mode-hook #'smart-dash-mode)
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref python/config
:END:

Precede inline (i.e. end-of-line) comments with two spaces, per PEP 8.
#+BEGIN_SRC emacs-lisp
(defun python-set-comment-inline-offset ()
  (set (make-local-variable 'comment-inline-offset) 2)
  (setq comment-column 0))
#+END_SRC

**** Polymode
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref polymode/config
:END:

Use \src_emacs-lisp{python-mode} as primary (host) mode for Python buffers.
#+BEGIN_SRC emacs-lisp
(define-hostmode poly-python-hostmode
  :mode 'python-mode)
#+END_SRC

***** reStructuredText for Doctstrings
:PROPERTIES:
:DESCRIPTION: Use \src_emacs-lisp{rst-mode} for Python's docstrings.
:END:

#+BEGIN_SRC emacs-lisp
(defun poly-python-docstring-head (count)
  "Search for in direction specified by COUNT for Python docstring."
  (when (re-search-forward
         (rx line-start
             (zero-or-more blank) (group (= 3 "\""))
             (minimal-match (zero-or-more anything)) (group (= 3 "\""))
             (| line-end
                (sequence (zero-or-more blank) "#" (zero-or-more not-newline) line-end)))
         nil t count)
    (cons (match-beginning 1) (match-end 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun poly-python-docstring-tail (count)
  (cons (match-beginning 2) (match-end 2)))
#+END_SRC

Define the secondary (inner) mode.
The delimiters are Python's plain (i.e. non-raw) multi-line string delimiters: three consecutive double quotes.
#+BEGIN_SRC emacs-lisp
(define-innermode poly-rst-python-innermode
  :mode 'rst-mode
  :head-matcher #'poly-python-docstring-head
  :tail-matcher #'poly-python-docstring-tail
  :head-mode 'host
  :tail-mode 'host)
#+END_SRC

Define the actual Polymode.
#+BEGIN_SRC emacs-lisp
(define-polymode poly-python-rst-mode
  :hostmode 'poly-python-hostmode
  :innermodes '(poly-rst-python-innermode))
#+END_SRC

Use the above Polymode as the default mode for Python buffers.
#+BEGIN_SRC emacs-lisp :noweb-ref polymode/mode
("\\.py\\'" . poly-python-rst-mode)
#+END_SRC

*** Pyvenv

#+BEGIN_SRC emacs-lisp
(use-package pyvenv
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following after loading this package.
  :config
  <<pyvenv/config>>)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref pyvenv/config
:END:

Enable \src_emacs-lisp{pyvenv-mode} globally.
#+BEGIN_SRC emacs-lisp
(pyvenv-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun pyvenv-lafrenierejm-create-virtualenv (version)
  "Create a virtual environment using Python VERSION."
  (interactive "MVirtual environment base: ")
  (let* ((git-url (magit-git-string "remote" "get-url" "origin"))
         (git-urlobj (url-generic-parse-url git-url)))
    (let ((dns-name (->> (s-split (rx ".") (url-host git-urlobj) t)
                         (seq-reverse)
                         (s-join ".")))
          (repo-path (-as-> (url-filename git-urlobj) var
                            (s-replace-regexp (rx ".git" string-end) "" var)
                            (s-split (rx "/") var t)
                            (s-join "." var))))
      (let ((venv-name (s-join "." (list dns-name repo-path version))))
        (shell-command (format "pyenv virtualenv %s %s"
                               version
                               venv-name))
        (add-dir-local-variable
         nil
         'pyvenv-activate
         (f-join (getenv "HOME")
                 ".pyenv/versions/"
                 venv-name))))))
#+END_SRC

*** Blacken

#+BEGIN_SRC emacs-lisp
(use-package blacken
  ;; Load this package after the following packages.
  :after python

  ;; Load this package eagerly.
  :demand)
#+END_SRC

*** YAPFify

#+BEGIN_SRC emacs-lisp
(use-package yapfify
  ;; Load this package after the following packages.
  :after python

  ;; Load this package eagerly.
  :demand)
#+END_SRC

*** Isort

isort is a utility for sorting Python imports.

The /[[Reformatter]]/ package is used to create an Emacs formatter using isort's command-line interface.
#+BEGIN_SRC emacs-lisp :noweb-ref reformatter/config
(reformatter-define
 isort-format
 :program "isort"
 :args '("--atomic" "-"))
#+END_SRC

The defined hook can be added to all Python files.
#+BEGIN_SRC emacs-lisp :noweb-ref reformatter/ghook
('python-mode-hook #'isort-format-on-save-mode)
#+END_SRC

** Groovy

*** Groovy Mode

#+BEGIN_SRC emacs-lisp
(use-package groovy-mode
  :mode (("\\.gdsl\\'" . groovy-mode))

  :general
  (:keymaps 'groovy-mode-map
   "C-c C-p" #'run-groovy))
#+END_SRC

*** Polymode

**** Auto-Mode Alist

#+BEGIN_SRC emacs-lisp :noweb-ref polymode/mode
("\\(\\.g\\(?:ant\\|roovy\\|radle\\)\\'\\)|Jenkinsfile" . poly-groovy-mode)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref polymode/config
:END:

***** Sh Inner Mode
:PROPERTIES:
:DESCRIPTION: Use ~sh-mode~ for Groovey's ~sh~ strings.
:END:

#+BEGIN_SRC emacs-lisp
(defun poly-groovy-sh-head (count)
  "Search in direction specified by COUNT for sh commands."
  (when (re-search-forward
         (rx (seq line-start (zero-or-more blank) "sh "
                  (group (seq (or (= 3 "\"") (= 3 "'")) (optional "\\\n")))
                  (minimal-match (zero-or-more anything))
                  (group (or (= 3 "\"") (= 3 "'")))))
         nil t count)
    (cons (match-beginning 1) (match-end 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun poly-groovy-sh-tail (count)
  "Use match from `poly-groovy-sh-head' to determine end of sh command."
  (cons (match-beginning 2) (match-end 2)))
#+END_SRC

Define the secondary (inner) mode.
The delimiters are Groovy's multi-line string delimiters:
- three consecutive double quotes (") or
- three consecutive single quotes (').
#+BEGIN_SRC emacs-lisp
(define-innermode poly-groovy-innermode
  :mode 'sh-mode
  :head-matcher #'poly-groovy-sh-head
  :tail-matcher #'poly-groovy-sh-tail
  :head-mode 'host
  :tail-mode 'host)
#+END_SRC

***** Groovy Host Mode
Define the primary (host) mode for Groovy files.
#+BEGIN_SRC emacs-lisp
(define-hostmode poly-groovy-hostmode
  :mode 'groovy-mode)
#+END_SRC

Define the actual Polymode.
#+BEGIN_SRC emacs-lisp
(define-polymode poly-groovy-mode
  :hostmode 'poly-groovy-hostmode
  :innermodes '(poly-groovy-innermode))
#+END_SRC

** Structured Query Language (SQL)

*** SQL

#+BEGIN_SRC emacs-lisp
(use-package sql
  :straight (:type built-in)

  :demand

  :commands
  (init-sql/enable-truncate-lines)

  :gfhook
  <<sql/gfhook>>

  :config
  <<sql/config>>)
#+END_SRC

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref sql/gfhook
:END:

Restrict each line of text to a single screen line.
#+BEGIN_SRC emacs-lisp
('(sql-mode-hook sql-interactive-mode-hook) #'sql-truncate-lines)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref sql/config
:END:

Define a function to restrict each line of text to a single screen line.
#+BEGIN_SRC emacs-lisp
(defun sql-lafrenierejm-truncate-lines ()
  "Restrict each line of text to a single visual line."
  (setq truncate-lines t))
#+END_SRC

Alias the above function to remove my username.
My username is used above just to demarcate the function as a custom one.
#+BEGIN_SRC emacs-lisp
(defalias 'sql-truncate-lines #'sql-lafrenierejm-truncate-lines)
#+END_SRC

*** SQL Up Mode

By convention, SQL uses all uppercase characters for the names of keywords and built-in functions.
/SQL Up Mode/ provides a minor mode that will automatically "upcase" known keywords and function names.

#+BEGIN_SRC emacs-lisp
(use-package sqlup-mode
  ;; Add the following auto-loading hooks.
  :ghook
  ('(sql-interactive-mode sql-mode) #'sqlup-mode))
#+END_SRC


* Refactoring

** Reformatter

#+BEGIN_SRC emacs-lisp
(use-package reformatter
  ;; Add the following auto-loading hooks.
  :ghook
  <<reformatter/ghook>>

  ;; Inform the bytecode compiler of the following non-autoloaded functions.
  :functions reformatter-define

  ;; Evaluate the following code after this package has been loaded.
  :config
  <<reformatter/config>>)
#+END_SRC

* RESTful APIs
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref restful-apis
:END:

** REST Client

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :preface
  (defconst init-web/http-extension
    (rx ".http" string-end)
    "The filename extension \".http\".")

  :mode
  ("\\.http\\'" . restclient-mode))
#+END_SRC

** Company REST Client

#+BEGIN_SRC emacs-lisp
(use-package company-restclient
  :after (:all company restclient)

  :demand

  :config
  (add-to-list 'company-backends 'company-restclient))
#+END_SRC

** Polymode for REST Client

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref polymode/config
:END:

**** Emacs Lisp Inner Mode
Define the inner mode for Emacs Lisp sections of REST Client buffers.

#+BEGIN_SRC emacs-lisp
(define-innermode poly-restclient/emacs-lisp-innermode
  :mode 'emacs-lisp-mode
  :head-mode 'host
  :tail-mode 'host)
#+END_SRC

Define a matcher for single-line expressions.
#+BEGIN_SRC emacs-lisp
(define-innermode poly-restclient/emacs-lisp/single-line-innermode poly-restclient/emacs-lisp-innermode
  :head-matcher (rx line-start ":" (one-or-more (not (any " "))) " :=")
  :tail-matcher (rx "\n"))
#+END_SRC

Define a matcher for multi-line expressions.
#+BEGIN_SRC emacs-lisp
(define-innermode poly-restclient/emacs-lisp/multi-line-innermode poly-restclient/emacs-lisp-innermode
  :head-matcher (rx line-start ":" (one-or-more (not (any " "))) " := <<\n")
  :tail-matcher (rx line-start "#\n"))
#+END_SRC

**** JSON Inner Mode
Define the inner mode for JSON sections.

#+BEGIN_SRC emacs-lisp
(define-innermode poly-restclient/json-innermode
  :mode 'json-mode
  :head-mode 'body
  :tail-mode 'body
  :head-matcher (rx line-start "{" line-end)
  :tail-matcher (rx line-start "}" line-end))
#+END_SRC

**** Rest Client Parent Mode
#+BEGIN_SRC emacs-lisp
(define-hostmode poly-restclient-hostmode
  :mode 'restclient-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-polymode poly-restclient-mode
  :hostmode 'poly-restclient-hostmode
  :innermodes '(poly-restclient/emacs-lisp/single-line-innermode
                poly-restclient/emacs-lisp/multi-line-innermode
                poly-restclient/json-innermode))
#+END_SRC

* Project Management
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref project-management
:END:

** Jira

I often want to link directly to a Jira ticket from an Org buffer.
The following functions allow me to do so.

#+BEGIN_SRC emacs-lisp
(defcustom jira-hostname nil
  "The hostname of the Jira server.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jira-lafrenierejm-url-of-ticket (name)
  "Return a Jira ticket's url given the ticket's NAME or &OPTION region from BEG to END."
  (interactive "MTicket: ")
  (format "https://%s/browse/%s" jira-hostname name))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defalias 'jira-url-of-ticket #'jira-lafrenierejm-url-of-ticket)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jira-lafrenierejm-org-link-ticket (name &optional beg end)
  "Create an Org link to the ticket NAME or &OPTION contained in region from BEG to END."
  (interactive
   (if (use-region-p)
       (list nil (region-beginning) (region-end))
     (list (read-string "Ticket: ") nil nil)))
  (let* ((name (or name
                   (buffer-substring-no-properties beg end)))
         (url (jira-url-of-ticket name)))
    (when (and beg end)
      (save-excursion
        (delete-region beg end)
        (goto-char beg)))
    (insert (format "[[%s][%s]]" url name))
    url))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defalias 'jira-org-link-ticket #'jira-lafrenierejm-org-link-ticket)
#+END_SRC

* Windows and Frames
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref windows-and-frames
:END:

** Minions
#+BEGIN_QUOTE
A minor-mode menu for the mode line.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package minions
  ;; Load this package eagerly.
  :demand

  ;; Apply the following variable customizations.
  :custom
  (minions-mode-line-lighter "…")
  (minions-mode t "Enable `minions-mode' globally."))
#+END_SRC

** EXWM
From the package's README:
#+BEGIN_QUOTE
EXWM (Emacs X Window Manager) is a full-featured tiling X window manager for Emacs built on top of XELB.
It features:

- Fully keyboard-driven operations
- Hybrid layout modes (tiling & stacking)
- Dynamic workspace support
- ICCCM/EWMH compliance
- (Optional) RandR (multi-monitor) support
- (Optional) Built-in system tray
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package exwm
  ;; Do not load the package lazily.
  :demand

  ;; Inform the bytecode compiler of the following functions.
  :commands
  (init-window-and-frame/start-process)

  ;; Customize the following variables.
  :custom
  <<exwm/custom>>

  ;; Add the following function hooks.
  :gfhook
  <<exwm/gfhook>>

  ;; Execute the following code after the package has been loaded.
  :config
  <<exwm/config>>)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref exwm/custom
:END:

Only enable a single workspace.
Buffer switching with e.g. Counsel is preferred to using multiple workspaces.

#+BEGIN_SRC emacs-lisp
(exwm-workspace-number 1)
#+END_SRC

*** Non-Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref exwm/gfhook
:END:

Use Firefox windows' names as the windows' buffers names.

#+BEGIN_SRC emacs-lisp
('exwm-update-title-hook
 (defun init-window-and-frame/update-title ()
   "Use Firefox windows' names as the windows' buffers names."
   (when (or (string-match "Icecat" exwm-class-name)
             (string-match "Next" exwm-class-name))
     (exwm-workspace-rename-buffer exwm-title))))
   #+END_SRC

Add simulation keys for Firefox windows.

#+BEGIN_SRC emacs-lisp
('exwm-manage-finish-hook
 (defun init-window-and-frame/set-firefox-simulation-keys ()
   (when (and exwm-class-name (string= exwm-class-name "Icecat"))
     (exwm-input-set-local-simulation-keys
      '(([?\C-s] . [?\C-f])
        ([?\C-q] . [?\C-w])
        ([?\C-t] . [?\C-n]))))))
   #+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref exwm/config
:END:

Define a function to launch applications from the shell.
Launching applications is performed by calling ~start-process-shell-command~.

#+BEGIN_SRC emacs-lisp
(defun init-window-and-frame/start-process (command)
  "Start a process via a shell COMMAND."
  (interactive (list (read-shell-command "$ ")))
  (start-process-shell-command command nil command))
#+END_SRC

**** Keybindings
Effective use of EXWM requires the ability to return from ~char-mode~ to ~line-mode~.
This will be performed with =s-r=.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-r") #'exwm-reset)
#+END_SRC

Hide all windows except the current one.
#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-o") #'delete-other-windows)
#+END_SRC

Close the current window and kill its buffer.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "C-s-x") #'kill-buffer-and-window)
#+END_SRC

Close the current window without killing its buffer.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-x") #'delete-window)
#+END_SRC

Run a shell command.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "<s-return>") #'init-window-and-frame/start-process)
#+END_SRC

Open an Eshell buffer in the current buffer's location.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "C-z") #'eshell-find-eshell-here)
#+END_SRC

Move =point= to the windows immediately around the current window.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-h") #'windmove-left)
(exwm-input-set-key (kbd "s-j") #'windmove-down)
(exwm-input-set-key (kbd "s-k") #'windmove-up)
(exwm-input-set-key (kbd "s-l") #'windmove-right)
#+END_SRC

** Ace Window
From the README of Oleh Krehel (abo-abo)'s Ace Window package:
#+BEGIN_QUOTE
This package aims to take the speed and predictability of ~windmove~ and pack it into a single key binding, similar to ~other-window~.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  ("s-a" #'ace-window)

  ;; Apply the following customizations.
  :custom
  <<ace-window/custom>>

  ;; Evaluate the following code before loading this package.
  :init
  <<ace-window/init>>)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ace-window/custom
:END:

Use home row characters to label windows.

#+BEGIN_SRC emacs-lisp
(aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
#+END_SRC

Issue a read-char even for one window.
This allows more flexibility in what action is performed, i.e. more than just changing focus, at the cost of requiring more keystrokes for the single most common task of changing focus.

#+BEGIN_SRC emacs-lisp
(aw-dispatch-always t)
#+END_SRC

Show the ace window key in the mode line.
This is useful for EXWM buffers which cannot display keys in the buffer itself.

#+BEGIN_SRC emacs-lisp
(ace-window-display-mode t)
#+END_SRC

*** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ace-window/init
:END:

Bind Ace Window to =s-a= in EXWM.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'exwm
  (exwm-input-set-key (kbd "s-a") #'ace-window))
#+END_SRC

** Window

Add top-level =super= bindings to window management functions.
This allows the keys to be useful whenever the =s= modifier is made available to Emacs.
#+BEGIN_SRC emacs-lisp :noweb-ref general/config
(general-define-key
 "s-o" #'delete-other-windows
 "s-h" #'windmove-left
 "s-j" #'windmove-down
 "s-k" #'windmove-up
 "s-l" #'windmove-right)
#+END_SRC

** Desktop Environment

#+BEGIN_SRC emacs-lisp
(use-package desktop-environment
  :if (eq system-type 'gnu/linux)

  :general
  ("<XF86MonBrightnessUp>" #'desktop-environment-brightness-increment
   "<XF86MonBrightnessDown>" #'desktop-environment-brightness-decrement
   "<XF86AudioRaiseVolume>" #'desktop-environment-volume-increment
   "<XF86AudioLowerVolume>" #'desktop-environment-volume-decrement
   "<XF86AudioMute>" #'desktop-environment-toggle-mute
   "<XF86AudioMicMute>" #'desktop-environment-toggle-microphone-mute
   "S-<print>" #'desktop-environment-screenshot-part
   "<print>" #'desktop-environment-screenshot
   "C-s-l" #'desktop-environment-lock-screen
   "<XF86WLAN>" #'desktop-environment-toggle-wifi
   "<XF86Bluetooth>" #'desktop-environment-toggle-bluetooth))
#+END_SRC

* Secret Management
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref secret-management
:END:

** Password Cache

#+BEGIN_SRC emacs-lisp
(use-package password-cache
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Apply the following customizations.
  :custom
  (password-cache-expiry nil "Do not expire cached passwords."))
#+END_SRC

** Auth Source Pass

Damien Cassou (DameinCassou)'s [[https://github.com/DamienCassou/auth-password-store][auth-source-pass]] package integrates Jason A. Donenfield (ZX2C4)'s [[https://www.passwordstore.org/][pass]] utility into Emacs's authentication mechanisms.

#+BEGIN_SRC emacs-lisp
(use-package auth-source-pass
  ;; Only load this package if the following code evaluates to non-nil.
  :if
  <<auth-source-pass/if>>

  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<auth-source-pass/config>>)
#+END_SRC

*** Conditional Loading
:PROPERTIES:
:DESCRIPTION: Only load ~auth-source-pass~ if this condition is met.
:HEADER-ARGS+: :noweb-ref auth-source-pass/if
:END:

~auth-source-pass~ is only usable if =pass= is available in the user's =$PATH=.

#+BEGIN_SRC emacs-lisp
(executable-find "pass")
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to evaluate after the parent package has been loaded
:HEADER-ARGS+: :noweb-ref auth-source-pass/config
:END:

Enable auth-source-password-store.

#+BEGIN_SRC emacs-lisp
(auth-source-pass-enable)
#+END_SRC

** Password Store

#+BEGIN_SRC emacs-lisp
(use-package password-store
  ;; Only load `password-store' if the following condition is met.
  :if
  <<password-store/if>>

  ;; Load `password-store' eagerly.
  :demand

  :custom
  (password-store-password-length 32 "Default password length"))
#+END_SRC

*** Conditional Loading (~:if~)
:PROPERTIES:
:DESCRIPTION: Only load ~password-store~ if the following code evaluates to non-~nil~.
:HEADER-ARGS+: :noweb-ref password-store/if
:END:

~password-store~ is only usable if =pass= is on the user's =$PATH=.

#+BEGIN_SRC emacs-lisp
(executable-find "pass")
#+END_SRC

** Ivy Pass

Ivy Pass is an Ivy interface for Password Store.

#+BEGIN_SRC emacs-lisp
(use-package ivy-pass
  ;; Only load this package if the evaluation of the following code is non-nil.
  :if
  <<password-store/if>>

  ;; Load this package after the following packages.
  :after (:all  ivy password-store)

  ;; Add the following key bindings.
  :general
  ("C-x p" #'ivy-pass))
#+END_SRC

** EasyPG Assistant (EPA)

#+BEGIN_SRC emacs-lisp
(use-package epa
  :straight (:type built-in)

  ;; Apply the following customizations.
  :custom
  <<epa/custom>>)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS: :noweb-ref epa/custom
:END:

#+BEGIN_SRC emacs-lisp
(epa-pinentry-mode 'loopback "Redirect all Pinentry queries to Emacs.")
#+END_SRC

* Footnotes

[fn:1] ~:ghook~ is one of the keywords added to \src_emacs-lisp{use-package} by /General/.
