#+TITLE: Emacs Configuration
#+AUTHOR: Joseph LaFreniere (lafrenierejm)
#+EMAIL: joseph@lafreniere.xyz
#+PROPERTY: header-args+ :noweb yes

#+begin_src emacs-lisp :tangle yes
;;; init.el --- Configure Emacs  -*- lexical-binding: t; -*-

;; Copyright (C) 2018 Joseph LaFreniere

;; Author: Joseph LaFreniere <joseph@lafreniere.xyz>
;; Version 0.1

;; <<license>>

;;; Commentary:
;; <<commentary>>

;;; Code:
<<bootstrapping>>

;;; Dependencies:
<<dependencies>>

;;; Constants
<<constants>>

;;; Customization:
<<customization>>

;;; Visual Interface:
<<interface>>

;;; Working with Documentation:
<<documentation>>

;;; Buffer Organization:
<<buffer-organization>>

;;; Keybindings:
<<keybindings>>

;;; Minibuffer:
<<minibuffer>>

;;; TRAMP:
<<tramp>>

;;; Version Control:
<<version-control>>

;;; Completion
<<completion>>

;;; System:
<<system>>

;;; Diff:
<<diff>>

;;; Directories:
<<directories>>

;;; Command Interpretation:
<<command-interpretation>>

;;; Static Analysis:
<<static-analysis>>

;;; Feeds:
<<feeds>>

;;; Multimedia:
<<multimedia>>

;;; Programming:
<<programming>>

;;; Refactoring:
<<refactoring>>

;;; Web:
<<web>>

;;; Project Management:
<<project-management>>

;;; Windows and Frames
<<windows-and-frames>>

;;; Secret Management:
<<secret-management>>

(provide 'init)
;;; init.el ends here
#+end_src

* License
** Code
All source code in this file is licensed under the [[http://www.gnu.org/licenses/gpl-3.0.html][GNU Public License v3]] or later.
#+begin_src text :noweb-ref license
This file is not part of GNU Emacs.

Init is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

Init is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with GNU Emacs.
If not, see <https://www.gnu.org/licenses/>.
#+end_src

** Prose

All prose in this file is licensed under the [[http://www.gnu.org/licenses/fdl-1.3.html][GNU Free Documentation License (FDL) v1.3]].
#+begin_src text
Copyright (C) 2019 Joseph LaFreniere.
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
#+end_src

* Commentary
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref commentary
:END:

#+begin_src text
This is tangled source of Joseph LaFreniere (lafrenierejm)'s literate Emacs initialization file.
Please refer to `init.org' in this same directory for full commentary.
#+end_src

* Bootstrapping
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref bootstrapping
:END:

GNU Emacs does not have the capability to use an Org file directly as its initialization file.
As such, this file needs to be tangled manually for its first use on a new system.
The following code ensures that this step is only needed once.

** Package Management

#+begin_src emacs-lisp
(cond
 ((executable-find "guix")
  <<bootstrapping/guix-nix>>
  <<bootstrapping/guix-nix/use-package>>)
 (t
  <<bootstrapping/straight>>
  <<bootstrapping/straight/use-package>>))
(setq use-package-always-defer t)
#+end_src

*** Guix or Nix
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref bootstrapping/guix-nix
:END:

Emacs packages can be managed as any other package with Guix or Nix.
As such, Emacs's native package management tools can be used but its default archives should be ignored.
Before any other installed packages can be configured, /Package/ must be loaded and initialized.
#+begin_src emacs-lisp
(require 'package)
(setq package-archives nil)
(setq package-enable-at-startup nil)
(package-initialize)
#+end_src

**** /Use Package/
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref bootstrapping/guix-nix/use-package
:END:

Because I use /Straight/ to manage packages on systems where neither Gix nor Nix are available, I need to account for instances where I use the ~:straight~ keyword in \src_emacs-lisp{use-package} macros.
This is accomplished by requesting \src_emacs-lisp{use-package} to just ignore any unkown keywords rather than raise errors.
#+begin_src emacs-lisp
(require 'use-package)
(setq use-package-ignore-unknown-keywords t)
#+end_src

*** Straight
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref bootstrapping/straight
:END:

Specify the branch to download /Straight/ from.
#+begin_src emacs-lisp
(setq straight-repository-branch "develop")
#+end_src

Download and load /Straight/.
#+begin_src emacs-lisp
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         (format
          "https://raw.githubusercontent.com/raxod502/straight.el/%s/install.el"
          straight-repository-branch)
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

**** /Use Package/
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref bootstrapping/straight/use-package
:END:

Download /Use Package/.
#+begin_src emacs-lisp
(straight-use-package 'use-package)
#+end_src

Configure /Use Package/ to download packages with /Straight/ by default.
#+begin_src emacs-lisp
(setq straight-use-package-by-default t)
#+end_src

And finally load /Use Package/.
#+begin_src emacs-lisp
(require 'use-package)
#+end_src

** Org
:PROPERTIES:
:CUSTOM_ID: bootstrap/org
:END:

After /Use Package/ has been loaded, we can use it to configure all other packages.
Tangling this Org file for use as Emacs's initialization file requires features from the /Org/ package.
As such, the below function is specified to belong to the =:config= section of /Org/'s \src_emacs-lisp{use-package} declaration.
The process of tangling this file is to
1. Compare the modification time of this file to its tangled source, =./init.el=.
2. If this file is the more recent of the two, tangle this file then byte compile and load the result.
3. Otherwise the tangled file is the more recent, so byte compile and load it directly.

#+begin_src emacs-lisp :noweb-ref org/config
(defun org-babel-tangle-init ()
  "Tangle Emacs's init file."
  (let ((el-file user-init-file)
        (org-file "~/.config/emacs/init.org")
        (load-byte-compile t))
    (if (not (file-exists-p el-file))
        ;; If the Emacs Lisp file does not exist, tangle the Org file.
        (org-babel-tangle-file org-file)
      ;; If the Emacs Lisp file does exist, compare the modification times.
      (let* ((org-modify (modify-time org-file))
             (el-modify (modify-time el-file)))
        ;; If the Org file was modified more recently, tangle it.
        (when (< el-modify org-modify)
          (org-babel-tangle-file org-file))))))
#+end_src

#+begin_src emacs-lisp :noweb-ref org/config
(defun modify-time (file)
  (-> (file-attributes file)
      (file-attribute-modification-time)
      (float-time)))
#+end_src

** General
/General/ provides convenience wrappers for setting keybindings and adding hooks.
It is highly compatible with /Use Package/ and provides additional keywords to the \src_emacs-lisp{use-package} macro.
/General/ is loaded now just so it can be used in all further \src_emacs-lisp{use-package} declarations.
The ~:demand~ keyword is used to ensure General is loaded eagerly.
#+begin_src emacs-lisp
(use-package general
  :demand

  :config
  <<general/config>>)
#+end_src

** Environment Variables

*** /Exec Path From Shell/

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :demand

  :custom
  <<exec-path-from-shell/custom>>

  :config
  (exec-path-from-shell-initialize))
#+end_src

**** Set Variables to Source

#+begin_src emacs-lisp :noweb-ref exec-path-from-shell/custom
(exec-path-from-shell-variables
 '("PATH" "MANPATH"                     ; defaults
   ;; Include all XDG environment variables.
   "XDG_CACHE_DIR"
   "XDG_CONFIG_HOME"
   "XDG_DESKTOP_DIR"
   "XDG_DOCUMENTS_DIR"
   "XDG_DOWNLOAD_DIR"
   "XDG_MAIL_DIR"
   "XDG_MUSIC_DIR"
   "XDG_PICTURES_DIR"
   "XDG_PUBLICSHARE_DIR"
   "XDG_RUNTIME_DIR"
   "XDG_SOURCE_DIR"
   "XDG_TEMPLATES_DIR"
   "XDG_VIDEOS_DIR"
   ;; Include Guix-related variables.
   "GUIX_PROFILE"))
#+end_src

* Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref customization
:END:

** /XDG/

The /XDG/ package provides functions for working with XDG standards and specifications.
It is loaded to override \src_emacs-lisp{xdg-line-regexp}.
By default, that variable only allows reading a few of the most common directory types even though the XDG spec allows setting an arbitrary number of directories in =$XDG_CONFIG_DIR/user-dirs.dirs=.

#+begin_src emacs-lisp
(use-package xdg
  :straight (:type built-in)

  :demand

  :config
  (setq xdg-line-regexp
        (rx line-start
            "XDG_" (group (one-or-more upper)) "_DIR="
            "\"" (group (minimal-match (one-or-more anything))) "\""
            line-end)))
#+end_src

** /Standard Dirs/

/Standard Dirs/ provides platform-specific paths for configuration, cache, and other data.
#+begin_src emacs-lisp
(use-package standard-dirs
  :demand)
#+end_src

** /Cus Edit/

Emacs has a customization system distinct from simply \src_emacs-lisp{setq}-ing variables.
By default, any customizations made using that system are appended to the bottom of Emacs's init file.
This is controlled by the value of the \src_emacs-lisp{custom-file} variable.
That variable is provided as part of the Cus Edit package, so we will perform modifications inside the \src_emacs-lisp{use-package} declaration of Cus Edit.

Viewing the help documentation for \src_emacs-lisp{custom-file} (via =C-h v custom-file RET=) tells us
#+BEGIN_QUOTE
The default is nil, which means to use your init file as specified by \src_emacs-lisp{user-init-file}.
If the value is not \src_emacs-lisp{nil}, it should be an absolute file name.

You can set this option through Custom, if you carefully read the last paragraph below.
However, usually it is simpler to write something like the following in your init file:

#+BEGIN_EXAMPLE emacs-lisp
(setq custom-file "~/.emacs-custom.el")
(load custom-file)
#+END_EXAMPLE
#+END_QUOTE

That \src_emacs-lisp{setq} and \src_emacs-lisp{load} need to be evaluated /after/ /Cus Edit/ has been loaded, so the expressions should go in the ~:config~ block of the \src_emacs-lisp{use-package} declaration.
Additionally, \src_emacs-lisp{custom-file} needs to exist before it is loaded.
The file can be created with the function \src_emacs-lisp{f-touch}.

\src_emacs-lisp{f-touch}, in turn, is provided by the package F.
Since we are relying a function from an external package when we're loading Cus Edit, we need to inform \src_emacs-lisp{use-package} of that fact and tell it to load Cus Edit only after F has been loaded.
This is done with the ~:after~ keyword of \src_emacs-lisp{use-package}.

Additionally, we want Cus Edit to always be loaded (not just when we interactively use something it provides).
\src_emacs-lisp{use-package} needs to told to load Cus Edit eagerly (as opposed to lazily), which is accomplished with the ~:demand~ keyword.

#+begin_src emacs-lisp
(use-package cus-edit
  :straight (:type built-in)

  :after (:all f standard-dirs)

  :demand

  :init
  (let ((path (expand-file-name
               "custom.el"
               (standard-dirs-project-data "org" "gnu" "Emacs"))))
    (f-touch path)
    (setq custom-file path)
    (load custom-file)))
#+end_src

/F/ is not built-in to GNU Emacs, so it must be downloaded by some package manager separately.
Further \src_emacs-lisp{f-touch} is not marked as an auto-loaded function in /F/ (this too can be discovered by viewing the function's help), so /F/ must also be loaded eagerly.

#+begin_src emacs-lisp
(use-package f
  :demand)
#+end_src

** /No Littering/

/No Littering/ configures various packages' paths to unify where data is saved.
#+begin_src emacs-lisp
(use-package no-littering
  :demand
  :after standard-dirs
  :init
  (setq
   no-littering-etc-directory (standard-dirs-project-config "org" "gnu" "emacs")
   no-littering-var-directory (standard-dirs-project-data-local "org" "gnu" "emacs")

   ;; Seperate auto-save files.
   auto-save-file-name-transforms
   `((".*"
      ,(let ((path (no-littering-expand-var-file-name "auto-save/")))
         (make-directory path t)
         path)
      t))

   ;; Separate backups
   backup-directory-alist
   (list (cons (rx (seq string-start (zero-or-more anychar) string-end))
               (let ((path (no-littering-expand-var-file-name "backup/")))
                 (make-directory path t)
                 path)))))
#+end_src

* Visual Interface
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref interface
:END:

** /Menu Bar/

The menu bar can be disabled completely.
The macOS-native build of Emacs that I use relies on ~menu-bar-mode~ being enabled, but it uses macOS's global menu bar so it's unobtrusive.
#+begin_src emacs-lisp
(use-package menu-bar
  :straight (:type built-in)
  :demand
  :config
  (unless (eq system-type 'darwin)
    (menu-bar-mode -1)))
#+end_src

** /Scroll Bar/

The scroll bar can be disabled completely.
#+begin_src emacs-lisp
(use-package scroll-bar
  :straight (:type built-in)
  :demand
  :config
  (scroll-bar-mode -1))
#+end_src

** /Tool Bar/

The tool bar can be disabled completely.
#+begin_src emacs-lisp
(use-package tool-bar
  :straight (:type built-in)
  :demand
  :config
  (tool-bar-mode -1))
#+end_src

** /Startup/

The startup message and scratch message add no value, so they are disabled.
#+begin_src emacs-lisp
(setq
 inhibit-startup-screen t
 initial-scratch-message nil)
#+end_src

** Font
What are colloquially known as "fonts" Emacs refers to "faces".
Google's Noto family of has the best glyph coverage that I am aware of, so I try to use it everywhere I can.
Alan Third has a nice write-up in his [[https://idiocy.org/emacs-fonts-and-fontsets.html]["Emacs, fonts and fontsets" post on idiocy.org]] of how to enable Noto fonts everywhere and simultaneously reduce Emacs's need to scour the system for fallback font sets.
The /Faces/ package provides this functionality, so all font setup can can occur within /Faces/'s \src_emacs-lisp{use-package}.

#+begin_src emacs-lisp
(use-package faces
  :straight (:type built-in)

  :demand

  :config
  (when (member "Noto Sans" (font-family-list))
    (set-face-attribute 'default nil :font "Noto Sans Mono")
    (set-fontset-font t 'latin "Noto Sans")

    ;; East Asia: 你好, 早晨, こんにちは, 안녕하세요
    (set-fontset-font t 'han "Noto Sans CJK SC Regular")
    (set-fontset-font t 'kana "Noto Sans CJK JP Regular")
    (set-fontset-font t 'hangul "Noto Sans CJK KR Regular")
    (set-fontset-font t 'cjk-misc "Noto Sans CJK KR Regular")

    ;; South East Asia: ជំរាបសួរ, ສະບາຍດີ, မင်္ဂလာပါ, สวัสดีครับ
    (set-fontset-font t 'khmer "Noto Sans Khmer")
    (set-fontset-font t 'lao "Noto Sans Lao")
    (set-fontset-font t 'burmese "Noto Sans Myanmar")
    (set-fontset-font t 'thai "Noto Sans Thai")

    ;; Africa: ሠላም
    (set-fontset-font t 'ethiopic "Noto Sans Ethiopic")

    ;; Middle/Near East: שלום, السّلام عليكم
    (set-fontset-font t 'hebrew "Noto Sans Hebrew")
    (set-fontset-font t 'arabic "Noto Sans Arabic")

    ;;  South Asia: નમસ્તે, नमस्ते, ನಮಸ್ಕಾರ, നമസ്കാരം, ଶୁଣିବେ,
    ;;              ආයුබෝවන්, வணக்கம், నమస్కారం, བཀྲ་ཤིས་བདེ་ལེགས༎
    (set-fontset-font t 'gujarati "Noto Sans Gujarati")
    (set-fontset-font t 'devanagari "Noto Sans Devanagari")
    (set-fontset-font t 'kannada "Noto Sans Kannada")
    (set-fontset-font t 'malayalam "Noto Sans Malayalam")
    (set-fontset-font t 'oriya "Noto Sans Oriya")
    (set-fontset-font t 'sinhala "Noto Sans Sinhala")
    (set-fontset-font t 'tamil "Noto Sans Tamil")
    (set-fontset-font t 'telugu "Noto Sans Telugu")
    (set-fontset-font t 'tibetan "Noto Sans Tibetan"))
  <<faces/config>>)
#+end_src

When working with prose, I prefer to use a variable-pitch (as opposed to monospace) face.
Frequently, though, some aspects of a mostly-prose document are better presented in monospace.
An example of this is the code blocks in this Org file.

*** Ligatures

Some fonts support ligatures.
#+begin_src emacs-lisp :noweb-ref faces/config
(when (functionp 'mac-auto-operator-composition-mode)
  (mac-auto-operator-composition-mode))
#+end_src

** /Form Feed/

Display ^L glyphs as horizontal lines.
#+begin_src emacs-lisp
(use-package form-feed
  :demand

  :after s

  :config
  (define-globalized-minor-mode form-feed-global-mode form-feed-mode
    (lambda ()
      (unless (s-starts-with? "magit" (symbol-name major-mode))
        (form-feed-mode +1))))

  (form-feed-global-mode +1))
#+end_src

** Rainbow Identifiers
Rainbow Identifiers provides a minor mode that highlights identifiers based on their names.
The highlight color of each identifier is chosen based on the hash of the identifier's name.
The package's source is available at [[https://github.com/Fanael/rainbow-identifiers][github.com/Fanael/rainbow-identifiers]].

I want this package to be enabled when programming, so I enable it for \src_emacs-lisp{prog-mode} and all major modes that inherit from \src_emacs-lisp{prog-mode}, which effectively covers all programming language major modes.
This is done by adding \src_emacs-lisp{rainbow-identifiers-mode} to \src_emacs-mode{prog-mode-hook}, performed below by the arguments to the ~:ghook~ keyword[fn:1].

#+begin_src emacs-lisp
(use-package rainbow-identifiers
  :ghook
  <<rainbow-identifiers/ghook>>

  :custom
  <<rainbow-identifiers/custom>>)
#+end_src

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref rainbow-identifiers/custom
:END:

Only use Rainbow Identifiers to highlight (read: color) variable names.

#+begin_src emacs-lisp
(rainbow-identifiers-faces-to-override
 '(font-lock-constant-face
   font-lock-type-face
   font-lock-function-name-face
   font-lock-variable-name-face
   font-lock-keyword-face
   font-lock-builtin-face))
#+end_src

** Rainbow Delimiters
Rainbow Delimters provides a minor mode that highlights delimeters such as parantheses based on their depth.
The highlight color of each level is distinct.
The package's source is available at [[https://github.com/Fanael/rainbow-delimiters][github.com/Fanael/rainbow-delimeters]].

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  ;; Load this package eagerly.
  :demand

  :ghook
  <<rainbow-delimiters/ghook>>)
#+end_src

** /Paren/

Show matching parentheses.
#+begin_src emacs-lisp
(use-package paren
  :straight (:type built-in)
  :demand
  :config
  (show-paren-mode +1))
#+end_src

** Line Wrapping
Out of the box, Emacs will fill paragraph to 72 characters.
Most projects that care about line width adhere to an 80 character (79 + line feed) maximum width, so to reduce the amount of per-project customization we can set the default value to 80.
#+begin_src emacs-lisp
(custom-set-default 'fill-column 80)
#+end_src

** Display Line Numbers

#+begin_src emacs-lisp
(use-package display-line-numbers
  :straight (:type built-in)

  ;; Only load this package if the following code evaluates to non-nil.
  :if
  <<display-line-numbers/if>>

  ;; Apply the following customizations.
  :custom
  (display-line-numbers-widen t "Disregard any narrowing.")
  (display-line-numbers-current-absolute t "Always display absolute number of current line.")

  ;; Add the following auto-loading hooks.
  :ghook
  <<display-line-numbers/ghook>>

  ;; Evaluate the following expressions about loading this package.
  :config
  <<display-line-numbers/config>>)
#+end_src

*** Conditional Loading
:PROPERTIES:
:DESCRIPTION: Define condition for loading ~display-line-numbers~.
:HEADER-ARGS+: :noweb-ref display-line-numbers/if
:END:

~display-line-numbers~ was added in GNU Emacs 26.1.

#+begin_src emacs-lisp
(version< "26.1" emacs-version)
#+end_src

*** Automatically Switch Between Relative and Absolute Line Numbers

**** Display Absolute Line Numbers when Entering Insert State

#+begin_src emacs-lisp :noweb-ref display-line-numbers/config
(defun display-line-numbers-absolute ()
  "Display absolute line numbers."
  (setq-local display-line-numbers t))
#+end_src

#+begin_src emacs-lisp :noweb-ref display-line-numbers/config
(defun display-line-numbers-evil-insert-entry ()
  "Display absolute line numbers upon entering insert state."
  (general-add-hook
   'evil-insert-state-entry-hook
   #'display-line-numbers-absolute
   nil
   t))
#+end_src

#+begin_src emacs-lisp :noweb-ref display-line-numbers/ghook
('prog-mode-hook #'display-line-numbers-evil-insert-entry)
#+end_src

**** Display Visual-Relative Line Numbers at Start and Upon Exiting Insert State

#+begin_src emacs-lisp :noweb-ref display-line-numbers/config
(defun display-line-numbers-visual ()
  "Display visual-relative line numbers."
  (setq-local display-line-numbers 'visual))
#+end_src

#+begin_src emacs-lisp :noweb-ref display-line-numbers/config
(defun display-line-numbers-evil-insert-exit ()
  "Display absolute line numbers upon exiting insert state."
  (general-add-hook
   'evil-insert-state-exit-hook
   #'display-line-numbers-visual
   nil
   t))
#+end_src

#+begin_src emacs-lisp :noweb-ref display-line-numbers/ghook
('prog-mode-hook #'display-line-numbers-evil-insert-exit)
#+end_src

#+begin_src emacs-lisp :noweb-ref display-line-numbers/ghook
('prog-mode-hook #'display-line-numbers-visual)
#+end_src

** /Highlight Indent Guides/

#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :ghook
  <<highlight-indent-guides/ghook>>

  :custom
  (highlight-indent-guides-method 'character)
  (highlight-indent-guides-character ?│))
#+end_src

** Theme

#+begin_src emacs-lisp
(use-package modus-themes
  :demand

  :init
  ;; Load the theme files before enabling a theme
  (modus-themes-load-themes)

  :config
  ;; Load the theme of your choice:
  (modus-themes-load-operandi))
#+end_src

* Buffer Organization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref buffer-organization
:END:

** Projectile
#+begin_src emacs-lisp
(use-package projectile
  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  <<projectile/general>>

  ;; Customize the following variables.
  :custom
  <<projectile/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<projectile/config>>)
#+end_src

*** Auto-Loading Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref projectile/general
:END:

#+begin_src emacs-lisp
(:keymaps 'projectile-mode-map
 "C-c p" 'projectile-command-map
 "C-x g" #'projectile-vc)
#+end_src

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref projectile/custom
:END:

Enable ~projectile-mode~ globally.
#+begin_src emacs-lisp
(projectile-mode t)
#+end_src

When switching projects, default to opening the ~vc-dir~ at the root of the project.
#+begin_src emacs-lisp
(projectile-switch-project-action #'projectile-vc)
#+end_src

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref projectile/config
:END:

Use Ivy's integration.
#+begin_src emacs-lisp
(with-eval-after-load 'ivy
  (setq projectile-completion-system 'ivy))
#+end_src

** Counsel Projectile

#+begin_src emacs-lisp
(use-package counsel-projectile
  ;; Load this package after the following packages.
  :after (:all counsel projectile)

  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  (:keymaps 'projectile-mode-map
   "C-x C-f" #'counsel-projectile-find-file
   "C-x C-b" #'counsel-projectile-switch-to-buffer
   "C-x C-d" #'counsel-projectile-find-dir)

  ;; Customize the following variables.
  :custom
  <<counsel-projectile/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  (counsel-projectile-mode +1))
#+end_src

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref counsel-projectile/custom
:END:

Do not display the current project when switching projects.
#+begin_src emacs-lisp
(counsel-projectile-remove-current-project t)
#+end_src

Do not display the current buffer when switching buffers..
#+begin_src emacs-lisp
(counsel-projectile-remove-current-buffer t)
#+end_src

** Perspective

/Perspective/ provides tagged workspaces.
#+begin_src emacs-lisp
(use-package perspective
  ;; Load this package eagerly.
  :demand

  ;; Customize variables.
  :custom
  (persp-mode t "Enable perspective mode globally"))
#+end_src

** /Relative Buffers/

From the package's README:
#+begin_quote
[/Relative Buffers/] is a tiny package that will rename your buffers according to project structure.
For python buffers that will be whole module name.
For temporary files and directories that will be relative path from project root.
#+end_quote

#+begin_src emacs-lisp
(use-package relative-buffers
  :straight (:host github :repo "emacsattic/relative-buffers")
  :ghook
  <<relative-buffers/ghook>>)
#+end_src

** /Current Buffer/

#+begin_src emacs-lisp
(use-package current-buffer
  :straight (:host github
             :repo "lafrenierejm/current-buffer.el")

  :general
  ("C-x C-S-d" #'current-buffer-delete)
  ("C-x C-c" #'current-buffer-copy)
  ("C-x C-g" #'current-buffer-revert)
  ("C-x C-k" #'current-buffer-kill)
  ("C-x C-r" #'current-buffer-rename)
  ("C-x y n" #'current-buffer-yank-name)
  ("C-x y p" #'current-buffer-yank-path))
#+end_src

* Documentation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref documentation
:END:

** AsciiDoc

From [[https://asciidoc.org/][its website:]]
#+begin_quote
AsciiDoc is a text document format for writing notes, documentation, articles, books, ebooks, slideshows, web pages, man pages and blogs.
AsciiDoc files can be translated to many formats including HTML, PDF, EPUB, man page.

AsciiDoc is highly configurable: both the AsciiDoc source file syntax and the backend output markups (which can be almost any type of SGML/XML markup) can be customized and extended by the user.

AsciiDoc is free software and is licenced under the terms of the GNU General Public License version 2 (GPLv2).
#+end_quote

*** /ADoc Mode/

From [[https://github.com/sensorflo/adoc-mode/wiki][the package's wiki:]]
#+begin_quote
\src_emacs-lisp{adoc-mode} is an Emacs major mode for editing AsciiDoc files.
It emphasizes on the idea that the document is highlighted so it pretty much looks like the final output.
What must be bold is bold, what must be italic is italic etc.
Meta characters are naturally still visible, but in a faint way, so they can be easily ignored.
#+end_quote

#+begin_src emacs-lisp
(use-package adoc-mode
  :mode ("\\.adoc\\'" . adoc-mode))
#+end_src

** Org Mode
Strong support for literate programming is provided by Org mode's features.

*** Org
:PROPERTIES:
:CUSTOM_ID: bootstrap/org
:END:

Note that although \src_emacs-lisp{use-package} is used below, the /Org/ package should already be loaded due to the \src_emacs-lisp{require} call in [[#bootstrap/org]].

#+begin_src emacs-lisp
(use-package org
  :straight (:type built-in)

  :demand

  :gfhook
  <<org/gfhook>>

  :custom
  <<org/custom>>

  :config
  <<org/config>>)
#+end_src

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref org/gfhook
:END:

Enable the following minor modes in all Org buffers:
- \src_emacs-lisp{org-indent-mode} to indent text according to outline structure.
- \src_emacs-lisp{visual-line-mode} to naturally wrap long lines.


#+begin_src emacs-lisp
('org-mode-hook (list #'org-indent-mode #'visual-line-mode))
#+end_src

**** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref org/custom
:END:

Determine how leading whitespace characters in source blocks are treated.
#+begin_src emacs-lisp
(org-src-preserve-indentation t "Preserve source blocks' indentation.")
(org-edit-src-content-indentation 0 "Do not add any additional indentation to source blocks in Org buffers.")
#+end_src

Determine where source blocks are opened.
Note that this is effectively deprecated by Polymode;  I set it here only as a fallback.
#+begin_src emacs-lisp
(org-src-window-setup 'current-window "Edit source blocks in the current window.")
#+end_src

Determine what is required to follow links.
#+begin_src emacs-lisp
(org-return-follows-link t "Follow links with just RET.")
#+end_src

Set whether confirmation is required before evaluating source blocks.
#+begin_src emacs-lisp
(org-confirm-babel-evaluate nil "Do not require confirmation before evaluating source blocks.")
#+end_src

Set the workflow states.
#+begin_src emacs-lisp
(org-todo-keywords '((sequence "TODO" "FEEDBACK" "VERIFY" "|"
                               "DELEGATED" "DONE(d!/!)" "|"
                               "CANCELED")))
#+end_src

**** Spell Check

Use /Wucuo/ to perform spell checking.

#+begin_src emacs-lisp :noweb-ref wucuo/ghook
('org-mode-hook #'wucuo-start)
#+end_src

*** Poly Org

/Poly Org/ provides Polymode definitions for Org buffers.
#+begin_src emacs-lisp
(use-package poly-org)
#+end_src

*** Ox LaTeX

/Ox/ (Org eXport) allows exporting Org files such as this one.
/Ox LaTeX/ builds uses that framework to export to (La)TeX.

#+begin_src emacs-lisp
(use-package ox-latex
  :straight (:type built-in)
  :config
  <<ox-latex/config>>)
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ox-latex/config
:END:

If =latexmk= and its Perl dependency exist in =PATH=, use =latexmk= with a LuaLaTeX backend to compile TeX files.
#+begin_src emacs-lisp
(when (and (executable-find "latexmk")
           (executable-find "perl"))
  (general-setq-default org-latex-pdf-process '("latexmk -lualatex -f %f")))
#+end_src

*** Smartparens
:PROPERTIES:
:HEADER-ARGS+: smartparens/config
:END:

The equals sign (\=), tilde (\~), and forward slash (/) are used by Org syntax to wrap inline monospace, code, text, and italics respectively.
I want them to be automatically paired in Org buffers.
#+begin_src emacs-lisp
(sp-local-pair 'org-mode "=" "=")
(sp-local-pair 'org-mode "~" "~")
(sp-local-pair 'org-mode "/" "/")
#+end_src

Meanwhile, when writing prose I tend to use the single prime (') primarily as an apostrophe in English prose so I want it to /not/ be paired.
#+begin_src emacs-lisp
(sp-local-pair 'org-mode "'" nil :actions nil)
#+end_src

*** Evil Org

/Evil Org/ adds a minor mode that provides [[Evil]] keybindings for common Org mode actions.
#+begin_src emacs-lisp
(use-package evil-org
  ;; Load this package after the following packages.
  :after (:all evil org)

  ;; Add the following auto-loading hooks.
  :ghook
  <<evil-org/ghook>>

  ;; Add the following non-auto-loading hooks.
  :gfhook
  <<evil-org/gfhook>>

  ;; Inform the bytecode compiler of the following functions.
  :functions
  (evil-org-set-key-theme)

  ;; Apply the following variable customizations.
  :custom
  <<evil-org/custom>>)
#+end_src

**** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/ghook
:END:

Enable Evil Org mode in all Org mode buffers.
#+begin_src emacs-lisp
('( org-agenda-mode-hook org-mode-hook) #'evil-org-mode)
#+end_src

**** Non-Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/gfhook
:END:

Set keys for \src_emacs-lisp{org-mode} and \src_emacs-lisp{org-agenda-mode}.
#+begin_src emacs-lisp
('evil-org-mode-hook #'evil-org-set-key-theme)
#+end_src

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/custom
:END:

Specify the key themes to enable.
#+begin_src emacs-lisp
(evil-org-key-theme
 '(calendar
   navigation
   insert
   textobjects))
#+end_src

Retain selection after typing =<= or =>= in visual state.
#+begin_src emacs-lisp
(evil-org-retain-visual-state-on-shift t)
#+end_src

** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  ;; Inform the bytecode compiler of the following variables.
  :defines markdown-mode-hook

  ;; Inform the bytecode compiler of the following functions.
  :functions markdown-mode-spaces-only

  ;; Established deferred binding within `auto-mode-alist'.
  :mode
  (("README\\.md\\'" . gfm-mode)
   ("\\.md\\'" . markdown-mode))

  ;; Add the following non-autoloading hooks.
  :gfhook
  ('markdown-mode-hook #'markdown-mode-spaces-only)

  :config
  (defun markdown-mode-spaces-only ()
    (setq indent-tabs-mode nil)))
#+end_src

** reStructuredText (RST)

Emacs includes a package for /RST/ for working with reStructuredText.
#+begin_src emacs-lisp
(use-package rst
  :straight (:type built-in)

  :mode ("\\.rst\\'" . rst-mode)

  ;; Add the following keybindings.
  :general
  <<rst/general>>

  ;; Inform the bytecode compiler of the following interactive functions.
  :commands
  <<rst/commands>>

  ;; Evaluate the following code after the package has been loaded.
  :config
  <<rst/config>>)
#+end_src

*** External Hyperlink (e.g. URL) Insertion

From [[https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#embedded-uris-and-aliases][the documentation on hyperlinks]]:
#+begin_quote
- Named hyperlink references:
  - No start-string, end-string = =_=.
  - Start-string = =`=, end-string = =`_=. (Phrase references.)
- Anonymous hyperlink references:
   - No start-string, end-string = =__=.
   - Start-string = =`=, end-string = =`__=. (Phrase references.)

A hyperlink reference may directly embed a target URI or (since Docutils 0.11) a hyperlink reference within angle brackets ("<...>") as follows:
#+begin_example rst
See the `Python home page <http://www.python.org>`_ for info.

This `link <Python home page_>`_ is an alias to the link above.
#+end_example
#+end_quote

A helper function is defined to aid in insertion of inline links.
#+begin_src emacs-lisp :noweb-ref rst/config
(defun rst-insert-link (uri &optional description)
  "Insert an external hyperlink to URI, displaying text DESCRIPTION."
  (interactive "*\
MURI:
MDisplay text: ")
  (if description
      (insert (format "`%s <%s>`_" description uri))
    (insert (format "`%s`__" uri))))
#+end_src

Inform the bytecode compiler of the above function.
#+begin_src emacs-lisp :noweb-ref rst/commands
rst-insert-link
#+end_src

Bind the above function to =C-c C-l= in \src_emacs-lisp{rst-mode}.
#+begin_src emacs-lisp :noweb-ref rst/general
("C-c C-l" #'rst-insert-link)
#+end_src

** TeX

*** AUCTeX

From the package's README:
#+begin_quote
AUCTeX is a comprehensive customizable integrated environment for writing input files for TeX, LaTeX, ConTeXt, Texinfo, and docTeX using Emacs.
#+end_quote

#+begin_src emacs-lisp
(use-package auctex)
#+end_src

*** Evil TeX

#+begin_src emacs-lisp
(use-package evil-tex
  :ghook
  ('LaTeX-mode-hook #'evil-tex-mode))
#+end_src

*** Reformatter

#+begin_src emacs-lisp :noweb-ref reformatter/config
(reformatter-define
  latex-indent
  :program "latexindent"
  :args (list "--silent" "--overwrite" input-file)
  :stdin nil)
#+end_src

* Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref keybindings
:END:

** macOS-specific

#+begin_src emacs-lisp
(when (eq system-type 'darwin)
  (setq mac-option-modifier 'super
        mac-command-modifier 'meta))
#+end_src

** "Yes Or No" Selection

Avoid having to type out "yes" and "no" by replacing them with "y" and "n", respectively.
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Evil

/Evil/ aims to implement Vi's user features, most notably Vi's modal keyboard interface, in Emacs Lisp for use in Emacs.
I prefer Vi's keybindings to Emacs's, so I enable Evil everywhere I can.
#+begin_src emacs-lisp
(use-package evil
  ;; Load this package eagerly.
  :demand

  ;; Add the following autoloading hooks.
  :ghook
  <<evil/ghook>>

  ;; Apply the following variable customizations.
  :custom
  <<evil/custom>>

  ;; Set the following keybindings.
  :general
  <<evil/general>>

  ;; Evaluate the following code before loading this package.
  :init
  <<evil/init>>

  ;; Evaluate the following code after loading this package.
  :config
  <<evil/config>>)
#+end_src

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/custom
:END:

Determine whether to enable Evil in minibuffers.
#+begin_src emacs-lisp
(evil-want-minibuffer t "Enable Evil in minibuffers.")
#+end_src

#+begin_src emacs-lisp
(evil-mode-line-format nil "Do not display state tag in modeline.")
#+end_src

**** Set Keybindings (~:general~)
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/general
:END:

Use Emacs state instead of insert state.
This preserves readline-style keybindings.
#+begin_src emacs-lisp :noweb-ref evil/init
(setq-default evil-disable-insert-state-bindings t)
#+end_src

Do not allow =C-z= to enter Emacs mode.
Instead, make it a noop as far as Evil is concerned.
#+begin_src emacs-lisp
(:states (list 'normal 'insert 'visual 'replace 'operator 'motion)
 "C-z" nil)
#+end_src

Use shift + horizontal movement keys to jump to beginning or end of lines.
#+begin_src emacs-lisp
(:states '(motion normal visual)
 "H" #'evil-beginning-of-line-maybe
 "L" #'evil-end-of-line-maybe
 "SPC" #'evil-toggle-fold)
#+end_src

Bind =:= to ~eval-expression~ to evaluate one-off Emacs Lisp expressions.
#+begin_src emacs-lisp
(:states '(motion normal replace visual)
 ":" #'eval-expression)
#+end_src

Mirror =D='s behavior for yank.
#+begin_src emacs-lisp
(:states 'normal
 "Y" #'evil-yank-to-end-of-line)
#+end_src

Unbind =C-r= in insert mode to allow comint/shell history search.
#+begin_src emacs-lisp
(:states 'insert
 "C-r" nil)
#+end_src

**** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/init
:END:

Allow use of Evil Collection.
#+begin_src emacs-lisp
(setq-default evil-want-integration t)
(setq-default evil-want-keybinding nil)
#+end_src

Navigate by visual lines rather than newline-delimited lines.
#+begin_src emacs-lisp
(setq-default evil-respect-visual-line-mode)
#+end_src

**** Post-Load Evaluation (~:config~)
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/config
:END:

Enable Evil by default in all modes.
#+begin_src emacs-lisp
(evil-mode 1)
#+end_src

Define a function to enable \src_emacs-lisp{evil-move-beyond-eol}.
#+begin_src emacs-lisp
(defun evil-move-beyond-eol ()
  "Allow the cursor to move beyond the end of the line."
  (set (make-local-variable 'evil-move-beyond-eol) t))
#+end_src

***** Define =evil-yank-to-end-of-line=
#+begin_src emacs-lisp
(defun evil-yank-to-end-of-line ()
  "Yank the characters from point to the end of the current line."
  (interactive)
  (evil-yank (point) (point-at-eol)))
#+end_src

***** Semantic Movement Within Lines
****** Define ~back-to-comment~
The following code is based on [[http://stackoverflow.com/a/14245964%0A][a StackOverflow answer]] by user [[https://stackoverflow.com/users/387076/gilles][Gilles]].
All code posted to StackOverflow.com is licensed under CC BY-SA 3.0, so the following derived code is also CC BY-SA 3.0-licensed.

#+begin_src emacs-lisp
(defun evil-back-to-comment ()
  "Move point to the beginning of the comment in the current line.

If the current line does not contain a comment, then point will stay
in place and the function will return nil.  Otherwise the function
will return t."
  (interactive "^")
  (save-match-data
    ;; Record the position of the beginning of the line.
    (let ((old-point (point))
          (bol (progn
                 (beginning-of-line)
                 (point))))
      ;; Go to the end of the line.
      (end-of-line)
      ;; Look backward from there for a comment.
      (if (and comment-start-skip
               (comment-search-backward bol 'noerror))
          (progn
            (message "Comment found")
            ;; Go to the start of the comment's delimeter.
            (search-backward-regexp comment-start-skip bol 'noerror)
            ;; Go the start of any immediately prior whitespace.
            (skip-syntax-backward " \t" bol)
            ;; Return t.
            t)
        ;; Return point to its previous location.
        (goto-char old-point)
        ;; Return nil.
        nil))))
#+end_src

****** Define ~evil-back-to-text~
#+begin_src emacs-lisp
(defun evil-back-to-text ()
  "Move point to the last non-whitespace character on this line."
  (interactive)
  ;; Move point to the last character on this line.
  (move-end-of-line nil)
  ;; Move backward for non-whitesapce character.
  (re-search-backward "^\\|[^[:space:]]")
  ;; Move forward one character.
  (forward-char))
#+end_src

****** Define ~beginning-of-line-maybe~
~beginning-of-line-maybe~ moves ~point~ toward the beginning of the current line incrementally by semantic region.
The following semantic elements are considered:
1. Comment
2. Source code
3. Indentation (leading whitespace)

The following code is based on [[https://stackoverflow.com/a/145359/8468492][a StackOverflow answer]] by user [[https://stackoverflow.com/users/8355/cjm][cjm]].
All code posted to StackOverflow.com is licensed under CC BY-SA 3.0, so the following derived code is also CC BY-SA 3.0-licensed.

#+begin_src emacs-lisp
(defun evil-beginning-of-line-maybe ()
  "Move point to first non-whitespace character or beginning of the line.

Move point to the first non-whitespace character on the line.  If the
point was already at that position, move point to the beginning of the
line."
  (interactive)
  (let ((old-point (point)))            ; current position
    ;; Go to the beginning of a comment.  If there is not comment or
    ;; if point is already at or to the left of the comment...
    (when (or (not (evil-back-to-comment))
              (<= old-point (point)))
      ;; Go to the first non-whitespace column.
      (back-to-indentation)
      ;; If already at or to the left of the first non-whitespace character...
      (when (<= old-point (point))
        ;; Go to the beginning of the line.
        (beginning-of-line)))))
#+end_src

****** Define ~evil-end-of-line-maybe~
~end-of-line-maybe~ incrementally moves ~point~ to the right within a line by semantic region.
The following semantic elements are considered in ~end-of-line-maybe~'s movement:
1. Source code
2. Comments
3. Trailing whitespace


The following is licensed CC BY-SA 3.0-licensed by StackOverflow user [[https://stackoverflow.com/users/387076/gilles][Gilles]].
It is based on [[http://stackoverflow.com/a/14245964][Gilles's StackOverflow answer]].

#+begin_src emacs-lisp
(defun evil-end-of-line-maybe ()
  "Incrementally move point to the ends of syntactic blocks within the line.

The syntactic blocks are as follows, ordered from right to left:
1. Source code
2. Inline comment"
  (interactive "^")
  ;; Record point's current position.
  (let ((old-point (point)))
    ;; Go to the beginning of an inline comment (if any).
    (evil-back-to-comment)
    ;; If already at or after the start of the comment...
    (when (>= old-point (point))
      ;; ...then go to the beginning of trailing whitespace.
      (evil-back-to-text))))
#+end_src

*** /Evil Collection/

/Evil Collection/ offers a collection of Evil keybindings for modes that Evil does not support by default.
#+begin_src emacs-lisp
(use-package evil-collection
  ;; Load this package eagerly.
  :demand

  ;; Load this package afer the following packages.
  :after evil

  :preface
  (setq-default evil-want-keybinding nil)

  ;; Apply the following variable customizations.
  :custom
  <<evil-collection/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<evil-collection/config>>)
#+end_src

**** Apply Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-collection/custom
:END:

Set up autocompletion to be similar to Vim's YouCompleteMe.
#+begin_src emacs-lisp
(evil-collection-company-use-tng nil)
#+end_src

Enable =TAB=-based bindings in Outline mode.
#+begin_src emacs-lisp
(evil-collection-outline-bind-tab t)
#+end_src

Synchronize insert and normal states with char and line modes, respectively, in Term mode.
#+begin_src emacs-lisp
(evil-collection-term-sync-state-and-mode-p t)
#+end_src

Set up Vim-style keybindings in the minibuffer.
#+begin_src emacs-lisp
(evil-collection-setup-minibuffer t)
#+end_src

Set up debugger keys.
#+begin_src emacs-lisp
(evil-collection-setup-debugger-keys t)
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-collection/config
:END:

Enable Evil Collection globally.
#+begin_src emacs-lisp
(evil-collection-init)
#+end_src

*** Evil Matchit

[[https://github.com/redguardtoo/evil-matchit][Evil Matchit]] is a port of Tim Pope's [[http://www.vim.org/scripts/script.php?script_id%3D39][matchit.vim]] to Evil.
It enables jumping between matched tags, e.g. =<div>= and =</div>=.
#+begin_src emacs-lisp
(use-package evil-matchit
  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  (:keymaps 'evil-matchit-mode-map
   :states 'motion
   "%" #'evilmi-jump-items)

  :config
  (global-evil-matchit-mode 1))
#+end_src

*** Evil Surround

[[https://github.com/emacs-evil/evil-surround][Evil Surround]] is a port of [[https://github.com/tpope/vim-surround][vim-surround]] to Evil.
It adds a "surround" verb to Evil's modal editing.
#+begin_src emacs-lisp
(use-package evil-surround
  ;; Load eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  (global-evil-surround-mode 1))
#+end_src

*** Evil Indent Plus
=[[https://github.com/TheBB/evil-indent-plus]]= adds indentation levels as a text object for Evil.

- =i= is same or higher indentation.
- =I= is same or higher indentation, including the first line above with less indentation.
- =J= is same or higher indentation, including the first line above and below with less indentation.


#+begin_src emacs-lisp
(use-package evil-indent-plus
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  (evil-indent-plus-default-bindings))
#+end_src

** Smartparens

[[https://github.com/Fuco1/smartparens][Matus Goljer (Fuco1)'s package]] provides a minor mode "that deals with parens pairs and tries to be smart about it".

#+begin_src emacs-lisp
(use-package smartparens
  ;; Load this package eagerly.
  :demand

  :custom
  (sp-ignore-modes-list '())

  :config
  (smartparens-global-mode +1))
#+end_src

** Smartparens Config

Smartparens Config configures Smartparens for various programming languages.

#+begin_src emacs-lisp
(use-package smartparens-config
  :straight smartparens

  ;; Load this package after the following packages.
  :after smartparens

  ;; Load this package eagerly.
  :demand)
#+end_src

** /Smart Dash/

/Smart Dash/ a minor mode which redefines the dash key ("-") to insert an underscore within C-style identifiers and a dash otherwise.
#+begin_src emacs-lisp
(use-package smart-dash
  :ghook
  <<smart-dash/ghook>>)
#+end_src

** Caps Lock

#+begin_src emacs-lisp
(use-package caps-lock
  :general
  <<caps-lock/general>>

  :ghook
  <<caps-lock/ghook>>

  :functions
  <<caps-lock/functions>>

  :config
  <<caps-lock/config>>)
#+end_src

#+begin_src emacs-lisp :noweb-ref caps-lock/general
(:states 'insert
 "C-l" #'caps-lock-mode)
#+end_src

*** Disable When Exiting Insert State

Define a function to disable \src_emacs-lisp{caps-lack-mode}.
#+begin_src emacs-lisp :noweb-ref caps-lock/config
(defun caps-lock-disable ()
  "Disable `caps-lock-mode'."
  (caps-lock-mode -1))
#+end_src

Inform the bytecode compiler of the above function.
#+begin_src emacs-lisp :noweb-ref caps-lock/functions
caps-lock-disable
#+end_src

Run the above function whenever Insert state is existed…
#+begin_src emacs-lisp :noweb-ref caps-lock/ghook
('evil-insert-state-exit-hook #'caps-lock-disable)
#+end_src

** /Which Key/

#+begin_src emacs-lisp
(use-package which-key
  :demand
  :config
  (which-key-mode +1))
#+end_src

Enable integration with /Which Key/.
#+begin_src emacs-lisp :noweb-ref lsp-mode/gfhook
('lsp-mode-hook #'lsp-enable-which-key-integration)
#+end_src

* Minibuffer
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref minibuffer
:END:

The minibuffer is a persistent buffer in Emacs that is used for interactive input and messages.

** Recursive Minibuffers

Allowing one to have more than one minibuffer active allows for more sophisticated workflows.
#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
#+end_src

Once having multiple active minibuffers is possible, it is helpful to keep track of the depth of recursion.
#+begin_src emacs-lisp
(minibuffer-depth-indicate-mode +1)
#+end_src

** Flx

/Flx/ provides fuzzy searching algorithms.
Ivy's fuzzy finding will use Flx's scoring mechanism if /Flx/ is loaded.

#+begin_src emacs-lisp
(use-package flx
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code before loading this package.
  :init
  <<flx/config>>)
#+end_src

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref flx/config
:DESCRIPTION: Code to evaluated after ~flx~ has been loaded.
:END:

Run Emacs's garbage collector only when at least 20 MB have been allocated.
Doing so greatly improves ~flx~'s performance when working with large sets.

#+begin_src emacs-lisp
(when (> 20000000 gc-cons-threshold)
  (setq gc-cons-threshold 20000000))
#+end_src

** Ivy

From the project's readme:
#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs.
While it operates similarly to other completion schemes such as =icomplete-mode=, Ivy aims to be more efficient, smaller, simpler, and smoother to use yet highly customizable.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package ivy
  ;; Load this package after the following packages.
  :after (flx)

  ;; Load this package eagerly.
  :demand

  ;; Inform the byte-compiler of the following interactive functions.
  :commands
  (ivy-mode)

  ;; Inform the byte-code compiler of the following non-interactive functions.
  :functions
  (ivy-format-function-line)

  ;; Add the following keybindings.
  :general
  <<ivy/general>>

  ;; Apply the following customizations.
  :custom
  <<ivy/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<ivy/config>>)
#+end_src

*** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy/general
:END:

Shadow ~switch-to-buffer~ with ~ivy-switch-buffer~.
#+begin_src emacs-lisp
("C-x C-b" #'ivy-switch-buffer)
#+end_src

When in an Ivy buffer:
- =M-<return>= sends the current input verbatim.
- =C-u= restarts the minibuffer with a prefix argument.


#+begin_src emacs-lisp
(:keymaps 'ivy-minibuffer-map
 "M-<return>" #'ivy-immediate-done
 "C-u" #'init-minibuffer/restart-with-prefix)
#+end_src

When in the minibuffer:
- =C-u= restarts the minibuffer with a prefix argument.


#+begin_src emacs-lisp
(:keymaps 'minibuffer-inactive-mode-map
 "C-u" #'init-minibuffer/restart-with-prefix)
#+end_src

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy/custom
:END:

Determine how matched parts of the options are highlighted.
#+begin_src emacs-lisp
(ivy-display-style
 'fancy
 "Highlight the matching parts of the regexp in the minibuffer.")
#+end_src

#+begin_src emacs-lisp
(ivy-use-virtual-buffers
 t
 "Show recently killed buffers when calling `ivy-switch-buffer'.")
#+end_src

#+begin_src emacs-lisp
(ivy-re-builders-alist
 '((counsel-grep-or-swiper . ivy--regex-plus)
   (t . ivy--regex-plus))
 "Use `ivy--regex-plus' as the default matching function.")
#+end_src

#+begin_src emacs-lisp
(ivy-extra-directories
 nil
 "Do not show './' or '../' in the filename completion list.")
#+end_src

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to evaluate after ~ivy~ has been loaded.
:HEADER-ARGS+: :noweb-ref ivy/config
:END:

Enable ~ivy-mode~ globally.
#+begin_src emacs-lisp
(ivy-mode +1)
#+end_src

Do not include TRAMP buffers in Ivy's buffer lists.
#+begin_src emacs-lisp
(setq ivy-ignore-buffers
      (cons (rx line-start "*tramp/"
                (one-or-more (not whitespace))
                whitespace
                (one-or-more anything)
                "*" line-end)
            ivy-ignore-buffers))
#+end_src

**** Restart the Minibuffer with a Prefix Argument
:PROPERTIES:
:AUTHOR:   Clemens Radermacher (clemera) <clemera@posteo.net>
:COPYRIGHT: Copyright (C) 2019 Clemens Radermacher
:END:

Out of the box, Emacs does not provide a graceful way to add a prefix argument after the user has already started entering a command.
The following code posted by u/clemera on Reddit provides a workaround by restarting the minibuffer with same text.

First, a variable is defined to hold the minibuffer contents that were typed before entering a prefix.
#+begin_src emacs-lisp
(defvar init-minibuffer/original-command nil
  "Command the minibuffer was started with.")
#+end_src

#+begin_src emacs-lisp
(defun init-minibuffer/restart-with-prefix ()
  "Restart the minibuffer with a prefix argument."
  (interactive)
  (let ((input (ivy--input)))
    (cond ((memq #'ivy--queue-exhibit post-command-hook)
           (ivy-quit-and-run
             (let ((current-prefix-arg '(4))
                   (ivy-initial-inputs-alist `((,(ivy-state-caller ivy-last) . ,input))))
               (call-interactively (ivy-state-caller ivy-last))))
           (t
            (ivy-quit-and-run
              (let ((current-prefix-arg '(4)))
                (minibuffer-with-setup-hook
                    (lambda ()
                      (insert input)
                      (minibuffer-message "C-u"))
                  (call-interactively init-minibuffer/current-command)))))))))
#+end_src

** Counsel
#+begin_src emacs-lisp
(use-package counsel

  ;; Load this package after the following packages.
  :after (ivy)

  ;; Load this package eagerly.
  :demand

  ;; Perform the following keybindings.
  :general
  ("C-h k" #'counsel-descbinds)
  ("C-x C-4 C-b" #'switch-to-buffer-other-window)
  ("C-x C-4 C-f" #'find-file-other-window)
  ("C-x C-4 b" #'switch-to-buffer-other-window)
  ("C-x C-f" #'counsel-find-file)
  ("C-x b" #'counsel-switch-buffer)
  ("C-x f" #'counsel-find-file)
  ("M-x" #'counsel-M-x)
  (:keymaps '(minibuffer-local-map minibuffer-inactive-mode-map)
   :states '(insert movement)
   "C-r" #'counsel-minibuffer-history)
  (:keymaps '(comint-mode-map shell-mode-map)
   :states 'insert
   "C-r" #'counsel-shell-history)
  <<counsel/general>>

  :custom
  <<counsel/custom>>
  (counsel-switch-buffer-preview-virtual-buffers nil "Do not preview buffers"))
#+end_src

*** Use Ripgrep(-All) when Available

From [[https://github.com/BurntSushi/ripgrep][ripgrep (rg)]]'s readme:
#+begin_quote
ripgrep is a line-oriented search tool that recursively searches your current directory for a regex pattern.
By default, ripgrep will respect your .gitignore and automatically skip hidden files/directories and binary files.
ripgrep has first class support on Windows, macOS and Linux, with binary downloads available for every release.
ripgrep is similar to other popular search tools like The Silver Searcher, ack and grep.
#+end_quote

The primary benefit of ripgrep over GNU grep is its speed;
ripgrep's author, Andrew Gallant (aka burntsushi), has a [[https://blog.burntsushi.net/ripgrep/][thorough performance comparison]] between ripgrep and competing tools showing ripgrep outperforming in every metric.
Given that advantage, I use ripgrep as the default backend for my file-based searches.

[[https://github.com/phiresky/ripgrep-all][ripgrep-all (rga)]] builds on ripgrep by passing rich file types through various transformers to make their contents more easily greppable.
If ~rga~ is present, it is preferred to plain ~rg~.

#+begin_src emacs-lisp :noweb-ref counsel/custom
(counsel-grep-base-command
 (if-let ((command (cl-some #'executable-find '("rga" "rg"))))
     (s-join " " (list command
                       "--smart-case"
                       "--max-columns=88"
                       "--max-columns-preview"
                       "--no-heading"
                       "--line-number"
                       "--color=never"
                       "%s"
                       "%s"))
   counsel-grep-base-command))
#+end_src

*** Use Grep for Searching Large Buffers

#+begin_src emacs-lisp :noweb-ref counsel/general
("C-s" #'counsel-grep-or-swiper)
(:states '(movement normal visual)
 "/" #'counsel-grep-or-swiper)
#+end_src

** Ivy Rich
#+begin_src emacs-lisp
(use-package ivy-rich
  ;; Load this package after the following packages.
  :after ivy

  ;; Load this package eagerly.
  :demand

  ;; Apply the following customizations.
  :custom
  <<ivy-rich/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<ivy-rich/config>>)
#+end_src

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy-rich/custom
:END:

#+begin_src emacs-lisp
(ivy-virtual-abbreviate
 'abbreviate
 "Abbreviate virtual buffer names.")
#+end_src

#+begin_src emacs-lisp
(ivy-rich-path-style
 'relative
 "Show paths relative their the project home.")
#+end_src

Reduce the amount of information displayed for remote buffers (i.e. buffers whose contents were accessed via TRAMP).
This improves performance of operations that involve Ivy Rich.
#+begin_src emacs-lisp
(ivy-rich-parse-remote-buffer nil)
#+end_src

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to evaluate after loading ~ivy-rich~.
:HEADER-ARGS+: :noweb-ref ivy-rich/config
:END:

Enable ~ivy-rich-mode~ globally.
#+begin_src emacs-lisp
(ivy-rich-mode 1)
#+end_src

Add support for ~counsel-projectile-switch-to-buffer~, mirroring that of ~ivy-switch-buffer~.
#+begin_src emacs-lisp
(setq ivy-rich-display-transformers-list
      (plist-put
       ivy-rich-display-transformers-list
       'counsel-projectile-switch-to-buffer
       (plist-get ivy-rich-display-transformers-list 'ivy-switch-buffer)))
#+end_src

** Minibuffer Line
:PROPERTIES:
:DESCRIPTION: Display status info in the minibuffer
:END:

From /Minibuffer Line/'s readme:
#+BEGIN_QUOTE
This package lets you display various status information in the minibuffer window instead of the mode-line.
Of course, this is only displayed when the minibuffer window is not already used for other things (e.g. a minibuffer or an each area message).
The contents and aspect is controlled by the src_emacs-lisp{minibuffer-line-format} variable and the src_emacs-lisp{minibuffer-line} face.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package minibuffer-line
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code before loading this package.
  :init
  <<minibuffer-line/init>>

  ;; Inform the bytecode compiler of the following non-autoloading functions.
  :functions
  (format-time-string-8601 minibuffer-line-align)

  ;; Inform the bytecode compiler of the following autoloading functions.
  :commands
  minibuffer-line-mode

  ;; Apply the following variable customizations.
  :custom
  <<minibuffer-line/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<minibuffer-line/config>>
  (minibuffer-line-mode))
#+end_src

*** Allow Setting Left- and Right-Aligned Content

Define a variable to hold the string separator.
#+begin_src emacs-lisp :noweb-ref minibuffer-line/init
(defcustom minibuffer-line-separator " | "
  "String used to separate elements of minibuffer-line contents."
  :type 'string)
#+end_src

Define a function to separate contents provided as a list of functions or strings.
#+begin_src emacs-lisp :noweb-ref minibuffer-line/config
(defun minibuffer-line-separate (contents)
  (require 'cl-extra) ; for cl-map
  (defun eval-or-string (element)
    (cond
     ((stringp element)
      element)
     ((functionp element)
      `(:eval (,element)))
     (t
      `(:eval ,element))))
  (-drop-last
   1 (-flatten-n 1 (-zip-lists
                    (cl-map 'list #'eval-or-string contents)
                    (make-list (length contents) minibuffer-line-separator)))))
#+end_src

Define a function to left- and right-align elements using mode-line formatting.
#+begin_src emacs-lisp :noweb-ref minibuffer-line/config
(defun minibuffer-line-align (left right)
  "Return a string containing LEFT and RIGHT aligned across the frame.

LEFT and RIGHT are expected to be lists of strings or functions that return
strings.  The contents of the lists are separated with `minibuffer-line-separator'."
  (let* ((width-total (frame-text-cols))
         (width-space (- width-total
                         (+ (string-width (format-mode-line left))
                            (string-width (format-mode-line right))))))
    (append
     left
     (list (propertize
            (format (format "%%%ds" width-space) "")
            'face 'default))
     right)))
#+end_src

Use the above function to generate the value of \src_emacs-lisp{minibuffer-line-format}.
#+begin_src emacs-lisp :noweb-ref minibuffer-line/custom
(minibuffer-line-format
 '(:eval (minibuffer-line-align
          (minibuffer-line-separate minibuffer-line-left)
          (minibuffer-line-separate minibuffer-line-right)))
 "Describe the contents of the minibuffer line.")
#+end_src

Define variables to hold the left- and right-aligned contents.
#+begin_src emacs-lisp :noweb-ref minibuffer-line/init
(defcustom minibuffer-line-left '()
  "A list of the contents to align left in the minibuffer line."
  :type 'list)

(defcustom minibuffer-line-right '()
  "A list of the contents to align right in the minibuffer line."
  :type 'list)
#+end_src

*** Display the Time
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref minibuffer-line/config
:DESCRIPTION: Code to evaluate after loading /Minibuffer Line/
:END:

Define a function to print the date and time in ISO 8601 format.
#+begin_src emacs-lisp
(defun format-time-string-minibuffer-line ()
  "Return the current date and time in ISO 8601-like format."
  (format-time-string "%Y-%m-%d %T"))
#+end_src

#+begin_src emacs-lisp
(add-to-list 'minibuffer-line-right #'format-time-string-minibuffer-line t nil)
#+end_src

*** Display the System Name
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref minibuffer-line/config
:END:

#+begin_src emacs-lisp
(add-to-list 'minibuffer-line-right 'system-name)
#+end_src

*** Display the Battery Status
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref minibuffer-line/config
:END:

The \src_emacs-lisp{battery-status-function} used in \src_emacs-lisp{minibuffer-line-format} is provided by /Battery/.
That package must be loaded.
#+begin_src emacs-lisp
(use-package battery
  :straight (:type built-in)
  :demand
  :config
  (defvar battery-minibuffer-line-format
    "battery %L %p%%"
    "Control string formatting the battery status to display in the minibuffer.")
  (when battery-status-function
    (add-to-list 'minibuffer-line-right
               '(battery-format battery-minibuffer-line-format
                                (funcall battery-status-function)))))
#+end_src

*** Refresh Every Second

Determine how frequently the string in src_emacs-lisp{minibuffer-line-format} is recalculated.
#+begin_src emacs-lisp :noweb-ref minibuffer-line/custom
(minibuffer-line-refresh-interval
 1
 "Refresh the minibuffer-line every second.")
#+end_src

** McFly
:PROPERTIES:
:COPYRIGHT_YEAR: 2019
:COPYRIGHT_AUTHOR: Vincent Zhang (seagle0128)
:COPYRIGHT_EMAIL: seagle0128@gmail.com
:LICENSE:  GPLv3+
:END:

#+begin_src emacs-lisp
(defvar my-ivy-fly-commands '(query-replace-regexp
                              flush-lines
                              keep-lines
                              ivy-read
                              swiper
                              swiper-backward
                              swiper-all
                              swiper-isearch
                              swiper-isearch-backward
                              counsel-grep-or-swiper
                              counsel-grep-or-swiper-backward
                              counsel-grep
                              counsel-ack
                              counsel-ag
                              counsel-rg
                              counsel-pt))

(defun my-ivy-fly-back-to-present ()
  ;; (remove-hook 'pre-command-hook 'my-ivy-fly-back-to-present t)
  (cond ((and (memq last-command my-ivy-fly-commands)
              (equal (this-command-keys-vector) (kbd "M-p")))
         ;; repeat one time to get straight to the first history item
         (setq unread-command-events
               (append unread-command-events
                       (listify-key-sequence (kbd "M-p")))))
        ((or (memq this-command '(self-insert-command
                                  yank
                                  ivy-yank-word
                                  counsel-yank-pop))
             (equal (this-command-keys-vector) (kbd "M-n")))
         (delete-region (point)
                        (point-max)))))

(defun my-ivy-fly-time-travel ()
  (when (memq this-command my-ivy-fly-commands)
    (let* ((kbd (kbd "M-n"))
           (cmd (key-binding kbd))
           (future (and cmd
                        (with-temp-buffer
                          (when (ignore-errors
                                  (call-interactively cmd) t)
                            (buffer-string))))))
      (when future
        (save-excursion
          (insert (propertize (replace-regexp-in-string
                               "\\\\_<" ""
                               (replace-regexp-in-string
                                "\\\\_>" ""
                                future))
                              'face 'shadow)))
        (add-hook 'pre-command-hook 'my-ivy-fly-back-to-present nil t)))))

(add-hook 'minibuffer-setup-hook #'my-ivy-fly-time-travel)
#+end_src

* TRAMP
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref tramp
:END:

TRAMP allows Emacs to transparently access remote files as if they were local files.

** TRAMP

#+begin_src emacs-lisp
(use-package tramp
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Apply the following variable customizations.
  :custom
  <<tramp/custom>>)
#+end_src

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref tramp/custom
:END:

Determine where Emacs creates backups for files edited via TRAMP.
#+begin_src emacs-lisp
(tramp-backup-directory-alist backup-directory-alist "Create TRAMP backups locally.")
#+end_src

** Counsel Tramp

#+begin_src emacs-lisp
(use-package counsel-tramp
  :general
  ("C-x t" #'counsel-tramp))
#+end_src

** Docker Tramp

/Docker Tramp/ provides a TRAMP method for accessing Docker containers.

#+begin_src emacs-lisp
(use-package docker-tramp
  ;; Only load Docker Tramp if the following code evaluates to non-nil.
  :if
  <<docker/if>>

  ;; Load Docker Tramp package after the following packages.
  :after tramp

  ;; Load Docker Tramp eagerly.
  :demand)
#+end_src

* Version Control
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref version-control
:END:

Move files to trash instead of deleting them outright.
#+begin_src emacs-lisp
(setq trash-directory "~/.Trash"
      delete-by-moving-to-trash t)
#+end_src

** Backup Files

Emacs has built-in functionality to create backup files.
By default, such files are created in the same directory as the actual file and simply have a tilde appended to the filename.
This is functional, but results in messy directories.

#+begin_src emacs-lisp
(use-package files
  :straight (:type built-in)

  :custom
  <<files/custom>>)
#+end_src

*** Do Not Prompt to Kill Processes

By default, Emacs asks the user to confirm when terminating a sub-process, such as when exiting a shell.
I do not want to have to confirm.

#+begin_src emacs-lisp :noweb-ref files/custom
(confirm-kill-processes nil)
#+end_src

#+begin_src emacs-lisp :noweb-ref files/custom
(kill-buffer-query-functions '())
#+end_src

** Autorevert

#+begin_src emacs-lisp
(use-package autorevert
  :straight (:type built-in)

  ;; Add the following auto-loading hooks.
  :ghook
  ('pdf-tools-mode-hook #'auto-revert-mode)

  ;; Customize the following variables.
  :custom
  (auto-revert-verbose nil "Do not display messages when buffers are reverted."))
#+end_src

** /VC/

/VC/ is a built-in package that provides an interface for generic version control operations, abstracting over many different version control systems.
The only action performed below is changing the binding of \src_emacs-lisp{vc-revert}.
The new binding is harder to accidentally press and opens up a convenient binding for /Brose at Remote/'s command.

#+begin_src emacs-lisp
(use-package vc
  :straight (:type built-in)

  ;; Load VC eagerly.
  :demand

  ;; Bind the following keys.
  :general
  (:keymaps 'vc-prefix-map
   "U" #'vc-revert
   "u" nil))
#+end_src

** /VC Hooks/

#+begin_src emacs-lisp
(use-package vc-hooks
  :straight (:type built-in)
  :custom
  <<vc-hooks/custom>>)
#+end_src

*** Automatically Visit Sources of Symlinked Files

#+begin_src emacs-lisp :noweb-ref vc-hooks/custom
(vc-follow-symlinks t)
#+end_src

** Diff HL

#+begin_src emacs-lisp
(use-package diff-hl
  ;; Only load this package if the following condition is met.
  :if
  <<diff-hl/if>>

  ;; Load this package eagerly.
  :demand

  ;; Add the following auto-loading hooks.
  :ghook
  <<diff-hl/ghook>>

  ;; Inform the bytecode compiler about the following functions.
  :commands
  (global-diff-hl-mode)

  ;; Evaluate the following code before loading this package.
  :init
  <<diff-hl/init>>

  ;; Evaluate the following code after loading this package.
  :config
  <<diff-hl/config>>)
#+end_src

*** Conditional Loading
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/if
:END:

Diff HL depends on features added in Emacs 24.3.
#+begin_src emacs-lisp
(version<= "24.3" emacs-version)
#+end_src

*** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/ghook
:END:

Enable Diff HL in Dired buffers.
#+begin_src emacs-lisp
('dired-mode-hook #'diff-hl-dired-mode)
#+end_src

Update Diff HL's status when refreshing with modern versions of Magit.
#+begin_src emacs-lisp
('magit-post-refresh-hook #'diff-hl-magit-post-refresh)
#+end_src

*** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/init
:END:

Enable Diff HL's base minor mode globally.
#+begin_src emacs-lisp
(global-diff-hl-mode)
#+end_src

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/config
:END:

Perform Diff HL highlighting on-the-fly.
#+begin_src emacs-lisp
(diff-hl-flydiff-mode)
#+end_src

** Git
*** Git Attributes Mode

#+begin_src emacs-lisp
(use-package gitattributes-mode
  :straight magit)
#+end_src

*** /Magit/

#+begin_src emacs-lisp
(use-package magit
  ;; Load this package if the following code evaluates to non-nil.
  :if
  <<magit/if>>

  ;; Load this package eagerly.
  :demand

  ;; Perform the following customizations.
  :custom
  <<magit/custom>>

  ;; Apply the following keybindings.
  :general
  <<magit/general>>

  ;; Evaluate the following code after loading `magit'.
  :config
  <<magit/config>>)
#+end_src

**** Conditional Loading
:PROPERTIES:
:DESCRIPTION: Only load ~magit~ if this code evaluates to non-~nil~.
:HEADER-ARGS+: :noweb-ref magit/if
:END:

/Magit/ provides an interface for Git.
As such, the package is unusable is worthless if =git= is not in the user's ~PATH~.
#+begin_src emacs-lisp
(executable-find "git")
#+end_src

**** Customize Variables
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref magit/custom
:END:

Set the list of messages Magit should not display.
#+begin_src emacs-lisp
(magit-no-message '("Turning on magit-auto-revert-mode...") "Suppress messages")
#+end_src

Hide the stash and ignored file sections by default in status buffers.
#+begin_src emacs-lisp
(magit-section-initial-visibility-alist
 '((ignored . hide)
   (stashes . hide)
   (untracked . hide)))
#+end_src

Set the sections to be displayed in status buffers.
#+begin_src emacs-lisp
(magit-status-sections-hook
 '(magit-insert-status-headers
   magit-insert-merge-log
   magit-insert-rebase-sequence
   magit-insert-am-sequence
   magit-insert-sequencer-sequence
   magit-insert-bisect-output
   magit-insert-bisect-rest
   magit-insert-bisect-log
   magit-insert-ignored-files
   magit-insert-untracked-files
   magit-insert-unstaged-changes
   magit-insert-staged-changes
   magit-insert-stashes
   magit-insert-unpushed-to-pushremote
   magit-insert-unpushed-to-upstream-or-recent
   magit-insert-unpulled-from-pushremote
   magit-insert-unpulled-from-upstream))
#+end_src

**** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref magit/init
:DESCRIPTION: Code to evaluate before loading Magit.
:END:

Store the usernames used by the current user.
#+begin_src emacs-lisp
(defconst magit-push-usernames '("lafrenierejm")
  "The Git forge usernames whose repos this Emacs user has push access to.")
#+end_src

Store the domains where this user has global Git push access.
#+begin_src emacs-lisp
(defconst magit-push-domains '()
  "The domains where this Emacs user has global Git push access.")
#+end_src

**** Post-Load Execution
:PROPERTIES:
:DESCRIPTION: The code in this section shall be evaluated after ~magit~ has been loaded.
:HEADER-ARGS+: :noweb-ref magit/config
:END:

***** Return After Commit Message

Return to the main Magit window after closing a commit message, regardless of whether that message is committed or aborted.
#+begin_src emacs-lisp
(advice-add 'git-commit-commit :after #'delete-window)
(advice-add 'git-commit-abort :after #'delete-window)
#+end_src

***** Automatically Register Repositories with Projectile

Define a function to perform the registration.
#+begin_src emacs-lisp
(defun magit-lafrenierejm-add-known-project (&rest _)
  "Register the current repository's root with Projectile."
  (interactive)
  (when (and (fboundp #'projectile-add-known-project)
             magit--default-directory)
    (projectile-add-known-project magit--default-directory)))
#+end_src

Add the above function to be run after ~magit-status~.
#+begin_src emacs-lisp
(advice-add
 'magit-status-internal
 :after
 #'magit-lafrenierejm-add-known-project)
#+end_src

***** Comparable Version Number

The function ~magit-version~ provided by Magit does not return a version string that is comparable using Emacs's built-in ~version<~.
However, the response from the function contains a valid semver string before the first hyphen ("-").
#+begin_src emacs-lisp
(defun magit-lafrenierejm-version ()
  "Return Magit's version for use in comparisons."
  (car (split-string (magit-version) "-")))
#+end_src

***** Yank the Current Branch Name

Magit has built-in functions \src_emacs-lisp{magit-copy-section-value} and \src_emacs-lisp{magit-copy-buffer-revision} for placing values on the kill ring.
I often want to refer to the name of the current branch, so I define a counterpart to the above commands that accomplishes this.
#+begin_src emacs-lisp
(defun magit-lafrenierejm-copy-branch-name ()
  "Save the name of the current branch for later use.

Save the section value to the `kill-ring'."
  (interactive)
  (let ((branch-name (magit-get-current-branch)))
    (message "%s" branch-name)
    (kill-new (magit-get-current-branch))))
#+end_src

Alias the above command to remove my username "namespace".
#+begin_src emacs-lisp
(defalias 'magit-copy-branch-name #'magit-lafrenierejm-copy-branch-name)
#+end_src

***** Yank the Current Tag

Magit has built-in functions \src_emacs-lisp{magit-copy-section-value} and \src_emacs-lisp{magit-copy-buffer-revision} for placing values on the kill ring.
I often want to refer to the most recent tag, so I define a counterpart to the above commands that accomplishes this.
#+begin_src emacs-lisp
(defun magit-lafrenierejm-copy-current-tag ()
  "Save the current tag for later use.

Save the tag value to the `kill-ring'."
  (interactive)
  (let ((tag (magit-get-current-tag)))
    (message "%s" tag)
    (kill-new tag)))
#+end_src

Alias the above command to remove my username "namespace".
#+begin_src emacs-lisp
(defalias 'magit-copy-current-tag #'magit-lafrenierejm-copy-current-tag)
#+end_src

**** Keybindings
:PROPERTIES:
:HEADER-ARGS+:
:END:

Use =h= and =l= for horizontal movement in /Magit/ buffers.
#+begin_src emacs-lisp :noweb-ref evil-collection/custom
(evil-collection-magit-want-horizontal-movement t)
#+end_src

Bind keys for /Magit/ buffers.
#+begin_src emacs-lisp :noweb-ref magit/general
(:keymaps 'magit-mode-map
 :states '(evil-collection-magit-state movement normal)
 "/" nil
 "C-d" #'current-buffer-dired
 "C-z" nil
 "yb" #'magit-copy-branch-name
 "yc" #'magit-copy-buffer-revision
 "yt" #'magit-copy-current-tag
 [escape] nil)
#+end_src

**** /Magit Diff/

#+begin_src emacs-lisp
(use-package magit-diff
  :straight magit
  :custom
  (magit-diff-refine-hunk t "Show fine differences for the current diff hunk only."))
#+end_src

*** Forge
From the project's README:
#+BEGIN_QUOTE
Work with Git forges, such as Github and Gitlab, from the comfort of Magit and the rest of Emacs.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package forge
  ;; Load this package after the following packages.
  :after magit

  ;; Load this package eagerly.
  :demand)
#+end_src

*** SSH Agency

#+begin_src emacs-lisp
(use-package ssh-agency
  :after magit

  :demand

  :custom
  (ssh-agency-add-executable (executable-find "ssh-add"))
  (ssh-agency-agent-executable (executable-find "ssh-agent"))
  (ssh-agency-agent-exe-names '("ssh-agent")))
#+end_src

*** Determine Year Added

Define a function to determine when a file was first created.
This is useful when adding determining information.
#+begin_src emacs-lisp
(defun git-lafrenierejm-year-added (filename)
  (interactive "f")
  "Determine the year when FILENAME was added to a Git repository.

If the file has not been added to the repository, use the current year."
  (if-let (((not (string-empty-p filename)))
           (git-output
            (shell-command-to-string
             (format "%s | tail -1 | head -c 4 -z"
                     (s-join " " `("git" "log"
                                   "--diff-filter=A"
                                   "--follow"
                                   "--format=%aI"
                                   "--"
                                   ,filename
                                   ,(format "2>%s" null-device))))))
           ((not (string-empty-p git-output))))
      git-output
    (format-time-string "%Y")))
#+end_src

Alias the above function to remove my username.
#+begin_src emacs-lisp
(defalias 'git-year-added #'git-lafrenierejm-year-added)
#+end_src

*** /Browse at Remote/

Assemble and yank the URL to view the current context in its forge.
#+begin_src emacs-lisp
(use-package browse-at-remote
  ;; Load this package eagerly.
  :demand

  :general
  <<browse-at-remote/general>>

  :custom
  (browse-at-remote-add-line-number-if-no-region-selected
   nil
   "Only include line number when there's an active region."))
#+end_src

**** Bind in /VC/'s Map

Add a keybinding under /VC/'s key prefix to yank the context-dependent URL.
#+begin_src emacs-lisp :noweb-ref browse-at-remote/general
(:keymaps 'vc-prefix-map
 "u" #'browse-at-remote-kill)
#+end_src

** Mercurial (Hg)

*** /Monky/

#+begin_src emacs-lisp
(use-package monky
  :demand)
#+end_src

** /Ghq/

/Ghq/ is an Emacs frontend to the =ghq= command-line tool.
#+begin_src emacs-lisp
(use-package ghq
  :straight (ghq
             :type git
             :host github
             :repo "rcoedo/emacs-ghq"
             :fork "lafrenierejm/emacs-ghq"
             :branch "process-sentinel")

  :if (executable-find "ghq")

  :custom
  (ghq-after-clone-functions (list #'projectile-add-known-project)))
#+end_src

* Completion
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref completion
:END:

** /Compdef/

From [[https://github.com/wurosh/compdef/tree/master][the package's README]]:
#+begin_quote
=compdef= sets backends as a local variable for that specific mode, so you’re always pinging the right ones in the right order.
#+end_quote

#+begin_src emacs-lisp
(use-package compdef
  ;; This needs to be loaded before any completion frameworks, so we load it eagerly.
  :demand)
#+end_src

** /Company/

#+begin_src emacs-lisp
(use-package company
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading.
  :config
  <<company/config>>)
#+end_src

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to be evaluated after Company has been loaded.
:HEADER-ARGS+: :noweb-ref company/config
:END:

Enable ~company-mode~ globally.
#+begin_src emacs-lisp
(global-company-mode)
#+end_src

*** /Company Posframe/

Use child frames for /Company/'s candidate menus.
#+begin_src emacs-lisp
(use-package company-posframe
  :demand
  :after company
  :config
  (company-posframe-mode +1)
  (with-eval-after-load 'desktop
    (push '(company-posframe-mode . nil)
          desktop-minor-mode-table)))
#+end_src

** YASnippet

#+begin_src emacs-lisp
(use-package yasnippet
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<yasnippet/config>>)
#+end_src

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref yasnippet/config
:END:

Enable \src_emacs-lisp{yas-global-mode}.
#+begin_src emacs-lisp
(yas-global-mode 1)
#+end_src

**** Guix Package /emacs-yasnippet-snippets/

Add the snippets from the Guix package /emacs-yasnippet-snippets/.
#+begin_src emacs-lisp
(with-eval-after-load 'guix-profiles
  (when-let* (guix-user-profile
              (emacs-yasnippet-snippets-dir (expand-file-name
                                             "share/emacs/yasnippet-snippets"
                                             guix-user-profile))
              ((file-accessible-directory-p emacs-yasnippet-snippets-dir)))
    (add-to-list 'yas-snippet-dirs emacs-yasnippet-snippets-dir)))
#+end_src

** Ivy YASnippet

#+begin_src emacs-lisp
(use-package ivy-yasnippet
  ;; Load this package after the following packages.
  :after (ivy yasnippet)

  ;; Load this package eagerly.
  :demand)
#+end_src

* System Management
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref system
:END:

** Containers
*** Docker
**** /Docker/

#+begin_src emacs-lisp
(use-package docker
  ;; Only load Docker if the following code evaluates to non-nil.
  :if
  <<docker/if>>

  ;; Add the following auto-loading keybindings.
  :general
  ("C-c d" #'docker))
#+end_src

***** Conditional Loading
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref docker/if
:END:

/Docker/'s features are only usable if the =docker= command is present in =$PATH=.
#+begin_src emacs-lisp
(executable-find "docker")
#+end_src

**** /Dockerfile Mode/

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :mode
  ("Dockerfile\\'" . dockerfile-mode)

  :config
  (put 'dockerfile-image-name 'safe-local-variable #'stringp))
#+END_SRC

** Desktop Environment

#+begin_src emacs-lisp
(use-package desktop-environment
  :if (eq system-type 'gnu/linux)

  :general
  ("<XF86MonBrightnessUp>" #'desktop-environment-brightness-increment
   "<XF86MonBrightnessDown>" #'desktop-environment-brightness-decrement
   "<XF86AudioRaiseVolume>" #'desktop-environment-volume-increment
   "<XF86AudioLowerVolume>" #'desktop-environment-volume-decrement
   "<XF86AudioMute>" #'desktop-environment-toggle-mute
   "<XF86AudioMicMute>" #'desktop-environment-toggle-microphone-mute
   "S-<print>" #'desktop-environment-screenshot-part
   "<print>" #'desktop-environment-screenshot
   "C-s-l" #'desktop-environment-lock-screen
   "<XF86WLAN>" #'desktop-environment-toggle-wifi
   "<XF86Bluetooth>" #'desktop-environment-toggle-bluetooth))
#+end_src

** SystemD
*** /journalctl Mode/

#+begin_src emacs-lisp
(use-package journalctl-mode)
#+end_src

** Fix "Too many open files" Error

Ben Simon explains the problem in [[https://www.blogbyben.com/2022/05/gotcha-emacs-on-mac-os-too-many-files.html][this blog post]].
The fix is to run the below command when the error is encountered.
The command is copied directly from GNU Emacs's source code and is therefore copyright (c) the FSF.
See the relevant commit [[https://github.com/emacs-mirror/emacs/commit/a232821c5127d5ebf862dc229f14a35dfef78e40][here]].

#+begin_src emacs-lisp
(defun file-notify-rm-all-watches ()
  "Remove all existing file notification watches from Emacs."
  (interactive)
  (maphash
   (lambda (key _value)
     (file-notify-rm-watch key))
   file-notify-descriptors))
#+end_src

* Diff
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff
:END:

** Ediff

#+begin_src emacs-lisp
(use-package ediff
  :straight (:type built-in)

  ;; Evaluate the following code after loading this package.
  :custom
  <<ediff/custom>>)
#+end_src

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ediff/custom
:END:

Determine how Ediff windows are setup.
#+begin_src emacs-lisp
(ediff-window-setup-function
 #'ediff-setup-windows-plain
 "Use a single frame for all buffers including the control panel.")
#+end_src

** Whitespace

*** WS Butler

From the package's description:
#+BEGIN_QUOTE
- Only lines touched get trimmed.
  If the white space at end of buffer is changed, then blank lines at the end of buffer are truncated respecting require-final-newline.
- Trimming only happens when saving.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package ws-butler
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<ws-butler/config>>)
#+end_src

**** Post-Load Evluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ws-butler/config
:DESCRIPTION: Code to be evaluated after loading ~ws-butler~.
:END:

Enable ws-butler globally.

#+begin_src emacs-lisp
(ws-butler-global-mode)
#+end_src

* Directories
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref directories
:END:

Emacs is a robust tool for operating on directory objects.
The built-in package provided for doing so is /Dired/.
Most other directory-centric packages provide functionality on top of /Dired/.

** Dired

#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)

  ;; Load Dired eagerly.
  :demand

  ;; Inform the bytecode compiler of the following interactive functions.
  :commands dired-here

  ;; Add the following auto-loading keybindings.
  :general
  (:states '(motion normal visual)
   "C-d" #'dired-here)
  (:keymaps 'dired-mode-map
   "G" #'evil-goto-line)
  (:keymaps 'dired-mode-map
   :states '(motion normal visual)
   "g g" #'evil-goto-first-line)

  ;; Perform the following variable customizations.
  :custom
  (dired-auto-revert-buffer t "Automatically revert Dired buffers on visit.")
  (dired-listing-switches
   (string-join
    '("-l" ; use a long listing format
      "-A" ; do not list implied . and ..
      "-h" ; with -l and -s, print sizes like 1K 234M 2G etc.
      "-v" ; natural sort of (version) numbers within text
      )
    " "))
  (dired-dwim-target t)
  (dired-vc-rename-file t "Register renames in version control systems")

  ;; Evaluate the following code after loading Dired.
  :config
  <<dired/config>>)
#+end_src

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref dired/config
:END:

Define a function to create an empty file.
This behaves as a subset of =touch=;
it will not update the modified time of existing files.
#+begin_src emacs-lisp
(defun dired-lafrenierejm-touch (filename)
  "Create a new, empty file."
  (interactive "FFile to create: ")
  (let (filename-expanded (expand-file-name filename))
    (if (file-exists-p filename-expanded)
        (error "File '%s' already exists" filename-expanded)
      (with-temp-buffer (write-file filename-expanded)))))
#+end_src

Define a function to open the current directory in a Dired buffer.
#+begin_src emacs-lisp
(defun dired-here ()
  "\"Edit\" the current directory."
  (interactive)
  (dired default-directory))
#+end_src

** Writable Dired

#+begin_src emacs-lisp
(use-package wdired
  :straight (:type built-in)

  :custom
  (wdired-allow-to-change-permissions t))
#+end_src

** Dired Collapse

/Dired Collapse/ provides a minor mode \src_emacs-lisp{dired-collapse-mode} that provides visibility into directories with a single child.
This visibility is provided recursively, so the view provided will extend arbitrarily deep provided each directory in the view has exactly one child.

#+begin_src emacs-lisp
(use-package dired-collapse
  ;; Load Dired Collapse after the following packages.
  :after dired

  ;; Add the following auto-loading hooks.
  :ghook
  ('dired-mode-hook #'dired-collapse-mode))
#+end_src

** Dired Narrow

#+begin_src emacs-lisp
(use-package dired-narrow
  ;; Inform the bytecode compiler of the following interactive functions.
  :commands dired-narrow

  ;; Add the following auto-loading keybindings.
  :general
  (:keymaps 'dired-mode-map
   "C-x n n" #'dired-narrow))
#+end_src

** /Dired Subtree/

#+begin_src emacs-lisp
(use-package dired-subtree
  :after dired

  :demand

  :config
  <<dired-subtree/config>>)
#+end_src

*** Set \src_emacs-lisp{default-directory} Based on \src_emacs-lisp{point}'s'
:PROPERTIES:
:COPYRIGHT_AUTHOR: Göktuğ Kayaalp
:COPYRIGHT_EMAIL: [[mailto:self@gkayaalp.com][self@gkayaalp.com]]
:COPYRIGHT_URL: https://old.reddit.com/r/emacs/comments/fs93hk/weekly_tipstricketc_thread/fmfesda/
:HEADER-ARGS+: :noweb-ref dired-subtree/config
:END:

Posted by Göktuğ Kayaalp (u/gkayaalp) in a "Weekly tips/trick/etc/" thread on the r/emacs Subreddit.
#+begin_quote
I really like =dired-subtree.el=, but I don't like that when you try to visit a new file or run a command thinking ~default-directory~ will be relative to where the point is at, but it's still the toplevel directory the dired buffer is visiting.
This little advice makes sure that ~default-directory~ is the parent directory of the file or directory under point.
#+end_quote

#+begin_src emacs-lisp
(defun gk-dired-update-default-directory-from-current-line (ret)
  "Set ‘default-directory’ to dirname of entity under point.

Useful when using dired-subtree."
  (ignore ret)
  (ignore-errors
    (setq-local default-directory
                (file-name-directory (dired-get-file-for-visit)))))

(advice-add 'dired-previous-line :after #'gk-dired-update-default-directory-from-current-line)
(advice-add 'dired-next-line :after #'gk-dired-update-default-directory-from-current-line)
#+end_src

** /EditorConfig/

The /EditoConfig/ package provides support for [[https://editorconfig.org][EditorConfig]].
From the project's website:
#+begin_quote
EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs.
The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles.
EditorConfig files are easily readable and they work nicely with version control systems.
#+end_quote

#+begin_src emacs-lisp
(use-package editorconfig
  :demand
  :config
  (editorconfig-mode 1))
#+end_src

** /Cascading Dir-Locals/

From the [[https://github.com/fritzgrabo/cascading-dir-locals][project's home page]]:
#+begin_quote
Provides a global minor mode that changes how Emacs handles the lookup of applicable dir-locals files (.dir-locals.el):
instead of starting at the directory of the visited file and moving up the directory tree only until a first dir-locals file is found, collect and apply all (!) dir-locals files found from the current directory up to the root one.

Values specified in files nearer to the current directory take precedence over values in files farther away from it.

You might want to use this to set dir-local variables that apply to all of your projects only once, then override or add variables on a per-project basis.
#+end_quote

#+begin_src emacs-lisp
(use-package cascading-dir-locals
  :straight (:host github :repo "fritzgrabo/cascading-dir-locals")
  :demand
  :config
  (cascading-dir-locals-mode 1)
  (defun cascading-dir-locals-invalidate-cache (&rest rest)
    "Invalidate `dir-locals-directory-cache'."
    (setq dir-locals-directory-cache nil))
  (general-advice-add
   'add-dir-local-variable
   :after
   #'cascading-dir-locals-invalidate-cache))
#+end_src

** Direnv /Envrc/

#+begin_src emacs-lisp
(use-package envrc
  :if (executable-find "direnv")
  :demand
  :ghook
  ('after-init-hook #'envrc-global-mode))
#+end_src

** /Shadowenv/

#+begin_src emacs-lisp
(use-package shadowenv
  :if (executable-find "shadowenv")
  :demand
  :ghook
  ('after-init-hook #'shadowenv-global-mode))
#+end_src

* Command Interpretation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref command-interpretation
:END:

** Comint

#+begin_src emacs-lisp
(use-package comint
  :straight (:type built-in)

  :general
  <<comint/general>>)
#+end_src

*** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref comint/general
:END:

Use =C-l= to clear the current buffer.
#+begin_src emacs-lisp
(:keymaps 'comint-mode-map
 :states '(movement normal)
 "C-l" #'comint-clear-buffer)
#+end_src

** UNIX shell

*** /Shell/

#+begin_src emacs-lisp
(use-package shell
  :straight (:type built-in)

  :gfhook
  ('shell-mode-hook #'shell-disable-command-echo)
  ('shell-mode-hook #'shell-indicate-empty-lines)

  :config
  (defun shell-disable-command-echo ()
    "Turn off command echoing in the current buffer."
    (setq comint-process-echoes t))
  (defun shell-indicate-empty-lines ()
    "Visually indicate empty screen lines after the buffer end."
    (setq indicate-empty-lines t)))
#+end_src

** Emacs Shell
*** Esh Mode
#+begin_src emacs-lisp
(use-package esh-mode
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  :preface
  <<esh-mode/preface>>

  :config
  <<esh-mode/config>>)
#+end_src

**** Post-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref esh-mode/config
:END:

***** Define Eshell-Specific ~beginning-of-line-maybe~
The ~use-package~ declaration of /Evil/ includes a post-load definition of ~evil-beginning-of-line-maybe~.
That function acts as a do-what-I-mean alternative to the built-in ~beginning-of-line~ by incrementally jumping to the beginning of text sections within a line.

~esh-mode-beginning-of-line-maybe~ moves ~point~ toward the beginning of the current line incrementally by semantic region.
1. If point is in the text of a command, point will be moved to the beginning of the command.
2. If the current line has leading whitespace and point is somewhere after that whitespace, point will be moved to the first non-whitespace character.
3. Point will be moved to the beginning of the line.

#+begin_src emacs-lisp
(defun esh-mode-beginning-of-line-maybe ()
  "Move point to the start of the command beginning of the line."
  (interactive)
  (let ((old-point (point)))   ; Get current position.
    (eshell-bol)               ; Move to beginning of current command.
    (when (or (<= old-point (point))
              (= (point-at-bol) (point)))
      (back-to-indentation) ; Go to the first significant column
      ;; If already at or before the first significant column...
      (when (<= old-point (point))
        ;; Then go to the beginning of the line.
        (beginning-of-line)))))
#+end_src

***** Narrow to Command

Narrow the buffer to the context ~point~ is currently in:
- command output :: narrow to the preceding command and the current output
- last prompt/command :: do nothing
- other prompt/command :: narrow to the prompt, command, and the command's output

#+begin_src emacs-lisp
(defun esh-mode-narrow-to-command ()
  "Make text outside the current command invisible.

- If `point' is in the last prompt or last command, do nothing.
- If `point' is in command output, narrow to the output and the corresponding
  prompt and command.
- if `point' is in a prompt or command that's not the last, narrow to that
  prompt, command, and the corresponding output."
  (interactive)
  (let ((orig (point))
        (line-orig (line-number-at-pos (point)))
        (line-later-prompt (progn (eshell-next-prompt 2)
                                  (line-number-at-pos (point)))))
    ;; Restore original position.
    (goto-char orig)
    ;; If not in the last command...
    (if (not (= line-orig line-later-prompt))
        (let* ((command-beg (progn (eshell-bol) (point)))
               (line-beg (progn (beginning-of-line) (point)))
               (start (cond
                       ;; If not in a command...
                       ((= command-beg line-beg)
                        (eshell-previous-prompt 1)
                        (beginning-of-line)
                        (point))
                       ;; Else in a command...
                       (t
                        line-beg)))
               (end (progn
                      (eshell-next-prompt 2) ; next prompt
                      (previous-line 1) ; up one line
                      (end-of-line) ; end of line
                      (point))))
          (narrow-to-region start end)))))
#+end_src

***** Delete Whole Line

****** Define the Function

#+begin_src emacs-lisp
(defun eshell-kill-whole-line ()
  "Kill the whole Eshell buffer line."
  (interactive)
  (kill-region (progn (eshell-bol) (point)) (line-end-position)))
#+end_src

****** Define an Evil Operator
:PROPERTIES:
:COPYRIGHT_AUTHOR: Alexander Shukaev
:COPYRIGHT_YEAR: 2015
:COPYRIGHT_URL: https://emacs.stackexchange.com/a/14958
:END:


.emacs.d/init.el: ‘evil-called-interactively-p’ is an obsolete macro (as of Git commit 222b791); please use (called-interactively-p ’any) instead.

#+begin_src emacs-lisp
(evil-define-operator eshell-delete  (beg end type register yank-handler)
  "Delete text from BEG to END with TYPE.

Save in REGISTER or in the kill-ring with YANK-HANDLER."
  (interactive "<R><x><y>")
  (if (eq type 'line)
      (progn
        (unless register
          (let ((text (filter-buffer-substring beg end)))
            (unless (string-match-p "\n" text)
              (evil-set-register ?- text))))
        (let ((evil-was-yanked-without-register nil))
          (evil-yank beg end type register yank-handler))
        (dotimes (var (count-lines beg end))
          (eshell-kill-whole-line)))
    (evil-delete beg end type register yank-handler))
  (when (and (called-interactively-p 'any)
             (eq type 'line))
    (evil-first-non-blank)))
#+end_src

*** Em Hist

#+begin_src emacs-lisp
(use-package em-hist
  :straight (:type built-in)

  ;; Load eagerly.
  :demand

  ;; Customize the following variables.
  :custom
  <<em-hist/custom>>)
#+end_src

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-hist/custom
:END:

Determine whether duplicates are skipped when traversing command history.
#+begin_src emacs-lisp
(eshell-hist-ignoredups t "Skip duplicates when traversing command history.")
#+end_src

Determine how many commands are saved in history.
The default is 128.
#+begin_src emacs-lisp
(eshell-history-size 10000)
#+end_src

*** Em Dirs
#+begin_src emacs-lisp
(use-package em-dirs
  :straight (:type built-in)

  :demand

  :config
  <<em-dirs/config>>

  :commands
  (em-dirs-name-buffer))
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-dirs/config
:END:

***** Return Path Relative to Project Root
#+begin_src emacs-lisp
(defun em-dirs-pwd-relative-to-project (directory)
  "Print DIRECTORY relative to its Projectile root, if any.

If DIRECTORY is in a project as determined by Projectile, return DIRECTORY's
path starting starting at the project's root.

If DIRECTORY is _not_ in a project, return the abbreviated form of DIRECTORY's
path."
  (s-chop-suffix
   "/"
   (if-let (((fboundp #'projectile-project-name))
            ((fboundp #'projectile-project-root))
            (project-root (projectile-project-root directory))
            (project-name (projectile-project-name project-root)))
       ;; If in a project:
       (if (string=
            (file-name-as-directory (expand-file-name directory))
            project-root)
           ;; If at a project's root: use the project's name
           project-name
         ;; Else not at project's root: use path starting with project's root
         (concat (file-name-as-directory project-name)
                 (file-relative-name
                  (expand-file-name directory)
                  project-root)))
     ;; Else not in project: use abbreviated path
     (abbreviate-file-name directory))))
#+end_src

***** Abbreviate Path Elements
Printing the path to the current directory in the shell prompt helps me keep track of the context.
However, if the path is long this can result in unwieldy prompts.
The following functions can be used to abbreviate a path by shortening each element in the path to that element's first non-period character;
only the last directory in the path is shown in full.

#+begin_src emacs-lisp
(defun em-dirs-abbreviate-dirname (filename)
  (cond
   ((string-empty-p filename)
    "")
   ((string= (substring filename 0 1) ".")
    (substring filename 0 2))
   (t
    (substring filename 0 1))))
#+end_src

#+begin_src emacs-lisp
(defun em-dirs-abbreviate-path (path)
  "Abbreviate each element in PATH except for the last.

Abbreviated path elements are represented by their first non-period
character. For example, the path \"/home/user/.config/curdir\" will become
\"/h/u/.c/curdir\"."
  (let* ((split-path (split-string path "/")))
    (if (< (length split-path) 2)
        (or (car split-path) "")
      (concat
       (file-name-as-directory
        (cl-reduce
         (lambda (directory filename)
           (concat (if (string-empty-p directory)
                       "/"
                     (file-name-as-directory directory))
                   filename))
         (mapcar
          #'em-dirs-abbreviate-dirname
          split-path)
         :end (- (length split-path) 1)))
       (car (last split-path)))
      path)))
#+end_src

***** Create Eshell Buffer Names
#+begin_src emacs-lisp
(defun em-dirs-name-buffer (directory &optional process-name)
  "Create a name for an Eshell buffer in DIRECTORY."
  (concat "*eshell "
          (em-dirs-pwd-relative-to-project directory)
          (when process-name
            (concat " <" process-name ">"))
          "*"))
#+end_src

***** Prefer Changing Buffers to Changing Directories
Redefine ~eshell/cd~ to prefer switching to an Eshell buffer in the new directory (if such a buffer exists) over changing the directory of the buffer where ~eshell/cd~ was called.
Whether or not an Eshell buffer exists at the specified location is determined by the name of existing Eshell buffers.

The following code is derived directly from code in GNU Emacs's Em Dirs and Files packages.
As such, it is licensed under GPLv3.

#+begin_src emacs-lisp
(defun eshell/cd (&rest args)
  "Alias to extend the behavior of `cd'.

If an Eshell buffer already exists at the target directory, switch to that
buffer.  Otherwise, change the working directory of the current buffer to the
target directory then rename the current buffer to reflect its new working
directory.

The presence of an existing Eshell buffer at the new location is determined by
comparing the name of buffers to the result of `em-dirs-name-buffer'."
  (setq args (eshell-flatten-list args))
  (let ((path (car args))
        (subpath (car (cdr args)))
        (case-fold-search (eshell-under-windows-p))
        handled)
    (if (numberp path)
        (setq path (number-to-string path)))
    (if (numberp subpath)
        (setq subpath (number-to-string subpath)))
    (cond
     (subpath
      (let ((curdir (eshell/pwd)))
        (if (string-match path curdir)
            (setq path (replace-match subpath nil nil curdir))
          (error "Path substring `%s' not found" path))))
     ((and path (string-match "^-\\([0-9]*\\)$" path))
      (let ((index (match-string 1 path)))
        (setq path
              (ring-remove eshell-last-dir-ring
                           (if index
                               (string-to-number index)
                             0)))))
     ((and path (string-match "^=\\(.*\\)$" path))
      (let ((oldpath (eshell-find-previous-directory
                      (match-string 1 path))))
        (if oldpath
            (setq path oldpath)
          (let ((len (ring-length eshell-last-dir-ring))
                (index 0))
            (if (= len 0)
                (error "Directory ring empty"))
            (eshell-init-print-buffer)
            (while (< index len)
              (eshell-buffered-print
               (concat (number-to-string index) ": "
                       (ring-ref eshell-last-dir-ring index) "\n"))
              (setq index (1+ index)))
            (eshell-flush)
            (setq handled t)))))
     (path
      (setq path (eshell-expand-multiple-dots path))))
    (unless handled
      (let* ((cd-path (or (parse-colon-path (getenv "CDPATH"))
                          (list "./")))
             (curdir (eshell/pwd))
             (newdir (expand-file-name (file-name-as-directory (or path "~"))))
             (newname (em-dirs-name-buffer newdir)))
        (unless (equal curdir newdir)
          (eshell-add-to-dir-ring curdir))
        ;; If an Eshell buffer already exists in the new directory...
        (if-let ((newbuf (get-buffer newname)))
            ;; Then switch to the existing Eshell buffer.
            (switch-to-buffer newbuf)
          ;; Else change to the new directory.
          (let ((result (cd newdir)))
            ;; Change the buffer's name.
            (rename-buffer newname)
            ;; If `eshell-cd-shows-directory' is non-nil...
            (when eshell-cd-shows-directory
              ;; Then print the new directory.
              (eshell-printn result))))
        (run-hooks 'eshell-directory-change-hook)
        (if eshell-list-files-after-cd
            ;; Let-bind eshell-last-command around this?
            (eshell-plain-command "ls" (cdr args)))
        nil))))
    #+end_src

*** Eshell
#+begin_src emacs-lisp
(use-package eshell
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after (:all evil ivy em-dirs em-hist)

  ;; Inform the bytecode compiler of the following functions.
  :commands
  (eshell-add-visual-commands
   esh-mode-beginning-of-line-maybe
   eshell-find-eshell
   eshell-find-eshell-here
   eshell-prompt)

  ;; Add the following keybindings.
  :general
  <<eshell/general>>

  ;; Add the following non-autoloading hooks.
  :gfhook
  <<eshell/gfhook>>

  ;; Customize the following variables.
  :custom
  <<eshell/custom>>

  ;; Execute the following code before loading this package.
  :init
  <<eshell/init>>

  ;; Execute the following code after loading this package.
  :config
  <<eshell/config>>)
#+end_src

**** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/general
:END:

Map the opening an Eshell buffer to =C-x z=.
This keybinding mirrors the defaults for ~find-file~ and ~dired~.

#+begin_src emacs-lisp
("C-x z" #'eshell-find-eshell)
#+end_src

Map ~eshell-find-eshell-here~ to =C-z=.
This imitates the behavior of *NIX terminal applications.
In most terminal applications, =C-z= is the key combination to suspend the current process which usually results in the user being returned to their shell.

#+begin_src emacs-lisp
("C-z" #'eshell-find-eshell-here)
#+end_src

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/gfhook
:END:

Build the list of commands to be run in Term mode buffers.

#+begin_src emacs-lisp
(nil #'eshell-add-visual-commands)
#+end_src

Bind keys.
#+begin_src emacs-lisp
(nil #'eshell-define-keys)
#+end_src

**** Customize Variables
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/custom
:END:

#+begin_src emacs-lisp
(eshell-prefer-lisp-functions nil "Prefer external commands to Lisp functions.")
#+end_src

#+begin_src emacs-lisp
(eshell-prefer-lisp-variables nil "Prefer environment variables to Lisp variables.")
#+end_src

#+begin_src emacs-lisp
(eshell-prompt-function #'eshell-prompt)
#+end_src

**** Pre-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/init
:END:

***** Eshell Prompt
#+begin_src emacs-lisp
(defun eshell-prompt ()
  "Prefix \"$USER@$(hostname):\" if on remote host."
  (concat
   (format-time-string
    (concat esh-mode-prompt-timestamp-format-string " "))
   (if (file-remote-p default-directory 'host)
       (with-parsed-tramp-file-name default-directory nil
         (concat
          (when user
            (concat user "@"))
          host ":"
          localname))
     (em-dirs-abbreviate-path
      (em-dirs-pwd-relative-to-project
       (expand-file-name default-directory))))
   (if (= (user-uid) 0)
       " # "
     " $ ")))
#+end_src

***** Set =$PAGER=
Because Eshell runs entirely within an Emacs buffer, Eshell does not need an external pager.
Instead, text can be dumped directly into the buffer.
This is accomplished by setting ~PAGER~ to ~cat~.

#+begin_src emacs-lisp
(setenv "PAGER" "cat")
#+end_src

***** Use Magit for Some Git Commands
The code in this section is copyright Gergely Nagy [[mailto:algernon@bonehunter.rulez.org][<algernon@bonehunter.rulez.org>]] and shared under GPLv3.

#+begin_src emacs-lisp
(with-eval-after-load 'magit
  (defun eshell/git (command &rest args)
    (pcase command
      ;; Use magit's log.
      ("log" (apply #'algernon/git-log args))
      ;; Use magit's status.
      ("status" (progn
                  (magit-status)
                  (eshell/echo)))
      ;; Run all other commands directly in `git'.
      (_ (let ((command (s-join " " (append (list "git" command) args))))
           (message command)
           (shell-command-to-string command))))))
#+end_src

Run ~magit-log~ after determining if the argument to ~git log~ was a file or branch.

#+begin_src emacs-lisp
(with-eval-after-load 'magit
  (defun algernon/git-log (&rest args)
    (let* ((branch-or-file (car args))
           (file-list (if (and branch-or-file (f-file-p branch-or-file))
                          args
                        (cdr args)))
           (branch (if (and branch-or-file (f-file-p branch-or-file))
                       "HEAD"
                     branch-or-file)))
      (message branch-or-file)
      (if branch-or-file
          (magit-log (list branch)
                     '()
                     (mapcar
                      (lambda (f) (concat (file-name-as-directory (eshell/pwd)) f))
                      file-list))
        (magit-log-head)))
    (eshell/echo)))
#+end_src

**** Post-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/config
:END:

***** "Visual" Commands
Run the following commands in a =term= buffer:
#+NAME: visual-commands
- alsamixer
- ssh
- top
- tail

#+begin_src emacs-lisp
(defun eshell-add-visual-commands ()
  "Add commands to `eshell-visual-commands'."
  (let ((commands (list "alsamixer" "ssh" "top" "tail")))
    (dolist (command commands)
      (add-to-list 'eshell-visual-commands command))))
#+end_src

***** Custom Functions
****** Open Eshell in a Given Directory
Open or switch to an Eshell buffer in a given directory.

#+begin_src emacs-lisp
(defun eshell-find-eshell (directory)
  "Open Eshell in DIRECTORY.

If an Eshell instance for the directory already exists, switch to it.  If no
such instance exists, start a new instance whose name includes the directory."
  (interactive "DOpen Eshell in: ")
  (let* ((eshell-buffer-name (em-dirs-name-buffer directory))
         (buffer (get-buffer-create eshell-buffer-name)))
    (pop-to-buffer-same-window buffer)
    (cd directory)
    (unless (derived-mode-p 'eshell-mode)
      (eshell-mode))
    buffer))
#+end_src

****** Open Eshell in the Current Directory

Define a function to open an Eshell instance in the current directory.
If an Eshell instance already exists in that directory, switch to its buffer.

#+begin_src emacs-lisp
(defun eshell-find-eshell-here ()
  "Open Eshell in the current working directory.

If an Eshell instance for the directory already exists, switch to it. If no such
instance exists, start a new instance whose name includes the directory."
  (interactive)
  (let ((cwd (abbreviate-file-name (if (buffer-file-name)
                                       (file-name-directory (buffer-file-name))
                                     default-directory))))
    (eshell-find-eshell cwd)))
    #+end_src

****** "Background" the Current Process

If a long-running process is started from an Eshell prompt without explicitly backgrounding the process, that process will block any further input to the prompt.
Because having access to long-running processes' stdout and stderr is useful, there is a need for an interactive function that can
1. preserve the buffer belonging to that long-running process;
2. rename the buffer belonging to the process; and
3. open a new Eshell buffer in the same directory.


#+begin_src emacs-lisp
(defun eshell/background-process-maybe ()
  "Rename the Eshell BUFFER with its process and reopen the directory."
  (interactive)
  (when-let ((path default-directory)
             (process (get-buffer-process (current-buffer)))
             (process-name (process-name process)))
    (rename-buffer (em-dirs-name-buffer path process-name))
    (eshell-find-eshell path)))
#+end_src

UNIX shells use the chord =C-z= to background the current process.

#+begin_src emacs-lisp
(defun eshell-bind-background-process-maybe ()
  "Add a keybinding for `eshell/background-process-maybe'."
  (general-define-key
   :keymaps 'eshell-mode-map
   "C-z" #'eshell/background-process-maybe))
#+end_src

****** Clear Buffer

#+begin_src emacs-lisp
(defun eshell/clear-scrollback-keep-input ()
  "Clear the scrollback content of the eshell window but keep any current input."
  (interactive)
  (let ((input (eshell-get-old-input)))
    (eshell/clear-scrollback)
    (eshell-emit-prompt)
    (insert input)))
#+end_src

***** Keybindings

Add the following keybindings:
- =d= :: custom Evil deletion operator
- =C-l= :: clear the buffer's scrollback
- =C-x n c= :: narrow to the current command
- =C-z= :: "background" the current process

#+begin_src emacs-lisp
(defun eshell-define-keys ()
  "Define keys for eshell."
  (with-eval-after-load 'general
    (general-define-key
     :keymaps 'eshell-mode-map
     "C-l" #'eshell/clear-scrollback-keep-input
     "C-x n c" #'esh-mode-narrow-to-command
     "C-z" #'eshell/background-process-maybe)
    (general-define-key
     :keymaps 'eshell-mode-map
     :states '(movement normal visual)
     "d" #'eshell-delete)
    (general-define-key
     :keymaps 'eshell-mode-map
     :states 'insert
     "C-r" #'counsel-esh-history)))
#+end_src

*** Esh Module

From the package group's docstring:
#+BEGIN_QUOTE
The ~eshell-module~ group is for Eshell extension modules, which provide optional behavior which the user can enable or disable by customizing the variable ~eshell-modules-list~.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package esh-module
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Customize the following variables.
  :custom
  <<esh-module/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<esh-module/config>>)
#+end_src

**** Post-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref esh-module/config
:END:

Disable the greeting banner.

#+begin_src emacs-lisp
(setq eshell-modules-list (delq 'eshell-banner eshell-modules-list))
#+end_src

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref esh-module/custom
:END:

Determine whether input causes window to scroll.
#+begin_src emacs-lisp
(eshell-scroll-to-bottom-on-input
 'this
 "On input, scroll the selected Eshell window to the bottom.")
#+end_src

*** /Em Alias/

#+begin_src emacs-lisp
(use-package em-alias
  :straight (:type built-in)

  :after (:all esh-module)

  :config
  (setq eshell-aliases-file (expand-file-name "eshell/alias" user-emacs-directory)))
#+end_src

*** /Em Prompt/

#+begin_src emacs-lisp
(use-package em-prompt
  :straight (:type built-in)

  :demand

  :preface
  <<em-prompt/preface>>

  :config
  <<em-prompt/config>>)
#+end_src

***** Timestamp
:PROPERTIES:
:DESCRIPTION: Before sending input, update the current prompt with a timestamp.
:END:

A common practice among users of command line interface (CLI) shells is to include timestamps in their shells' prompts.

In Bash, for example, timestamping one's prompt is frequently accomplished by using the ~date~ command as part of the prompt variable.
For example, the prompt src_sh[:exports code]{PS1="(\$date +%H:%M:%S) $"} would result in a prompt such as =21:43:41 $=.

I find the information by such a prompt to be misleading, however.

****** The Problem

My motivation for timestamping my prompts was to be able to easily answer the question, "When did I run this command?"
But rather than providing context for when the corresponding command was submitted, most =PS1=-inserted timestamps actually indicate when the /previous/ command finished executing.

Answering the question about when an arbitrary command \(c_n\) was submitted, then, involves
1. ignoring the timestamp \(t_n\) that is next to \(c_n\);
2. scrolling down to where the next command \(c_{n+1}\) was entered;
3. removing the timestamp \(t_{n+1}\) that is next to \(c_{n+1}\) from the context conferred upon it by its proximity to \(c_{n+1}\); and
4. mentally linking \(t_{n+1}\) back to \(c_n\).

Clearly, the task is not so complicated as to be impossible.
It is far less efficient and more error-prone than it could be, though.
That inefficiency results from requiring the user to
- consciously splitting then re-pairing timestamps and
- visually --- and, if scrolling is required, phsyically --- navigate between two prompts.


****** The Solution

The primary difficulty in establishing accurate timestamps is that doing so requires modifying the prompt text /after/ its input has been sent.
Some shells have workaround for this, such as Zsh's ~preexec~.
Rather than implementing such a function for Eshell, we can instead take advantage of the fact that Eshell is written in Emacs Lisp and outputs directly to an Emacs buffer.

******* Timestamp Format

Define the format of the timestamp to prefix prompts with.
By default, this follows ISO 8601.
#+NAME: esh-mode-prompt-timestamp-format-string
#+begin_src emacs-lisp :noweb-ref esh-mode/preface
(defcustom esh-mode-prompt-timestamp-format-string
  "%FT%T%z"
  "The format-string used for Eshell prompts' timestamps.

See `help format-time-string' for the definition of the constructs.
The default value follows ISO 8601."
  :type '(string))
#+end_src

******* Timestamp Regex

Define the regexp to match the result of the above format string.
#+NAME: esh-mode-prompt-timestamp-regexp
#+begin_src emacs-lisp :noweb-ref em-prompt/preface
(defcustom esh-mode-prompt-timestamp-regexp
  (rx
   (repeat 4 digit) ?- (repeat 2 digit) ?- (repeat 2 digit)
   ?T (repeat 2 digit) (repeat 2 (and ?: (repeat 2 digit)))
   (or ?- ?+) (repeat 4 digit))
  "A regular expression that matches `esh-mode-prompt-timestamp-format-string'."
  :type '(regexp))
#+end_src

******* Update Prompts with Timestamps

Define a function to update the most recent prompt's timestamp.
#+begin_src emacs-lisp :noweb-ref em-prompt/config
(defun esh-mode-timestamp-prompt ()
  "Update the timestamp at the beginning of the current prompt."
  (interactive)
  (let ((cur-pos (point)))
    ;; Move to the end of the buffer.
    (goto-char (point-max))
    ;; Move POINT to the end of the previous prompt, then to end of the next prompt.
    ;; This handles cases of multi-line input and ensures POINT is at the most recent prompt.
    (eshell-previous-prompt 1)
    (eshell-next-prompt 1)
    ;; Move POINT to the beginning of the line.
    (forward-line 0)
    (let ((inhibit-read-only t)
          (prompt-properties
           (list 'font-lock-face 'eshell-prompt
                 'font-sticky '(font-lock-face 'read-only)
                 'read-only t
                 'rear-nonsticky '(font-lock-face read-only))))
      ;; Remove the existing timestamp.
      (when (re-search-forward esh-mode-prompt-timestamp-regexp)
        (replace-match ""))
      ;; Insert the timestamp, propertized to match the rest of the prompt.
      (insert (apply #'propertize
                     (format-time-string esh-mode-prompt-timestamp-format-string)
                     prompt-properties)))
    ;; Restore POINT to its original location.
    (goto-char cur-pos)))
#+end_src
Where ~esh-mode-prompt-timestamp-format-string~ and ~esh-mode-prompt-timestamp-regexp~ are defined in ref:esh-mode-prompt-timestamp-format-string and ref:esh-mode-prompt-timestamp-regexp, respectively.

Call the above function before sending input.
#+begin_src emacs-lisp :noweb-ref em-prompt/config
(advice-add 'eshell-send-input :before #'esh-mode-timestamp-prompt)
#+end_src

***** Ensure Separate Line

I want each prompt to start on its own line regardless of whether the previous output concluded with a newline character.

The first step to ensuring separate lines is to determine whether the previous output concluded with a newline and insert one if not.
#+begin_src emacs-lisp :noweb-ref em-prompt/config
(defun eshell-prompt-ensure-newline ()
  "Ensure any preceding output concludes with a newline.

If the preceding output itself does not conclude with a newline, insert \"%\"
followed by a newline."
  (let* ((pos-eol (point))
         (pos-bol (progn (beginning-of-line) (point))))
    (goto-char pos-eol)
    (unless (= pos-eol pos-bol)
      (insert (propertize "%\n" 'face '(:font-lock-face 'eshell-prompt)))
      (set-marker eshell-last-output-end (point)))))
#+end_src

#+begin_src emacs-lisp :noweb-ref em-prompt/config
(add-to-list 'eshell-before-prompt-hook #'eshell-prompt-ensure-newline)
#+end_src

*** Em Tramp

Em Tramp is an Eshell modules that provides TRAMP features.

#+begin_src emacs-lisp
(use-package em-tramp
  :straight (:type built-in)

  ;; Load this package after the following packages.
  :after (esh-module)

  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<em-tramp/config>>)
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-tramp/config
:END:

Load Em Tramp as an Eshell module.

#+begin_src emacs-lisp
(add-to-list 'eshell-modules-list 'eshell-tramp)
#+end_src

***** Redefine ~eshell/sudo~

For ease of use with Emacs's authentication mechanisms, the full hostname of the machine should be resolved in all cases, even when the Eshell prompt is running locally.

The following code is derived from the Em Tramp package distributed with GNU Emacs.
As such, it is licensed under the same conditions as GNU Emacs itself (namely, GPLv3 or later).

#+begin_src emacs-lisp
(defun eshell/sudo (&rest args)
  "Alias \"sudo\" to call Tramp.

Uses the system sudo through TRAMP's sudo method."
  (setq args (eshell-stringify-list (eshell-flatten-list args)))
  (let ((orig-args (copy-tree args)))
    (eshell-eval-using-options
     "sudo" args
     '((?h "help" nil nil "show this usage screen")
       (?u "user" t user "execute a command as another USER")
       :show-usage
       :usage "[(-u | --user) USER] COMMAND
      Execute a COMMAND as the superuser or another USER.")
     (throw 'eshell-external
            (let ((user (or user "root"))
                  (host (or (file-remote-p default-directory 'host)
                            (system-name)))
                  (dir (file-local-name (expand-file-name default-directory)))
                  (prefix (file-remote-p default-directory)))
              ;; `eshell-eval-using-options' reads options of COMMAND.
              (while (and (stringp (car orig-args))
                          (member (car orig-args) '("-u" "--user")))
                (setq orig-args (cddr orig-args)))
              (let ((default-directory
                      (if (and prefix
                               (or
                                (not
                                 (string-equal
                                  "sudo"
                                  (file-remote-p default-directory 'method)))
                                (not
                                 (string-equal
                                  user
                                  (file-remote-p default-directory 'user)))))
                          (format "%s|sudo:%s@%s:%s"
                                  (substring prefix 0 -1) user host dir)
                        (format "/sudo:%s@%s:%s" user host dir))))
                (eshell-named-command (car orig-args) (cdr orig-args))))))))
#+end_src

*** Em Rebind

#+begin_src emacs-lisp
(use-package em-rebind
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after (esh-module)

  ;; Apply the following variable customizations.
  :custom
  <<em-rebind/custom>>

  ;; Evaluate the following code before loading this package.
  :init
  <<em-rebind/init>>

  ;; Evaluate the following code after loading this package.
  :config
  <<em-rebind/config>>)
#+end_src

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-rebind/custom
:END:

Determine whether movement commands can cause the point to leave the current input.
#+begin_src emacs-lisp
(eshell-confine-point-to-input
 nil
 "Allow movement commands to move `point' out of the current input.")
#+end_src

**** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-rebind/init
:END:

Add this module to the list of Eshell modules to load.

#+begin_src emacs-lisp
(push 'eshell-rebind eshell-modules-list)
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-rebind/config
:DESCRIPTION: The code to be evaluated after ~em-rebind~ has been loaded.
:END:

Rebind Emacs's vertical movement keys to search through history.
Normal buffer movement is performed using keybindings provided by ~evil~.

#+begin_src emacs-lisp
(push '([(control ?n)] . eshell-previous-matching-input-from-input)
      eshell-rebind-keys-alist)
#+end_src

*** Em Cmpl

#+begin_src emacs-lisp
(use-package em-cmpl
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Apply the following variable customizations.
  :custom
  (eshell-cmpl-cycle-completions nil "Use zsh-like completion."))
#+end_src

** libvterm

*** /vterm/

From the [[https://github.com/akermu/emacs-libvterm][project's README]]:
#+begin_quote
Emacs-libvterm (vterm) is fully-fledged terminal emulator inside GNU Emacs based on libvterm, a C library.
As a result of using compiled code (instead of elisp), emacs-libvterm is fully capable, fast, and it can seamlessly handle large outputs.
#+end_quote

#+begin_src emacs-lisp
(use-package vterm
  :demand
  :custom
  (vterm-buffer-name-string "*vterm %s*"))
#+end_src

** Xonsh

From the [[https://xon.sh/contents.html][project's homepage]]:
#+begin_quote
Xonsh is a Python-powered, cross-platform, Unix-gazing shell language and command prompt.
The language is a superset of Python 3.5+ with additional shell primitives that you are used to from Bash and IPython.
It works on all major systems including Linux, Mac OSX, and Windows.
Xonsh is meant for the daily use of experts and novices alike.
#+end_quote

*** /Xonsh Mode/

/Xonsh Mode/ provides a major mode for Xonsh scripts and RC files.
#+begin_src emacs-lisp
(use-package xonsh-mode)
#+end_src

** /DWIM Shell Command/

#+begin_quote
Emacs shell commands with DWIM behavior
#+end_quote

#+begin_src emacs-lisp
(use-package dwim-shell-command
  :commands
  <<dwim-shell-command/command>>

  :general
  ("M-!" #'dwim-shell-command)
  (:keymaps 'dired-mode-map
   [remap dired-do-async-shell-command] #'dwim-shell-command
   [remap dired-do-shell-command] #'dwim-shell-command
   [remap dired-smart-shell-command] #'dwim-shell-command)

  :config
  <<dwim-shell-command/config>>)
#+end_src

*** Extract Archives

#+begin_src emacs-lisp :noweb-ref dwim-shell-command/config :noweb no
(defun dwim-shell-command-extract ()
  "Unzip all marked archives (of any kind) using `atool'.

Copyright (c) 2022-07-16 Álvaro Ramírez https://xenodium.com/a-lifehack-for-your-shell/"
  (interactive)
  (dwim-shell-command-on-marked-files
   "Extract" "atool --extract --explain --subdir '<<f>>'")
  :utils "atool")
#+end_src

#+begin_src emacs-lisp :noweb-ref dwim-shell-command/command
dwim-shell-command-extract
#+end_src

* Static Analysis
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref static-analysis
:END:

** Ispell

#+begin_src emacs-lisp
(use-package ispell
  :straight (:type built-in)

  ;; Only load this package if the following code evaluates to non-nil.
  :if
  <<ispell/if>>

  ;; Do not load this package lazily.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<ispell/config>>)
#+end_src

*** Conditional Loading
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ispell/if
:DESCRIPTION: Define condition for loading Ispell.
:END:

Ispell provides interfaces for third-party spellchecking binaries.
If no such binaries exist, Ispell does not need to be downloaded.

#+begin_src emacs-lisp
(executable-find "aspell")
#+end_src

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ispell/config
:DESCRIPTION: Code to be evaluated after Ispell has been loaded.
:END:

Set the executable to use for spell checking.
If =aspell= is not available, disable Ispell.

#+begin_src emacs-lisp
(cond
 ((executable-find "aspell")
  (setq ispell-program-name "aspell")
  (setq ispell-extra-args '("--run-together")))
 (t
  (setq ispell-program-name nil)))
#+end_src

** /Wucuo/

/Wucuo/ is a wrapper around /Flyspell/ that provides performance optimizations and camel case support out of the box.

#+begin_src emacs-lisp
(use-package wucuo
  :after ispell

  :ghook
  <<wucuo/ghook>>)
#+end_src

** Flycheck

#+begin_src emacs-lisp
(use-package flycheck
  ;; Load this package eagerly.
  :demand

  :custom
  (flycheck-global-modes
   (list #'not
         <<flycheck/custom/global-blacklist>>
         ))

  :custom
  (global-flycheck-mode +1))
#+end_src

* Feeds
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref feeds
:END:

** Email
*** /mu4e/

#+begin_src emacs-lisp
(use-package mu4e
  ;; Load `mu4e' after the following packages.
  :after s

  ;; Inform the bytecode compiler of the following functions.
  :commands (mu4e-choose-msmtp-account mu4e-show-trailing-whitespace)

  ;; Apply the following variable customizations.
  :custom
  <<mu4e/custom>>

  ;; Add the following, non-autoloading hooks.
  :gfhook
  <<mu4e/gfhook>>

  ;; Add keybindings according to the following alist.
  :bind
  (("C-x m" . mu4e-compose-new))

  ;; Evaluate the following code after loading this package.
  :config
  <<mu4e/config>>)
#+end_src

**** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mu4e/custom
:END:

Use ISO-esque timestamps for ~:human-date~.

#+begin_src emacs-lisp
(mu4e-headers-date-format "%Y-%m-%d %H:%M")
#+end_src

***** Account Contexts
Do not prompt for the context when starting mu4e.
Being in the proper context is unnecessary except when composing messages.

#+begin_src emacs-lisp
(mu4e-context-policy 'pick-first "Do not be concerned about context on startup.")
#+end_src

If no context matches (using its match function) when beginning to compose a message, prompt the user to manually select a context.

#+begin_src emacs-lisp
(mu4e-compose-context-policy 'ask)
#+end_src

***** Fetching and Indexing
Display the update status in the modeline.
This helps keep track of the current update status.

#+begin_src emacs-lisp
(mu4e-display-update-status-in-modeline t "Display the update status in the modeline.")
#+end_src

Do not display messages related to updating or indexing.
These messages are generally uninteresting.

#+begin_src emacs-lisp
(mu4e-hide-index-messages t "Do not display messages related to updating or indexing.")
#+end_src

***** Sending
#+begin_src emacs-lisp
(message-sendmail-envelope-from 'header "Use the value from the mail's header as the FROM field.")
#+end_src

#+begin_src emacs-lisp
(message-kill-buffer-on-exit t "Close the message buffer after sending its message.")
#+end_src

***** Composing
Use [[https://joeclark.org/ffaq.htm][format\=flowed]] for nicer viewing of plaintext mail.

#+begin_src emacs-lisp
(mu4e-compose-format-flowed t "Use format=flowed when composing mail.")
#+end_src

Replace the current frame when writing mail.

#+begin_src emacs-lisp
(mu4e-compose-in-new-frame nil "Do not open a new frame when composing mail.")
#+end_src

If a signature is set, automatically include it.

#+begin_src emacs-lisp
(mu4e-compose-signature-auto-include t "Automatically include signatures.")
#+end_src

***** Message View

Show senders' full addresses.
#+begin_src emacs-lisp
(mu4e-view-show-addresses t "Show senders' full addresses.")
#+end_src

View messages in their own windows.
#+begin_src emacs-lisp
(mu4e-split-view 'single-window)
#+end_src

Add an option to open the current message in the web browser.
#+begin_src emacs-lisp
(mu4e-view-actions
 '(("open in browser" . mu4e-action-view-in-browser)
   ("capture message" . mu4e-action-capture-message)
   ("view as pdf" . mu4e-action-view-as-pdf)
   ("show this thread" . mu4e-action-show-thread)))
#+end_src

***** Header View

Display the following fields in the headers buffer:
- date
- mailing list
- =FROM:= or =TO:= address
- subject
#+begin_src emacs-lisp
(mu4e-headers-fields
 '((:human-date . 16)
   (:flags . 8)
   (:mailing-list . 10)
   (:from-or-to . 20)
   (:subject . nil)))
#+end_src

Use Unicode box-drawing characters for the prefixes.

#+begin_src emacs-lisp
(mu4e-headers-has-child-prefix '("-" . "─"))
(mu4e-headers-empty-parent-prefix '("-" . "─"))
(mu4e-headers-first-child-prefix '("-" . "─"))
(mu4e-headers-duplicate-prefix '("=" . "═"))
(mu4e-headers-default-prefix '("-" . "─"))
#+end_src

***** Mail Directory

Use the value of ~$MAILDIR~ as the path to the mail directory if that environment variable exists.
#+begin_src emacs-lisp
(mu4e-maildir (xdg-user-dir "MAIL"))
#+end_src

**** Use Default Completing Read

Using Emacs's read completion allows for Ivy to hook in.
#+begin_src emacs-lisp :noweb-ref mu4e/custom
(mu4e-completing-read-function #'completing-read)
#+end_src

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mu4e/gfhook
:END:

Show trailing whitespace when composing mail.
#+begin_src emacs-lisp
('mu4e-compose-mode-hook #'mu4e-show-trailing-whitespace)
#+end_src

Specify the SMTP account to use before sending mail.
#+begin_src emacs-lisp
('message-send-mail-hook #'mu4e-choose-msmtp-account)
#+end_src

**** Post-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mu4e/config
:END:

***** Fetching and Indexing
If isync is installed, use =mbsync= to fetch all mail and rename filenames when moving mail.

#+begin_src emacs-lisp
(when (executable-find "mbsync")
  (setq mu4e-get-mail-command "mbsync -a")
  (setq mu4e-change-filenames-when-moving t))
#+end_src

***** Sending Mail
Choose how mail is sent, preferring =msmtp= to the built-in =smtpmail-send-it=.

#+begin_src emacs-lisp
(cond ((executable-find "msmtp")
       <<mu4e/config/sending/msmtp>>)
      (t
       <<mu4e/config/sending/smtpmail-send-it>>))
#+end_src

****** =msmtp= Configuration
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mu4e/config/sending/msmtp
:END:

Use =msmtp= as the sender.

#+begin_src emacs-lisp
(setq
 sendmail-program (executable-find "msmtp")
 message-send-mail-function #'message-send-mail-with-sendmail)
#+end_src

Supply an account label (option =-a=) to =msmtp= based on the mu4e context.

#+begin_src emacs-lisp
(defun mu4e-choose-msmtp-account ()
  "Choose msmtp account label based on mu4e context name."
  (when (message-mail-p)
    (setq message-sendmail-extra-arguments
          (list (concat "--account=" (mu4e-context-name (mu4e-context-current)))
                "--file=/home/lafrenierejm/etc/msmtp/config"))))
#+end_src

****** ~smtpmail-send-it~ Configuration
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mu4e/config/sending/smtpmail-send-it
:END:

Provide settings for using ~smtpmail-send-it~ to send mail.

#+begin_src emacs-lisp
(setq
 message-send-mail-function 'smtpmail-send-it
 send-mail-function 'smtpmail-send-it
 ;; Set the port number.
 smtpmail-smtp-service 587
 ;; Set the type of connection.
 smtpmail-stream-type 'starttls)
#+end_src

***** Multiple Accounts
#+begin_src emacs-lisp
(setq
 mu4e-contexts `( ,(make-mu4e-context
                    ;; Name of the context
                    :name "edu.utdallas@jml140230"
                    ;; alist of variables to set for this context.
                    :vars '((user-full-name . "Joseph LaFreniere")
                            (user-mail-address . "jml140230@utdallas.edu")
                            ;; SMTP
                            (smtpmail-smtp-server . "smtp.office365.com") ; hostname
                            (smtpmail-smtp-user . "jml140230@utdallas.edu") ; username
                            ;; Signature
                            (mu4e-compose-signature-auto-include . t)
                            (mu4e-compose-signature . "Joseph LaFreniere")
                            ;; Folders
                            (mu4e-archive-folder . "/edu.utdallas.jml140230/archive")
                            (mu4e-drafts-folder . "/edu.utdallas.jml140230/draft")
                            (mu4e-sent-folder .  "/edu.utdallas.jml140230/sent")
                            (mu4e-trash-folder . "/edu.utdallas.jml140230/trash"))
                    ;; =match-func= returns true when the passed message matches this context.
                    :match-func (lambda (msg)
                                  (when msg
                                    (mu4e-message-field msg :maildir)
                                    (string-prefix-p "/edu.utdallas.jml140230"
                                                     (mu4e-message-field msg :maildir)))))
                  ,(make-mu4e-context
                    ;; Name of the context
                    :name "xyz.lafreniere@joseph"
                    ;; alist of variables to set for this context.
                    :vars '((user-full-name . "Joseph LaFreniere")
                            (user-mail-address . "joseph@lafreniere.xyz")
                            ;; Signature
                            (mu4e-compose-signature-auto-include . t)
                            (mu4e-compose-signature . "Joseph LaFreniere")
                            ;; SMTP
                            (smtpmail-smtp-server . "smtp.kolabnow.com") ; hostname
                            (smtpmail-smtp-user . "joseph@lafreniere.xyz") ; username
                            ;; Folders
                            (mu4e-archive-folder . "/xyz.lafreniere.joseph/archive")
                            (mu4e-drafts-folder . "/xyz.lafreniere.joseph/draft")
                            (mu4e-sent-folder .  "/xyz.lafreniere.joseph/sent")
                            (mu4e-trash-folder . "/xyz.lafreniere.joseph/trash"))
                    ;; =match-func= returns true when the passed message matches this context.
                    :match-func (lambda (msg)
                                  (when msg
                                    (mu4e-message-field msg :maildir)
                                    (string-prefix-p "/xyz.lafreniere.joseph"
                                                     (mu4e-message-field msg :maildir)))))
                  ,(make-mu4e-context
                    ;; Name of the context
                    :name "com.gmail@lafrenierejm"
                    ;; alist of variables to set for this context.
                    :vars '((user-full-name . "Joseph LaFreniere")
                            (user-mail-address . "lafrenierejm@gmail.com")
                            ;; Signature
                            (mu4e-compose-signature-auto-include . t)
                            (mu4e-compose-signature . "Joseph LaFreniere")
                            ;; SMTP
                            (smtpmail-smtp-server . "smtp.gmail.com") ; hostname
                            (smtpmail-smtp-user . "lafrenierejm@gmail.com") ; username
                            ;; Folders
                            (mu4e-archive-folder . "/com.gmail.lafrenierejm/archive")
                            (mu4e-drafts-folder . "/com.gmail.lafrenierejm/draft")
                            (mu4e-sent-folder .  "/com.gmail.lafrenierejm/sent")
                            (mu4e-trash-folder . "/com.gmail.lafrenierejm/trash"))
                    ;; =match-func= returns true when the passed message matches this context.
                    :match-func (lambda (msg)
                                  (when msg
                                    (mu4e-message-field msg :maildir)
                                    (string-prefix-p "/com.gmail.lafrenierejm"
                                                     (mu4e-message-field msg :maildir)))))))
#+end_src

****** My Addresses
mu4e maintains a list of addresses whose presence in a message's From field means that the message was sent by me.
In such cases, display the To address(es).

#+begin_src emacs-lisp
(setq
 mu4e-user-mail-address-list '("admin@lafreniere.xyz"
                               "jml140230@utdallas.edu"
                               "joseph.lafreniere@utdallas.edu"
                               "joseph@lafreniere.xyz"
                               "lafrenierejm@gmail.com"
                               "lafrenierejm@utdallas.edu"))
#+end_src

***** Composing Mail

Show trailing whitespace.
This is helpful when composing =format=flowed= mail.

#+begin_src emacs-lisp
(defun mu4e-show-trailing-whitespace ()
  "Highlight trailing whitespace with face `trailing-whitespace'."
  (setq show-trailing-whitespace t))
#+end_src

**** Spell Checking

Enable spell check when composing mail.

#+begin_src emacs-lisp :noweb-ref wucuo/ghook
('mu4e-compose-mode-hook #'wucuo-start)
#+end_src

*** Message

#+begin_src emacs-lisp
(use-package message
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Non-autoloading hooks.
  :gfhook
  <<message/gfhook>>

  ;; Evaluate the following code after loading this package.
  :config
  <<message/config>>)
#+end_src

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref message/gfhook
:END:

Prompt the user before sending a message without an attachment.

#+begin_src emacs-lisp
('message-send-hook #'mbork/message-warn-if-no-attachments)
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref message/config
:END:

***** Attachment Reminders
The following code is taken from Marcin Borkowski's 2016-02-06 post [[http://mbork.pl/2016-02-06_An_attachment_reminder_in_mu4e]["An attachment reminder in mu4e"]].
Borkowski's post links to the [[https://github.com/mbork/message][mbork/message]] repository on GitHub as the host for the attachment reminder code.
Interestingly, the repository appears to contain neither the attachment code nor any commits that hint at the code having ever been committed into the repository's mbork-message package.
Despite the attachment code never having (publicly) been a part of mbork/message, the code is attributed here to Borkowsi under the same GPLv2 license as mbork-message.

#+begin_src emacs-lisp
(defun mbork/message-attachment-present-p ()
  "Return t if an attachment is found in the current message."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      (when (search-forward "<#part" nil t)
        t))))
#+end_src

#+begin_src emacs-lisp
(defcustom mbork/message-attachment-intent-re
  (regexp-opt '("attachment" "attached"))
  "If this regex is matched then the message should have an attachment.")
#+end_src

#+begin_src emacs-lisp
(defcustom mbork/message-attachment-reminder
  "Are you sure you want to send this message without any attachment? "
  "The question asked when trying to send a message with a missing attachment.")
#+end_src

#+begin_src emacs-lisp
(defun mbork/message-warn-if-no-attachments ()
  "Ask if the user wants to send even though the message has no attachment."
  (when (and (save-excursion
               (save-restriction
                 (widen)
                 (goto-char (point-min))
                 (re-search-forward mbork/message-attachment-intent-re nil t)))
             (not (mbork/message-attachment-present-p)))
    (unless (y-or-n-p mbork/message-attachment-reminder)
      (keyboard-quit))))
#+end_src

*** Mml

#+begin_src emacs-lisp
(use-package mml
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<mml/config>>)
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref mml/config
:END:

***** Add Attachments at Ends of Buffers
~mml-attach-file~, the function used by ~mu4e-compose-mode~ to add attachments to mail, attaches the specified file wherever point happens to be.
[[http://emacs.1067599.n8.nabble.com/Why-does-mml-attach-file-put-the-attachment-at-the-very-end-of-the-message-td373798.html][This thread]], authored by Marcin Borkowski, explores the problems that attachments anywhere but the end of a message buffer can cause.
In light of that, it is desirable to only /ever/ insert attachments at the end of the buffer.
This can be accomplished by advising ~mml-attach-file~ to automatically move and restore ~point~.
Borkowsi provided code to do so in [[http://mbork.pl/2015-11-28_Fixing_mml-attach-file_using_advice][a blog post]]:

#+begin_src emacs-lisp
(defun init-email/mml-attach-file-at-eob (orig-fun &rest args)
  "Go to the end of the buffer before attaching files."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-max))
      (apply orig-fun args))))
#+end_src

#+begin_src emacs-lisp
(advice-add 'mml-attach-file :around #'init-email/mml-attach-file-at-eob)
#+end_src

The license of the code hosted on Borkowsi's blog does not appear to be specified anywhere in the blog.
I have reached out to Borkowski asking how he would like the code to be licensed.

** Atom and RSS

I Use Chris Wellons's /Elfeed/ for managing my web feeds.

*** /Elfeed/

#+begin_src emacs-lisp
(use-package elfeed
  :custom
  (elfeed-db-directory "~/.local/share/elfeed"))
#+end_src

*** /Elfeed Org/

/Elfeed Org/ allows the use of an Org file to specify feeds for /Elfeed/.
I set it to load =elfeed.org= from my Emacs directory.
The primary advantage of doing so is that it allows me to version-control the file along with the rest of my Emacs configuration.

#+begin_src emacs-lisp
(use-package elfeed-org
  :demand

  :custom
  (rmh-elfeed-org-files
   (list (expand-file-name "elfeed.org" user-emacs-directory)))

  :config
  ;; load feeds from `rmh-elfeed-org-files' when elfeed starts
  (elfeed-org))
#+end_src

** Internet Relay Chat (IRC)

*** /ERC/

#+begin_src emacs-lisp
(use-package erc
  :custom
  <<erc/custom>>

  :config
  <<erc/config>>)
#+end_src

**** Use Auth-Source for Passwords

\src_emacs-lisp{erc-prompt-for-password} determines whether passwords are prompted for (non-\src_emacs-lisp{nil} )or obtained via auth-source (\src_emacs-lisp{nil}).
I prefer to use auth-source.
#+begin_src emacs-lisp :noweb-ref erc/custom
(erc-prompt-for-password nil "Use auth-source for login passwords.")
#+end_src

**** Hide Types of Messages

Hide the following message types across all networks and channels:
- JOIN
- PART
- QUIT
#+begin_src emacs-lisp :noweb-ref erc/custom
(erc-hide-list '("JOIN" "PART" "QUIT"))
#+end_src

**** Automatically Identify

Redefine ~erc-login~ to identify using NickServ commands sent via PRIVMSG.
#+begin_src emacs-lisp :noweb-ref erc/config
(defun erc-login ()
  "Perform user authentication at the IRC server."
  (erc-log (format "login: nick: %s, user: %s %s %s :%s"
                   (erc-current-nick)
                   (user-login-name)
                   (or erc-system-name (system-name))
                   erc-session-server
                   erc-session-user-full-name))

  (erc-server-send (format "NICK %s" (erc-current-nick)))
  (erc-server-send
   (format "USER %s %s %s :%s"
           ;; hacked - S.B.
           (if erc-anonymous-login erc-email-userid (user-login-name))
           "0" "*"
           erc-session-user-full-name))
  (if erc-session-password
      (erc-message "PRIVMSG" (format "NickServ identify %s %s"
                                   (erc-current-nick) erc-session-password))
    (message "Logging in without password"))
  (erc-update-mode-line))
#+end_src

* Multimedia
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref multimedia
:END:

** Ebook

*** /nov.el/ for EPUB

From /nov.el/'s [[https://depp.brause.cc/nov.el/][homepage]]:
#+begin_quote
=nov.el= provides a major mode for reading EPUB documents.

Features:
- Basic navigation (jump to TOC, previous/next chapter)
- Remembering and restoring the last read position
- Jump to next chapter when scrolling beyond end
- Storing and following Org links to EPUB files
- Renders EPUB2 (.ncx) and EPUB3 (<nav>) TOCs
- Hyperlinks to internal and external targets
- Supports textual and image documents
- Info-style history navigation
- View source of document files
- Metadata display
- Image rescaling
#+end_quote

#+begin_src emacs-lisp
(use-package nov
  :if (executable-find "unzip")
  :mode ("\\.epub\\'" . nov-mode))
#+end_src

** Portable Document Format (PDF)

*** /PDF Tools/

#+begin_src emacs-lisp
(use-package pdf-tools
  ;; Establish deferred binding within `auto-mode-alist'.
  :mode
  <<pdf-tools/mode>>

  ;; Create key maps and, if necessary, autoloads.
  :general
  <<pdf-tools/general>>

  ;; Evalutate the following code before loading this package.
  :init
  (pdf-tools-install t))
#+end_src

**** Filename Mapping
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref pdf-tools/mode
:END:

Create an alist whose keys are regexps matching filenames and whose values are the function to enable ~pdf-view-mode~.

#+begin_src emacs-lisp
("\\.pdf\\'" . pdf-view-mode)
#+end_src

**** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref pdf-tools/general
:END:

#+begin_src emacs-lisp
(:keymaps 'pdf-view-mode-map
 "h" #'left-char
 "j" #'pdf-view-next-line-or-next-page
 "k" #'pdf-view-previous-line-or-previous-page
 "l" #'right-char
 "q" nil
 "y" #'kill-region)
#+end_src

** Video

*** /YouTube DL/

#+begin_src emacs-lisp
(use-package youtube-dl
  :custom
  (youtube-dl-directory (xdg-user-dir "VIDEOS")))
#+end_src

** Emacs Multi-Media System (EMMS)

*** /EMMS Source File/

#+begin_src emacs-lisp
(use-package emms-source-file
  :straight emms
  :after standard-dirs
  :custom
  (emms-source-file-default-directory (standard-dirs-user-audio)))
#+end_src

*** /EMMS Setup/

#+begin_src emacs-lisp
(use-package emms-setup
  :straight emms

  ;; Load this package eagerly.
  :demand

  :config
  (emms-all)
  (emms-default-players))
#+end_src

*** /EMMS Mode Line/

#+begin_src emacs-lisp
(use-package emms-mode-line
  :straight emms

  ;; Load this package eagerly.
  :demand

  ;; Set the following custom variables.
  :custom
  <<emms-mode-line/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<emms-mode-line/config>>)
#+end_src

**** Display in Minibuffer, Not Mode-Line

By default, the current media is shown in the mode-line.
I would prefer that it be shown only in the minibuffer (via /Minibuffer Line/).

The first step is to disable display in the modeline.
#+begin_src emacs-lisp :noweb-ref emms-mode-line/custom
(emms-mode-line-mode-line-function nil "Do not show info in modeline")
#+end_src

Then redefine the function used to display the current song, showing only the file name if the ~description~ is a filename.
#+begin_src emacs-lisp :noweb-ref emms-mode-line/config
(defun emms-mode-line-playlist-current ()
  "Format the currently playing song."
  (when-let* ((description (emms-track-description
                            (emms-playlist-current-selected-track)))
              (name (if (f-file? description)
                        (replace-regexp-in-string
                         (rx string-start (one-or-more digit)
                             (or " " " - " "."))
                         ""
                         (f-base description))
                      description)))
    (format "%s" name)))
#+end_src

Add the function to the left-hand /Minibuffer Line/ variable.
#+begin_src emacs-lisp :noweb-ref emms-mode-line/config
(add-to-list 'minibuffer-line-left #'emms-mode-line-playlist-current)
#+end_src

*** /EMMS Playing time/

#+begin_src emacs-lisp
(use-package emms-playing-time
  :straight emms

  ;; Load this package eagerly.
  :demand

  ;; Apply the following variable customizations.
  :custom
  <<emms-playing-time/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<emms-mode-line/config>>)
#+end_src

**** Display Time in Minibuffer

Do not add any spaces around the time.
#+begin_src emacs-lisp :noweb-ref emms-playing-time/custom
(emms-playing-time-display-format "%s")
#+end_src

Redefine \src_emacs-lisp{emms-playing-time-mode-line} to add to the left-hand minibuffer line instead of mode-line.
#+begin_src emacs-lisp :noweb-ref emms-playing-time/config
(defun [emms-playing-time-mode-line] ()
  "Add playing time to the left-hand side of the minibuffer."
  (add-to-list 'minibuffer-line-left #'emms-playing-time-string)
  (emms-playing-time-restore-mode-line))
#+end_src

* Programming
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref programming
:END:

** Literate Programming

[[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]] programming is a programming paradigm introduced by Donald Knuth in which the standard precedence of code and explanatory prose are flipped.
Whereas the standard programming paradigm has a source documents' text "defaulting" to source code, literate programming assumes that text is intended for human consumption (the role normally filled by comments) unless it is explicitly demarcated as source code.
A literate document can then be /tangled/ into a source-only file.

*** Polymode
:PROPERTIES:
:CUSTOM_ID: polymode
:END:

Polymode is a framework for supporting multiple major modes (MMM) inside a single Emacs buffer.
This can benefit both literate and traditional programming by allowing one to code blocks and docstrings, respectively, with the full features of dedicated major modes.

#+begin_src emacs-lisp
(use-package polymode
  :demand

  :mode
  <<polymode/mode>>

  ;; Evaluate the following code after loading this package.
  :config
  <<polymode/config>>)
#+end_src

*** /Poly Markdown/

/Poly Markdown/ provides a set of /Polymode/ functions pre-configured for Markdown buffers.
#+begin_src emacs-lisp
(use-package poly-markdown
  :after (:all markdown-mode polymode)
  :demand)
#+end_src

** Language Server Protocol (LSP)

*** /LSP Mode/

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode

  :init
  (setq lsp-keymap-prefix "C-c l")

  :custom
  (lsp-disabled-clients '(pyls))
  (lsp-headerline-breadcrumb-enable nil)

  ;; Add the following auto-load hooks.
  :ghook
  <<lsp-mode/ghook>>

  ;; Add the following non-auto-loading hooks.
  :gfhook
  <<lsp-mode/gfhook>>

  ;; Define relevant keybindings.
  :general
  (:keymaps '(lsp-mode-map)
   :states '(movement normal)
   "g r" #'lsp-find-references)

  :config
  ;; https://emacs-lsp.github.io/lsp-mode/page/faq/#how-do-i-force-lsp-mode-to-forget-the-workspace-folders-for-multi-root
  (general-advice-add
   'lsp :before
   (lambda (&rest _args) (eval '(setf (lsp-session-server-id->folders (lsp-session)) (ht)))))

  :commands (lsp lsp-deferred))
#+END_SRC

*** /LSP UI/

#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :demand
  :after (lsp-mode flycheck))
#+END_SRC

*** /Company LSP/

#+BEGIN_SRC emacs-lisp
(use-package company-lsp
  :demand
  :after (company lsp-mode))
#+END_SRC

*** /DAP Mode/

#+BEGIN_SRC emacs-lisp
(use-package dap-mode
  :after lsp-mode
  :config
  (dap-mode t)
  (dap-ui-mode t))
#+END_SRC

*** /LSP Ivy/

#+BEGIN_SRC emacs-lisp
(use-package lsp-ivy
  :demand
  :after (ivy lsp-mode))
#+END_SRC

** Treesitter

#+begin_src emacs-lisp
(use-package tree-sitter
  :demand

  :ghook
  <<tree-sitter/ghook>>
  ('tree-sitter-mode-hook #'tree-sitter-hl-mode))
#+end_src

#+begin_src emacs-lisp
(use-package tree-sitter-langs
  :demand
  :after tree-sitter)
#+end_src

*** /Evil TextObj Tree-Sitter/

#+begin_src emacs-lisp
(use-package evil-textobj-tree-sitter
  :straight (evil-textobj-tree-sitter
             :type git
             :host github
             :repo "meain/evil-textobj-tree-sitter"
             :files (:defaults "queries"))
  :demand
  :after tree-sitter

  :config
  (defun evil-textobj-tree-sitter-define-key (key textobj)
    "Bind key `key' to outer and inner variants of `textobj'."
    (eval `(define-key evil-outer-text-objects-map ,key
             (evil-textobj-tree-sitter-get-textobj ,(s-join "." (list textobj "outer")))))
    (eval `(define-key evil-inner-text-objects-map ,key
             (evil-textobj-tree-sitter-get-textobj ,(s-join "." (list textobj "inner"))))))

  (evil-textobj-tree-sitter-define-key "f" "function")
  (evil-textobj-tree-sitter-define-key "b" "block")
  (evil-textobj-tree-sitter-define-key "s" "statement")
  (evil-textobj-tree-sitter-define-key "c" "call"))
#+end_src

** Applescript

*** Apples Mode

#+begin_src emacs-lisp
(use-package apples-mode
  :mode
  ("\\.\\(applescri\\|sc\\)pt\\'")

  :general
  (:keymaps 'apples-mode-map
   "C-c C-c" #'apples-run-region/buffer))
#+end_src

** AutoHotkey

From [[https://www.autohotkey.com][autohotkey.com]]:
#+begin_quote
AutoHotkey is a free, open-source scripting language for Windows that allows users to easily create small to complex scripts for all kinds of tasks such as: form fillers, auto-clicking, macros, etc.
#+end_quote

#+begin_src emacs-lisp
(use-package ahk-mode)
#+end_src

** Configuration Files

*** /Conf Mode/

From the package's commentary:
#+begin_quote
This mode is designed to edit many similar varieties of Conf/Ini files and Java properties.
It started out from Aurélien Tisné's ini-mode.
\src_emacs-lisp{conf-space-keywords} were inspired by Robert Fitzgerald's any-ini-mode.
#+end_quote

#+begin_src emacs-lisp
(use-package conf-mode
  :straight (:type built-in)

  :preface
  (defconst conf-mode-ssh-config-dir
    (rx string-start (literal (getenv "HOME")) "/.ssh/config.d/")
    "The path to the current user's SSH configuration directory.")

  :mode
  ("\\.service\\'" . conf-unix-mode)
  ("/\\.flake8\\'" . conf-unix-mode)

  :config
  (add-to-list 'auto-mode-alist (cons conf-mode-ssh-config-dir #'conf-space-mode)))
#+end_src

** Cucumber

*** /Feature Mode/

#+begin_src emacs-lisp
(use-package feature-mode
  :mode
  ("\\.feature\\'" . #'feature-mode))
#+end_src

** Hashicorp

*** Hashicorp Configuration Language (HCL)

**** /HCL Mode/

#+begin_src emacs-lisp
(use-package hcl-mode
  :mode
  <<hcl-mode/mode>>

  :config
  <<hcl-mode/config>>)
#+end_src

*** Terraform (=.tf=)

**** /Terraform Mode/

#+begin_src emacs-lisp
(use-package terraform-mode
  :gfhook
  ('terraform-mode-hook #'terraform-format-on-save-mode))
#+end_src

***** /Smart Dash/

Enable \src_emacs-lisp{smart-dash-mode} in Terraform buffers.
#+begin_src emacs-lisp :noweb-ref smart-dash/ghook
('terraform-mode-hook nil)
#+end_src

***** Inline JSON

#+begin_src emacs-lisp
(defun poly-terraform-inline-json-head (count)
  "Search in direction specified by COUNT for inline JSON."
  (when (re-search-forward
         (rx "= <<" (group (one-or-more alpha)) line-end "\n"
             (minimal-match (zero-or-more anything))
             line-start (group (backref 1)))
         nil t count)
    (cons (match-beginning 1) (match-end 1))))
#+end_src

#+begin_src emacs-lisp
(defun poly-terraform-inline-json-tail (count)
  "Return the beginning and end of the tail."
  (cons (match-beginning 2) (match-end 2)))
#+end_src

Define the inner mode.
#+begin_src emacs-lisp
(define-innermode poly-terraform-json-innermode
  :mode 'json-mode
  :head-matcher #'poly-terraform-inline-json-head
  :tail-matcher #'poly-terraform-inline-json-tail
  :head-mode 'host
  :tail-mode 'host)
#+end_src

Define the host (i.e. outer) mode.
#+begin_src emacs-lisp
(define-hostmode poly-terraform-hostmode
  :mode 'terraform-mode)
#+end_src

Define the actual Polymode.
#+begin_src emacs-lisp
(define-polymode poly-terraform-json-mode
  :hostmode 'poly-terraform-hostmode
  :innermodes '(poly-terraform-json-innermode))
#+end_src

Add the newly created modes to /Flycheck/'s blacklist.
#+begin_src emacs-lisp :noweb-ref flycheck/custom/global-blacklist
'poly-terraform-json-mode 'poly-terraform-json-innermode
#+end_src

**** Terragrunt

#+begin_src emacs-lisp :noweb-ref hcl-mode/config
(define-derived-mode terragrunt-mode hcl-mode "Terragrunt"
  "Terragrunt mode is a major mode for editing Terragrunt HCL files.")
#+end_src

Autoload the mode for files named =terragrunt.hcl=.
#+begin_src emacs-lisp :noweb-ref hcl-mode/mode
("/terragrunt\\.hcl\\'" . terragrunt-mode)
#+end_src

The /[[Reformatter]]/ package is used to create an formatter for Terragrunt files using ~terragrunt fmt~.
#+begin_src emacs-lisp :noweb-ref reformatter/config
(reformatter-define
  terragrunt-format
  :program "terragrunt"
  :args '("fmt" "-no-color" "-"))
#+end_src

The defined hook can be added to all Terragrunt files.
#+begin_src emacs-lisp :noweb-ref reformatter/ghook
('terragrunt-mode-hook #'terragrunt-format-on-save-mode)
#+end_src

** JavaScript

*** /JSON Mode/

From [[https://github.com/joshwnj/json-mode][the project's README]]:
#+begin_quote
Extends the builtin js-mode to add better syntax highlighting for JSON and some nice editing keybindings.
#+end_quote

#+begin_src emacs-lisp
(use-package json-mode
  :gfhook
  ('json-mode-hook #'hs-minor-mode))
#+end_src

*** Formatting via Prettier

#+begin_src emacs-lisp :noweb-ref reformatter/config
(reformatter-define
  json-format
  :program "prettier"
  :args `("--parser" "json"
          "--write"
          "--stdin-filepath" ,(buffer-file-name)))
#+end_src

** Go

*** /Go Mode/

#+BEGIN_SRC emacs-lisp
(use-package go-mode)
#+END_SRC

**** LSP Mode
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref lsp-mode/ghook
:END:

Enable LSP Mode in Go buffers.
#+BEGIN_SRC emacs-lisp
('go-mode-hook #'lsp-deferred)
#+END_SRC

*** /Go Eldoc/

/Go Eldoc/ provides eldoc support for the Go language.
#+BEGIN_SRC emacs-lisp
(use-package go-eldoc
  :after go
  :ghook
  ('go-mode-hook #'go-eldoc-setup))
#+END_SRC

** Lisps

It is desirable to have slightly different character matching behavior when editing Lisps.
The following is a list of the Lisp modes I edit in.

#+begin_src emacs-lisp :noweb-ref constants
(defconst lisp-major-modes
  '(cider-repl-mode
    clojure-mode
    emacs-lisp-mode
    geiser-repl-mode
    hy-mode
    ielm-mode
    inferior-hy-mode
    lisp-data-mode
    lisp-mode
    minibuffer-inactive-mode
    minibuffer-mode
    scheme-mode)
  "A list of Lisp major modes.")
#+end_src

And the above modes' hooks:
#+begin_src emacs-lisp :noweb-ref constants
(defconst lisp-major-mode-hooks
  (mapcar #'derived-mode-hook-name lisp-major-modes)
  "A list of Lisp major mode hooks.")
#+end_src

The function \src_emacs-lisp{derived-mode-hook-name} is provided by /Derived/, which is a built-in package and can be \src_emacs-lisp{require}d.
#+begin_src emacs-lisp :noweb-ref dependencies
(require 'derived)
#+end_src

For sexp-based languages it is also desirable to disallow tabs for line indentation.
#+begin_src emacs-lisp
(defun use-spaces ()
  "Only use spaces (as opposed to tabs) for indentation."
  (setq indent-tabs-mode nil))
#+end_src

The above function should be added to all Lisp major mode hooks.
#+begin_src emacs-lisp
(general-add-hook lisp-major-mode-hooks #'use-spaces)
#+end_src

*** Lisp Mode

#+begin_src emacs-lisp
(use-package lisp-mode
  :straight (:type built-in)

  :demand

  :config
  <<lisp-mode/config>>)
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref lisp-mode/config
:END:

***** Fuco1's Indentation
:PROPERTIES:
:COPYRIGHT_AUTHOR: Matus Goljer (Fuco1)
:COPYRIGHT_EMAIL: matus.goljer@gmail.com
:COPYRIGHT_URL: https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94
:COPYRIGHT_YEAR: 2015
:END:

Redefine Lisp Mode's indentation function.
#+begin_src emacs-lisp
(defun lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.

INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.

If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:

-`defun', meaning indent `defun'-style
  \(this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);

- an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;

- a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.

This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))
#+end_src

*** Aggressive Indent
Aggressive Indent provides a minor mode to re-indent code after every change.

#+begin_src emacs-lisp
(use-package aggressive-indent
  :ghook
  (lisp-major-mode-hooks #'aggressive-indent-mode))
#+end_src

*** Character Matching
**** Smartparens

***** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref smartparens/config
:END:

Lisps use the single quote (='=) for quoting, where it is not paired with a closing character.
#+begin_src emacs-lisp
(sp-local-pair lisp-major-modes "'" nil :actions nil)
#+end_src

**** Evil Cleverparens
Author Llli Pieponnen (luxbock)'s describes Evil Cleverparens as providing an "Evil normal-state minor-mode for editing lisp-like languages".

#+begin_src emacs-lisp
(use-package evil-cleverparens
  ;; Delay loading this package until after the following packages.
  :after
  (:all evil smartparens)

  ;; Inform the byte compiler of the following functions.
  :functions evil-move-beyond-eol

  ;; Add the following autoloading hooks.
  :ghook
  <<evil-cleverparens/ghook>>

  ;; Add the following non-autoloading hooks.
  :gfhook
  <<evil-cleverparens/gfhook>>)
#+end_src

***** Autoloading Hooks
:PROPERTIES:
:DESCRIPTION: Add auto-loading hooks related to Evil Cleverparens.
:HEADER-ARGS+: :noweb-ref evil-cleverparens/ghook
:END:

Enable ~evil-cleverparens-mode~ for Lisps.
#+begin_src emacs-lisp
(lisp-major-mode-hooks #'evil-cleverparens-mode)
#+end_src

***** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-cleverparens/gfhook
:END:

Let the cursor move past the end of lines in Lisp source code.
#+begin_src emacs-lisp
('evil-cleverparens-mode-hook #'evil-move-beyond-eol)
#+end_src

*** Fennel

From the [[https://fennel-lang.org/][language's homepage]]:
#+begin_quote
Fennel is a programming language that brings together the speed, simplicity, and reach of Lua with the flexibility of a lisp syntax and macro system.
#+end_quote

**** /Fennel Mode/

#+begin_src emacs-lisp
(use-package fennel-mode
  :mode
  ("\\.fnl\\'" . fennel-mode))
#+end_src

*** Lisp-1

Lisp-1 languages have a single namespace for all names.

**** Geiser Guile

#+begin_src emacs-lisp
(use-package geiser-guile
  :if (executable-find "guile")

  :straight nil

  :config
  (when-let ((path (expand-file-name
                    "org.gnu.savannah.git/guix"
                    (xdg-user-dir "SOURCE")))
             (file-directory-p path))
    (add-to-list 'geiser-guile-load-path path)))
#+end_src

**** Guix

From the package's commentary:
#+BEGIN_QUOTE
Emacs-Guix (aka "guix.el") provides featureful visual interface for the GNU Guix package manager.
It allows you:
- to search for packages and to look at their code (package recipes);
- to manage your Guix profile(s) by installing/removing packages;
- to look at, compare and remove profile generations;
- to look at system services and generations (if you use [Guix System]);
- to do many other things.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package guix
  ;; Load this package if the following code evaluates to non-nil.
  :if
  <<guix/if>>

  ;; Add the following auto-loading hooks.
  :ghook
  <<guix/ghook>>

  ;; Evaluate the following code after loading this package.
  :custom
  (guix-load-path
   (when-let ((path (expand-file-name
                     "org.gnu.savannah.git/guix/"
                     (xdg-user-dir "SOURCE")))
              ((file-directory-p path)))
     path)
   "Directory or directories to prepend to Guile's `%load-path' and `load-compiled-path'."))
#+end_src

***** Conditions for Loading
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref guix/if
:END:

The package relies on =guix= being available on =$PATH=.
#+begin_src emacs-lisp
(executable-find "guix")
#+end_src

***** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref guix/ghook
:END:

Replace hash symbols with ellipses.
#+begin_src emacs-lisp
('(dired-mode-hook shell-mode-hook) #'guix-prettify-mode)
#+end_src

**** Racket

#+begin_src emacs-lisp
(use-package racket-mode)
#+end_src

**** Hy Mode

#+begin_src emacs-lisp
(use-package hy-mode
  :mode
  ("\\.hy\\'" . hy-mode)

  :general
  (:keymaps 'hy-mode-map
   "C-c C-c" #'hy-shell-eval-buffer)

  :config
  (defun hy-shell--redirect-check-prompt-regexp ()
    "Avoid infinite loop in redirect if `comint-prompt-regexp' badly defined."
    nil))
#+end_src

**** /Scheme/

#+begin_src emacs-lisp
(use-package scheme
  :mode ("\\.guile\\'" . scheme-mode))
#+end_src

*** Lisp-2
Lisp-2 languages have a separate namespace for functions.

**** Superior Lisp Interaction Mode (SLIME)

#+begin_src emacs-lisp
(use-package slime
  :init
  (defvar init-prog-lisp/slime-extra
    '(slime-indentation slime-fancy)
    "The contrib packages for SLIME to load")

  :config
  (setq slime-lisp-implementations
        '((sbcl ("sbcl" "--noinform"))))
  (slime-setup init-prog-lisp/slime-extra))
#+end_src

**** Emacs Lisp

***** /Elisp Mode/

#+begin_src emacs-lisp
(use-package elisp-mode
  :straight (:type built-in)

  ;; Add the following keybindings.
  :general
  ("C-x C-e" #'elisp-eval-last-sexp)
  (:keymaps 'emacs-lisp-mode-map
   "C-c C-c" #'eval-buffer)

  :commands elisp-eval-last-sexp

  :config
  <<elisp-mode/config>>)
#+end_src

****** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref elisp-mode/config
:END:

Define a custom \src_emacs-lisp{eval-buffer}-like function that, when passed a prefix argument, replaces the expression being evaluated with the result of its evaluation.
#+begin_src emacs-lisp
(defun elisp-eval-last-sexp (&optional replace)
  "Evaluate the preceding sexp, OPTIONally replacing it with its result."
  (interactive "P")
  (if (not replace)
      (eval-last-sexp replace)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0))))))
#+end_src

****** Comment Out Sexp
:PROPERTIES:
:COPYRIGHT_AUTHOR: A. Levy
:COPYRIGHT_URL: https://stackoverflow.com/a/4201022/8468492
:LICENSE:  CC BY-SA 4.0
:END:

Clojure, Hy, and Scheme have built-in macros for commenting out sexps.
Emacs Lisp, as far as I no, does not have any such macro built-in.
A. Levy provided a working macro as [[https://stackoverflow.com/a/4201022/8468492][an answer]] on StackOverflow:
#+begin_src emacs-lisp :noweb-ref elisp-mode/config
(defmacro comment (&rest body)
  "Return `nil' in place of BODY, zero or more s-expressions."
  nil)
#+end_src

***** Helpful

From the package's README:
#+BEGIN_QUOTE
Helpful is an alternative to the built-in Emacs help that provides much more contextual information.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package helpful
  :general
  ("C-h c" #'helpful-command
   "C-h f" #'helpful-callable
   "C-h v" #'helpful-variable)

  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable))
#+end_src

**** Clojure

***** Clojure Mode

#+begin_src emacs-lisp
(use-package clojure-mode)
#+end_src

***** Clojure Refactor

#+begin_src emacs-lisp
(use-package clj-refactor
  :ghook
  ('clojure-mode-hook #'clj-refactor-mode)

  :gfhook
  ('clojure-mode-hook #'yas-minor-mode)

  :config
  (cljr-add-keybindings-with-prefix "C-c C-m"))
#+end_src

***** CIDER

#+begin_src emacs-lisp
(use-package cider

  :commands
  cider-jack-in

  :general
  (:keymaps 'cider-repl-mode-map
   [remap current-buffer/kill] #'cider-quit
   "C-x C-k" #'cider-quit)
  (:keymaps 'cider-repl-mode-map
   :states '(movement normal)
   "C-l" #'cider-repl-clear-buffer))
#+end_src

***** CIDER Hydra

#+begin_src emacs-lisp
(use-package cider-hydra
  :ghook
  ('clojure-mode-hook #'cider-hydra-mode))
#+end_src

** Java

*** /Keystore Mode/

/KeyStore Mode/ is a major mode for viewing and editing Java Keystore (.jks) files.
#+begin_src emacs-lisp
(use-package keystore-mode
  :demand)
#+end_src

** Jinja

*** /Jinja2 Mode/

#+begin_src emacs-lisp
(use-package jinja2-mode
  :mode (("\\.j2\\'" . jinja2-mode)))
#+end_src

** UNIX Shell

*** /Sh Script/

#+begin_src emacs-lisp
(use-package sh-script
  ;; Evaluate the following code before everything except `:disabled'.
  :preface
  <<sh-script/preface>>

  ;; Add the following non-autoloading hooks.
  :gfhook
  <<sh-script/gfhook>>

  ;; Inform the bytecode compiler of the following functions.
  :functions sh-script-set-shell-type

  ;; Evaluate the following code after loading `shell-script-mode'.
  :config
  <<sh-script/config>>)
#+end_src

**** Detect Zsh Files

***** Filename Regular Expressions
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref sh-script/preface
:END:

Describe a regexp that matches Zsh dotfile filenames.

#+begin_src emacs-lisp
(defconst sh-script--zsh-dotfile-regexp
  (rx "/.z"
      (one-or-more (not (any ".")))
      string-end)
  "Regular expression matching Zsh dotfile filenames.")
#+end_src

Describe a regexp that matches Zsh script filenames.

#+begin_src emacs-lisp
(defconst sh-script--zsh-script-regexp
  (rx ".zsh" string-end)
  "Regular expression matching Zsh script filenames.")
#+end_src

Define a list of regexps that match Zsh dotfiles and script filenames.

#+begin_src emacs-lisp
(defconst sh-script--zsh-regexps
  (list sh-script--zsh-dotfile-regexp sh-script--zsh-script-regexp)
  "A list of regexps describing known Zsh filenames.")
#+end_src

**** Set Shell Type

Define a function that sets the shell type to Zsh when working with a Zsh file.
#+begin_src emacs-lisp :noweb-ref sh-script/config
(defun sh-script-set-shell-type ()
  "Set the shell type based on variable `buffer-file-name'."
  ;; Loop over the list of Zsh filenames.
  (dolist (regexp sh-script--zsh-regexps)
    ;; If the regexp matches the name of the file the buffer is visiting...
    (when (string-match regexp (or buffer-file-name (buffer-name)))
      ;; Then set the shell type to Zsh.
      (sh-set-shell "zsh"))))
#+end_src

Add the above function to be run on all \src_emacs-lisp{sh-mode} buffers.
#+begin_src emacs-lisp :noweb-ref sh-script/gfhook
('sh-mode-hook #'sh-script-set-shell-type)
#+end_src

*** Shell Format (/shfmt/)

#+begin_src emacs-lisp
(use-package shfmt
  :straight (:host github :repo "purcell/emacs-shfmt"
             :branch "master")
  :after sh-script
  :demand)
#+end_src

** PowerShell

*** /PowerShell/

#+BEGIN_SRC emacs-lisp
(use-package powershell)
#+END_SRC

** Python

To make it easier to apply settings to all major modes I edit Python code in, a variable is defined with the list of the modes:
#+begin_src emacs-lisp :noweb-ref constants
(defconst python-major-modes
  '(inferior-python-mode python-mode)
  "A list of Python major modes.")
#+end_src

And another variable stores the above modes' hooks:
#+begin_src emacs-lisp :noweb-ref constants
(defconst python-major-mode-hooks
  (mapcar #'derived-mode-hook-name python-major-modes)
  "A list of Python major mode hooks.")
#+end_src

*** /Python/

#+begin_src emacs-lisp
(use-package python
  :straight (:type built-in)

  ;; Inform the bytecode compiler of the following functions.
  :functions python-set-comment-inline-offset

  ;; Add the following non-autoloading hooks.
  :gfhook
  <<python/gfhook>>

  ;; Evaluate the following code after loading `python'.
  :config
  <<python/config>>)
#+end_src

**** PEP 8-Compliant Comment Spacing

Precede inline (i.e. end-of-line) comments with two spaces, per PEP 8.

#+begin_src emacs-lisp :noweb-ref python/config
(defun python-set-comment-inline-offset ()
  (set (make-local-variable 'comment-inline-offset) 2)
  (setq comment-column 0))
#+end_src

#+begin_src emacs-lisp :noweb-ref python/gfhook
(python-major-mode-hooks #'python-set-comment-inline-offset)
#+end_src

**** PEP 8-Compliant Indentation

PEP 8 specifies that indentation should use units of 4 space characters.

#+begin_src emacs-lisp :noweb-ref python/config
(defun python-set-indent ()
  "Set PEP 8-compliant indentation settings."
  (setq-local indent-tabs-mode nil)
  (setq-local tab-width 4)
  (setq-local tab-stop-list nil))
#+end_src

It's not desirable to enforce this in Python files (where there may be an existing standard that differs from PEP 8), but it is useful to force in Python REPLs.
#+begin_src emacs-lisp :noweb-ref python/gfhook
('inferior-python-mode-hook #'python-set-indent)
#+end_src

**** /Relative Buffers/

Set the buffer name relative to the project root.
This is useful because the resulting buffer name corresponds directly to the file's module path.
#+begin_src emacs-lisp :noweb-ref relative-buffers/ghook
('python-mode-hook #'relative-buffers-mode)
#+end_src

**** Polymode
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref polymode/config
:END:

Use \src_emacs-lisp{python-mode} as primary (host) mode for Python buffers.
#+begin_src emacs-lisp
(define-hostmode poly-python-hostmode
  :mode 'python-mode)
#+end_src

***** reStructuredText for Doctstrings
:PROPERTIES:
:DESCRIPTION: Use \src_emacs-lisp{rst-mode} for Python's docstrings.
:END:

#+begin_src emacs-lisp
(defun poly-python-docstring-head (count)
  "Search for in direction specified by COUNT for Python docstring."
  (when (re-search-forward
         (rx line-start
             (zero-or-more blank) (group (= 3 "\""))
             (minimal-match (zero-or-more anything)) (group (= 3 "\""))
             (| line-end
                (sequence (zero-or-more blank) "#" (zero-or-more not-newline) line-end)))
         nil t count)
    (cons (match-beginning 1) (match-end 1))))
#+end_src

#+begin_src emacs-lisp
(defun poly-python-docstring-tail (count)
  (cons (match-beginning 2) (match-end 2)))
#+end_src

Define the secondary (inner) mode.
The delimiters are Python's plain (i.e. non-raw) multi-line string delimiters: three consecutive double quotes.
#+begin_src emacs-lisp
(define-innermode poly-rst-python-innermode
  :mode 'rst-mode
  :head-matcher #'poly-python-docstring-head
  :tail-matcher #'poly-python-docstring-tail
  :head-mode 'host
  :tail-mode 'host)
#+end_src

Define the actual Polymode.
#+begin_src emacs-lisp
(define-polymode poly-python-rst-mode
  :hostmode 'poly-python-hostmode
  :innermodes '(poly-rst-python-innermode))
#+end_src

Use the above Polymode as the default mode for Python buffers.
#+begin_src emacs-lisp :noweb-ref polymode/mode
;; ("\\.py\\'" . poly-python-rst-mode)
#+end_src

Add the resulting newly-created RST modes to /Flycheck/'s blacklist.
#+begin_src emacs-lisp :noweb-ref flycheck/custom/global-blacklist
'poly-python-rst-mode 'poly-rst-python-innermode 'rst-mode
#+end_src

**** Rainbow Identifiers

Enable \src_emacs-lisp{rainbow-identifiers-mode} for \src_emacs-lisp{python-mode} buffers.
#+begin_src emacs-lisp :noweb-ref rainbow-identifiers/ghook
('python-mode-hook nil)
#+end_src

**** /Smart Dash/

#+begin_src emacs-lisp :noweb-ref smart-dash/ghook
(python-major-mode-hooks nil)
#+end_src

**** /Tree-Sitter/

Enable tree-sitter in Python buffers.
#+begin_src emacs-lisp :noweb-ref tree-sitter/ghook
('python-mode-hook nil)
#+end_src

**** Per-Project REPLs

#+begin_src emacs-lisp :noweb-ref python/config
(defun python-shell-get-process-name (&rest _args)
  "Assemble a project-specific name for an inferior Python process."
  (if-let (((fboundp #'projectile-project-name))
           ((fboundp #'projectile-project-root))
           (project-root (projectile-project-root (buffer-file-name (current-buffer))))
           (project-name (projectile-project-name project-root)))
      (format "%s %s" python-shell-buffer-name project-name)
    python-shell-buffer-name))
#+end_src

*** /Python Black/

#+begin_src emacs-lisp
(use-package python-black
  ;; Load this package after the following packages.
  :after python

  ;; Load this package eagerly.
  :demand)
#+end_src

*** YAPFify

#+begin_src emacs-lisp
(use-package yapfify
  ;; Load this package after the following packages.
  :after python

  ;; Load this package eagerly.
  :demand)
#+end_src

*** Isort

isort is a utility for sorting Python imports.

The /[[Reformatter]]/ package is used to create an Emacs formatter using isort's command-line interface.
#+begin_src emacs-lisp :noweb-ref reformatter/config
(reformatter-define
 isort-format
 :program "isort"
 :args '("--atomic" "-"))
#+end_src

The defined hook can be added to all Python files.
#+begin_src emacs-lisp :noweb-ref reformatter/ghook
('python-mode-hook #'isort-format-on-save-mode)
#+end_src

*** /Rainbow Delimiters/

Enable \src_emacs-lisp{rainbow-delimiters-mode} in \src_emacs-lisp{python-mode} buffers.
#+begin_src emacs-lisp :noweb-ref rainbow-delimiters/ghook
('python-mode-hook nil)
#+end_src

*** Spell Check

#+begin_src emacs-lisp :noweb-ref wucou/ghook
('python-mode-hook #'wucuo-start)
#+end_src

*** /Highlight Indent Guides/

#+begin_src emacs-lisp :noweb-ref highlight-indent-guides/ghook
('python-mode-hook #'highlight-indent-guides-mode)
#+end_src

*** /Pytest/

#+begin_src emacs-lisp
(use-package pytest
  :after python
  :demand
  :custom
  (pytest-project-root-files '("pyproject.toml" "setup.cfg" "setup.py")))
#+end_src

*** /Pyright Language Server/

#+begin_src emacs-lisp
(use-package lsp-pyright
  :if (some (lambda (os) (eq system-type os)) '(darwin))

  :ghook
  ('python-mode-hook #'lsp-pyright-enable)

  :preface
  (setq lsp-pyright-multi-root nil)

  :config
  (defun lsp-pyright-enable ()
    "Load and enable this `lsp-pyright'."
    (require 'lsp-pyright)
    (lsp)))
#+end_src

** Groovy

*** Groovy Mode

#+begin_src emacs-lisp
(use-package groovy-mode
  :mode (("\\.gdsl\\'" . groovy-mode))

  :general
  (:keymaps 'groovy-mode-map
   "C-c C-p" #'run-groovy)

  :config
  (make-variable-buffer-local 'groovy-indent-offset))
#+end_src

Enable \src_emacs-lisp{rainbow-delimiters-mode} in Groovy buffers.
#+begin_src emacs-lisp :noweb-ref rainbow-delimiters/ghook
('groovy-mode-hook nil)
#+end_src

*** Polymode

**** Auto-Mode Alist

#+begin_src emacs-lisp :noweb-ref polymode/mode
("\\(\\.g\\(?:ant\\|roovy\\|radle\\)\\'\\)|Jenkinsfile" . poly-groovy-mode)
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref polymode/config
:END:

***** Sh Inner Mode
:PROPERTIES:
:DESCRIPTION: Use ~sh-mode~ for Groovey's ~sh~ strings.
:END:

#+begin_src emacs-lisp
(defun poly-groovy-sh-head (count)
  "Search in direction specified by COUNT for sh commands."
  (when (re-search-forward
         (rx (seq line-start (zero-or-more blank) "sh "
                  (group (seq (or (= 3 "\"") (= 3 "'")) (optional "\\\n")))
                  (minimal-match (zero-or-more anything))
                  (group (or (= 3 "\"") (= 3 "'")))))
         nil t count)
    (cons (match-beginning 1) (match-end 1))))
#+end_src

#+begin_src emacs-lisp
(defun poly-groovy-sh-tail (count)
  "Use match from `poly-groovy-sh-head' to determine end of sh command."
  (cons (match-beginning 2) (match-end 2)))
#+end_src

Define the secondary (inner) mode.
The delimiters are Groovy's multi-line string delimiters:
- three consecutive double quotes (") or
- three consecutive single quotes (').
#+begin_src emacs-lisp
(define-innermode poly-groovy-innermode
  :mode 'sh-mode
  :head-matcher #'poly-groovy-sh-head
  :tail-matcher #'poly-groovy-sh-tail
  :head-mode 'host
  :tail-mode 'host)
#+end_src

***** Groovy Host Mode
Define the primary (host) mode for Groovy files.
#+begin_src emacs-lisp
(define-hostmode poly-groovy-hostmode
  :mode 'groovy-mode)
#+end_src

Define the actual Polymode.
#+begin_src emacs-lisp
(define-polymode poly-groovy-mode
  :hostmode 'poly-groovy-hostmode
  :innermodes '(poly-groovy-innermode))
#+end_src

** Haskell

*** /Haskell Mode/

/Haskell Mode/ provides a major mode for Haskell.
#+begin_src emacs-lisp
(use-package haskell-mode)
#+end_src

*** /Hindent Mode/

#+begin_src emacs-lisp
(use-package hindent
  :ghook
  ('haskell-mode-hook #'hindent-mode))
#+end_src

** Lua

*** /Lua Mode/

#+begin_src emacs-lisp
(use-package lua-mode)
#+end_src

** Nix

*** /Nix Mode/

#+begin_src emacs-lisp
(use-package nix-mode
  :straight (nix-mode
             :type git
             :host github
             :repo "NixOS/nix-mode"
             :fork "lafrenierejm/nix-mode"
             :branch "reformatter")
  :mode "\\.nix\\'")
#+end_src

**** LSP Mode

Enable LSP Mode in Nix buffers.
#+BEGIN_SRC emacs-lisp :noweb-ref lsp-mode/ghook
('nix-mode-hook #'lsp-deferred)
#+END_SRC

** Ruby

*** /rbenv.el/

#+begin_src emacs-lisp
(use-package rbenv
  :if (executable-find "rbenv")
  :demand

  :custom
  (rbenv-installation-dir (f-parent (executable-find "rbenv")))
  (rbenv-show-active-ruby-in-modeline nil)

  :config
  (global-rbenv-mode))
#+end_src

*** /Seeing Is Believing/

#+begin_src emacs-lisp
(use-package seeing-is-believing
  :ghook
  ('ruby-mode-hook #'seeing-is-believing))
#+end_src

*** /Inf Ruby/

#+begin_src emacs-lisp
(use-package inf-ruby
  :ghook
  ('ruby-mode-hook #'inf-ruby-minor-mode)

  :general
  (:keymaps 'inf-ruby-minor-mode-map
   "C-c C-p" #'inf-ruby-console
   "C-c C-s" nil)

  :config
  (defun inf-ruby-console ()
    "Start an IRB REPL for the current project.

This is mostly copied from https://github.com/nonsequitur/inf-ruby."
    (interactive)
    (let* ((project-root (projectile-project-root))
           (project-name (projectile-project-name))
           (gemspec
            (car (file-expand-wildcards (format "%s/*.gemspec" (directory-file-name project-root)))))
           (with-bundler (file-exists-p (expand-file-name "Gemfile" project-root)))
           (base-command
            (if with-bundler
                (if (and gemspec (inf-ruby-file-contents-match gemspec "\\$LOAD_PATH"))
                    "bundle exec irb"
                  "bundle exec irb -I lib")
              "irb -I lib"))
           (name (and gemspec
                      (inf-ruby-file-contents-match
                       gemspec "\\.name[ \t]*=[ \t]*['\"]\\([^'\"]+\\)['\"]" 1)))
           args
           files)
      (unless (file-exists-p "lib")
        (error "The directory must contain a 'lib' subdirectory"))
      (let ((feature (and name (replace-regexp-in-string "-" "/" name))))
        (if (and feature (file-exists-p (concat "lib/" feature ".rb")))
            ;; There exists the main file corresponding to the gem name,
            ;; let's require it.
            (setq args (concat " -r " feature))
          ;; Let's require all non-directory files under lib, instead.
          (dolist (item (directory-files "lib"))
            (when (and (not (file-directory-p (format "lib/%s" item)))
                       (string-match-p "\\.rb\\'" item))
              (push item files)))
          (setq args
                (mapconcat
                 (lambda (file)
                   (concat " -r " (file-name-sans-extension file)))
                 files
                 ""))))
      (when (inf-ruby--irb-needs-nomultiline-p with-bundler)
        (setq base-command (concat base-command " --nomultiline")))
      (inf-ruby-console-run
       (concat base-command args
               " --prompt default --noreadline -r irb/completion")
       (format "Ruby IRB: %s" project-name)))))
#+end_src

*** /Smart Dash/

#+begin_src emacs-lisp :noweb-ref smart-dash/ghook
('ruby-mode-hook nil)
('inf-ruby-mode-hook nil)
#+end_src

** Rust
:PROPERTIES:
:URL:      https://www.rust-lang.org/
:END:

From [[https://en.wikipedia.org/wiki/Rust_(programming_language)][Wikipedia]]:
#+begin_quote
Rust is a multi-paradigm programming language focused on performance and safety, especially safe concurrency.
Rust is syntactically similar to C++, but provides memory safety without using garbage collection.

Rust was originally designed by Graydon Hoare at Mozilla Research, with contributions from Dave Herman, Brendan Eich, and others.
The designers refined the language while writing the Servo layout or browser engine, and the Rust compiler.
The compiler is free and open-source software dual-licensed under the MIT License and Apache License 2.0.
#+end_quote

*** /Rust Mode/

The project's README advertises /Rust Mode/ as providing:
#+begin_quote
- Syntax highlighting (for Font Lock Mode)
- Indentation
- Integration with Cargo, clippy and =rustfmt=
#+end_quote

#+begin_src emacs-lisp
(use-package rust-mode
  :mode ("\\.rs\\'" . rust-mode))
#+end_src

**** /Smart Dash Mode/

Enable \src_emacs-lisp{smart-dash-mode} in Rust buffers.
#+begin_src emacs-lisp :noweb-ref smart-dash/ghook
('rust-mode-hook nil)
#+end_src

**** LSP Mode
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref lsp-mode/ghook
:END:

Enable LSP Mode in Rust buffers.
#+BEGIN_SRC emacs-lisp
('rust-mode-hook #'lsp-deferred)
#+END_SRC

** Structured Query Language (SQL)

*** SQL

#+begin_src emacs-lisp
(use-package sql
  :straight (:type built-in)

  :demand

  :commands
  (sql-lafrenierejm-truncate-lines)

  :gfhook
  <<sql/gfhook>>

  :config
  <<sql/config>>)
#+end_src

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref sql/gfhook
:END:

Restrict each line of text to a single screen line.
#+begin_src emacs-lisp
('(sql-mode-hook sql-interactive-mode-hook) #'sql-truncate-lines)
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref sql/config
:END:

Define a function to restrict each line of text to a single screen line.
#+begin_src emacs-lisp
(defun sql-lafrenierejm-truncate-lines ()
  "Restrict each line of text to a single visual line."
  (setq truncate-lines t))
#+end_src

Alias the above function to remove my username.
My username is used above just to demarcate the function as a custom one.
#+begin_src emacs-lisp
(defalias 'sql-truncate-lines #'sql-lafrenierejm-truncate-lines)
#+end_src

**** /Smart Dash/

Enable `smart-dash-mode` in SQL buffers.
#+begin_src emacs-lisp :noweb-ref smart-dash/ghook
('(sql-interactive-mode-hook sql-mode-hook) #'smart-dash-mode)
#+end_src

*** SQL Up Mode

By convention, SQL uses all uppercase characters for the names of keywords and built-in functions.
/SQL Up Mode/ provides a minor mode that will automatically "upcase" known keywords and function names.

#+begin_src emacs-lisp
(use-package sqlup-mode
  ;; Add the following auto-loading hooks.
  :ghook
  ('(sql-interactive-mode-hook sql-mode-hook) #'sqlup-mode))
#+end_src

** X.509 Certificates

*** /X.509 Mode/

#+begin_src emacs-lisp
(use-package x509-mode)
#+end_src

** XML

*** /Highlight Indent Guides/

Enable indent guides in XML buffers.
#+begin_src emacs-lisp :noweb-ref highlight-indent-guides/ghook
('nxml-mode-hook #'highlight-indent-guides-mode)
#+end_src

*** Autoformat via =xmllint=

#+begin_src emacs-lisp :noweb-ref reformatter/config
(reformatter-define
  xml-format
  :program "xmllint"
  :args '("--format" "-"))
#+end_src

** Tool Command Language (Tcl)

From [[https://www.tcl-lang.org/][the language's homepage]]:
#+begin_quote
Tcl (Tool Command Language) is a very powerful but easy to learn dynamic programming language, suitable for a very wide range of uses, including web and desktop applications, networking, administration, testing and many more.
Open source and business-friendly, Tcl is a mature yet evolving language that is truly cross platform, easily deployed and highly extensible.
#+end_quote

*** /Tcl/

**** /Display Line Numbers/

Enable \src_emacs-lisp{display-line-numbers-mode} in \src_emacs-lisp{tcl-mode} buffers.
#+begin_src emacs-lisp :noweb-ref display-line-numbers/ghook
('tcl-mode-hook nil)
#+end_src

** TOML

*** /TOML Mode/

#+begin_src emacs-lisp
(use-package toml-mode
  :mode (("poetry\\.lock\\'" . toml-mode)))
#+end_src

** YAML

*** /YAML Mode/

#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src


**** /Highlight Indent Guides/

#+begin_src emacs-lisp :noweb-ref highlight-indent-guides/ghook
('yaml-mode-hook #'highlight-indent-guides-mode)
#+end_src

*** Ansible

#+begin_src emacs-lisp
(use-package ansible
  :after yaml-mode

  :demand

  :ghook
  ('ansible-mode-hook #'ansible-auto-decrypt-encrypt))
#+end_src

**** /Poly Ansible/

Polymode for Jina2 templating in YAML files.
#+begin_src emacs-lisp
(use-package poly-ansible
  :demand)
#+end_src

*** /Company Ansible/

#+begin_src emacs-lisp
(use-package company-ansible
  :compdef ansible-mode
  :company company-ansible)
#+end_src

*** Prettier

[[https://prettier.io/blog/2018/07/29/1.14.0.html][As of 1.1.4]], the [[https://prettier.io/][Prettier]] code formatter supports for YAML files.
Prettier's CLI be used via the /Reformatter/ package to automatically format YAML in a consistent way.
#+begin_src emacs-lisp :noweb-ref reformatter/config
(reformatter-define
  yaml-format
  :program "prettier"
  ;; https://prettier.io/docs/en/cli.html
  :args `("--parser" "yaml"
          "--write"
          "--config-precedence" "file-override"
          "--prose-wrap" "always"
          "--no-config"
          "--stdin-filepath" ,(buffer-file-name)))
#+end_src

** Tool Command Language (Tcl)
From [[https://www.tcl-lang.org/][the language's homepage]]:
#+begin_quote
Tcl (Tool Command Language) is a very powerful but easy to learn dynamic programming language, suitable for a very wide range of uses, including web and desktop applications, networking, administration, testing and many more.
Open source and business-friendly, Tcl is a mature yet evolving language that is truly cross platform, easily deployed and highly extensible.
#+end_quote

** TOML

*** /TOML Mode/

#+begin_src emacs-lisp
(use-package toml-mode)
#+end_src

** Automatic Indentation

*** /DTRT Indent/

#+begin_src emacs-lisp
(use-package dtrt-indent
  :demand

  :config
  (dtrt-indent-global-mode +1))
#+end_src

* Compilation

** /Compile/

Enable \src_emacs-lisp{smart-dash-mode} for \src_emacs-lisp{compilation-mode} buffers.
#+begin_src emacs-lisp :noweb-ref smart-dash/ghook
('compilation-mode-hook nil)
#+end_src

* Refactoring
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref refactoring
:END:

** Reformatter

#+begin_src emacs-lisp
(use-package reformatter
  ;; Add the following auto-loading hooks.
  :ghook
  <<reformatter/ghook>>

  ;; Inform the bytecode compiler of the following non-autoloaded functions.
  :functions reformatter-define

  ;; Evaluate the following code after this package has been loaded.
  :config
  <<reformatter/config>>)
#+end_src

** /RE Builder/

#+begin_src emacs-lisp
(use-package re-builder
  :custom
  (reb-re-syntax 'rx)

  :general
  (:keymaps 'reb-lisp-mode-map
   "C-x C-k" #'reb-quit)

  :config
  (defun reb-query-replace (to-string)
    (interactive
     (progn
       (barf-if-buffer-read-only)
       (list (query-replace-read-to
              (reb-target-binding reb-regexp)
              "Query replace"
              t))))
    (with-current-buffer reb-target-buffer
      (query-replace-regexp (reb-target-binding reb-regexp) to-string))))
#+end_src

** /Deadgrep/

#+begin_src emacs-lisp
(use-package deadgrep
  :if (executable-find "rg"))
#+end_src

* Web
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref web
:END:

** REST

*** REST Client

#+begin_src emacs-lisp
(use-package restclient
  :preface
  (defconst init-web/http-extension
    (rx ".http" string-end)
    "The filename extension \".http\".")

  :mode
  ("\\.http\\'" . restclient-mode))
#+end_src

*** Company REST Client

#+begin_src emacs-lisp
(use-package company-restclient
  :compdef restclient-mode
  :company company-restclient)
#+end_src

*** Polymode for REST Client

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref polymode/config
:END:

***** Emacs Lisp Inner Mode
Define the inner mode for Emacs Lisp sections of REST Client buffers.

#+begin_src emacs-lisp
(define-innermode poly-restclient/emacs-lisp-innermode
  :mode 'emacs-lisp-mode
  :head-mode 'host
  :tail-mode 'host)
#+end_src

Define a matcher for single-line expressions.
#+begin_src emacs-lisp
(define-innermode poly-restclient/emacs-lisp/single-line-innermode poly-restclient/emacs-lisp-innermode
  :head-matcher (rx line-start ":" (one-or-more (not (any " "))) " :=")
  :tail-matcher (rx "\n"))
#+end_src

Define a matcher for multi-line expressions.
#+begin_src emacs-lisp
(define-innermode poly-restclient/emacs-lisp/multi-line-innermode poly-restclient/emacs-lisp-innermode
  :head-matcher (rx line-start ":" (one-or-more (not (any " "))) " := <<\n")
  :tail-matcher (rx line-start "#\n"))
#+end_src

***** JSON Inner Mode
Define the inner mode for JSON sections.

#+begin_src emacs-lisp
(define-innermode poly-restclient/json-innermode
  :mode 'json-mode
  :head-mode 'body
  :tail-mode 'body
  :head-matcher (rx line-start "{" line-end)
  :tail-matcher (rx line-start "}" line-end))
#+end_src

***** Rest Client Parent Mode
#+begin_src emacs-lisp
(define-hostmode poly-restclient-hostmode
  :mode 'restclient-mode)
#+end_src

#+begin_src emacs-lisp
(define-polymode poly-restclient-mode
  :hostmode 'poly-restclient-hostmode
  :innermodes '(poly-restclient/emacs-lisp/single-line-innermode
                poly-restclient/emacs-lisp/multi-line-innermode
                poly-restclient/json-innermode))
#+end_src

** Browsing

*** /Counsel Web/

#+begin_src emacs-lisp
(use-package counsel-web
  :general
  <<counsel-web/general>>)
#+end_src

**** Minibuffer Web Searching

#+begin_src emacs-lisp :noweb-ref counsel-web/general
("s-s" #'counsel-web-suggest)
#+end_src

** Pastebins

*** /Webpaste/

#+begin_src emacs-lisp
(use-package webpaste
  :general
  ("C-c w p" #'webpaste-paste-buffer-or-region)

  :custom
  (webpaste-provider-priority '("paste.mozilla.org")))
#+end_src

* Project Management
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref project-management
:END:

** Jira

I often want to link directly to a Jira ticket from an Org buffer.
The following functions allow me to do so.

#+begin_src emacs-lisp
(defcustom jira-hostname nil
  "The hostname of the Jira server.")
#+end_src

#+begin_src emacs-lisp
(defun jira-lafrenierejm-url-of-ticket (name)
  "Return a Jira ticket's url given the ticket's NAME or &OPTION region from BEG to END."
  (interactive "MTicket: ")
  (format "https://%s/browse/%s" jira-hostname name))
#+end_src

#+begin_src emacs-lisp
(defalias 'jira-url-of-ticket #'jira-lafrenierejm-url-of-ticket)
#+end_src

#+begin_src emacs-lisp
(defun jira-lafrenierejm-org-link-ticket (name &optional beg end)
  "Create an Org link to the ticket NAME or &OPTION contained in region from BEG to END."
  (interactive
   (if (use-region-p)
       (list nil (region-beginning) (region-end))
     (list (read-string "Ticket: ") nil nil)))
  (let* ((name (or name
                   (buffer-substring-no-properties beg end)))
         (url (jira-url-of-ticket name)))
    (when (and beg end)
      (save-excursion
        (delete-region beg end)
        (goto-char beg)))
    (insert (format "[[%s][%s]]" url name))
    url))
#+end_src

#+begin_src emacs-lisp
(defalias 'jira-org-link-ticket #'jira-lafrenierejm-org-link-ticket)
#+end_src

* Windows and Frames
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref windows-and-frames
:END:

** Minions
#+BEGIN_QUOTE
A minor-mode menu for the mode line.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package minions
  ;; Load this package eagerly.
  :demand

  ;; Apply the following variable customizations.
  :custom
  (minions-mode-line-lighter "…")

  :config
  (minions-mode +1))
#+end_src

** Ace Window
From the README of Oleh Krehel (abo-abo)'s Ace Window package:
#+BEGIN_QUOTE
This package aims to take the speed and predictability of ~windmove~ and pack it into a single key binding, similar to ~other-window~.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package ace-window
  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  ("s-a" #'ace-window)

  ;; Apply the following customizations.
  :custom
  <<ace-window/custom>>

  ;; Evaluate the following code before loading this package.
  :init
  <<ace-window/init>>)
#+end_src

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ace-window/custom
:END:

Use home row characters to label windows.

#+begin_src emacs-lisp
(aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
#+end_src

Issue a read-char even for one window.
This allows more flexibility in what action is performed, i.e. more than just changing focus, at the cost of requiring more keystrokes for the single most common task of changing focus.

#+begin_src emacs-lisp
(aw-dispatch-always t)
#+end_src

Show the ace window key in the mode line.
This is useful for EXWM buffers which cannot display keys in the buffer itself.

#+begin_src emacs-lisp
(ace-window-display-mode t)
#+end_src

*** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ace-window/init
:END:

Bind Ace Window to =s-a= in EXWM.
#+begin_src emacs-lisp
(with-eval-after-load 'exwm
  (exwm-input-set-key (kbd "s-a") #'ace-window))
#+end_src

** Window

Add top-level =super= bindings to window management functions.
This allows the keys to be useful whenever the =s= modifier is made available to Emacs.
#+begin_src emacs-lisp :noweb-ref general/config
(general-define-key
 "s-o" #'delete-other-windows
 "s-x" #'delete-window
 "s-h" #'windmove-left
 "s-j" #'windmove-down
 "s-k" #'windmove-up
 "s-l" #'windmove-right
 "s-x" #'delete-window)
#+end_src

** /Popper/

#+begin_src emacs-lisp
(use-package popper
  :straight (:host github :repo "karthink/popper")
  :if (eq window-system 'ns)
  :demand
  :general
  ("C-`" #'popper-toggle-latest
   "s-`" #'popper-cycle
   "M-`" #'popper-toggle-type)

  :custom
  (popper-reference-buffers
   '(help-mode
     helpful-mode
     compilation-mode
     "^\\*Async Shell Command\\*\\'"
     "^\\*Messages\\*\\'"
     "^\\*Warnings\\*\\'"
     "^\\magit-process: .*\\'"
     "Output\\*\\'"))
  (popper-group-function #'popper-group-by-projectile)

  :config
  (popper-mode +1))
#+end_src

** /Frames Only Mode/

#+begin_src emacs-lisp
(use-package frames-only-mode
  :if (eq window-system 'pgtk)
  :demand
  :config
  (frames-only-mode +1))
#+end_src

* Secret Management
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref secret-management
:END:

** /Password Cache/

#+begin_src emacs-lisp
(use-package password-cache
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Apply the following customizations.
  :custom
  (password-cache-expiry nil "Do not expire cached passwords."))
#+end_src

** /Auth Source/

#+begin_src emacs-lisp
(use-package auth-source
  :straight (:type built-in)

  ;; Load this package eagerly.
  :demand

  ;; Apply the following customizations.
  :custom
  (auth-sources
   (cl-case system-type
     ('darwin
      '(macos-keychain-internet macos-keychain-generic))
     (t
      '("~/.authinfo" "~/.authinfo.gpg" "~/.netrc")))
   "Attempt to use system keychain."))
#+end_src

** Password Store ([[https://passwordstore.org][passwordstore.org]])

*** /Password Store/
#+begin_src emacs-lisp
(use-package password-store
  ;; Only load `password-store' if the following condition is met.
  :if
  <<password-store/if>>

  ;; Load `password-store' eagerly.
  :demand

  :custom
  (password-store-password-length 32 "Default password length"))
#+end_src

**** Conditional Loading (~:if~)
:PROPERTIES:
:DESCRIPTION: Only load ~password-store~ if the following code evaluates to non-~nil~.
:HEADER-ARGS+: :noweb-ref password-store/if
:END:

~password-store~ is only usable if =pass= is on the user's =$PATH=.

#+begin_src emacs-lisp
(executable-find "pass")
#+end_src

*** /Auth Source Pass/

Damien Cassou (DameinCassou)'s [[https://github.com/DamienCassou/auth-password-store][auth-source-pass]] package integrates Jason A. Donenfield (ZX2C4)'s [[https://www.passwordstore.org/][pass]] utility into Emacs's authentication mechanisms.

#+begin_src emacs-lisp
(use-package auth-source-pass
  ;; Only load this package if the following code evaluates to non-nil.
  :if
  <<auth-source-pass/if>>

  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<auth-source-pass/config>>)
#+end_src

**** Conditional Loading
:PROPERTIES:
:DESCRIPTION: Only load ~auth-source-pass~ if this condition is met.
:HEADER-ARGS+: :noweb-ref auth-source-pass/if
:END:

~auth-source-pass~ is only usable if =pass= is available in the user's =$PATH=.

#+begin_src emacs-lisp
(executable-find "pass")
#+end_src

**** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to evaluate after the parent package has been loaded
:HEADER-ARGS+: :noweb-ref auth-source-pass/config
:END:

Enable auth-source-password-store.

#+begin_src emacs-lisp
(auth-source-pass-enable)
#+end_src

** Ivy Pass

Ivy Pass is an Ivy interface for Password Store.

#+begin_src emacs-lisp
(use-package ivy-pass
  ;; Only load this package if the evaluation of the following code is non-nil.
  :if
  <<password-store/if>>

  ;; Load this package after the following packages.
  :after (:all  ivy password-store)

  ;; Add the following key bindings.
  :general
  ("C-x p" #'ivy-pass))
#+end_src

** EasyPG Assistant (EPA)

#+begin_src emacs-lisp
(use-package epa
  :straight (:type built-in)

  ;; Apply the following customizations.
  :custom
  <<epa/custom>>)
#+end_src

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref epa/custom
:END:

#+begin_src emacs-lisp
(epa-pinentry-mode 'loopback "Redirect all Pinentry queries to Emacs.")
#+end_src

* Footnotes

[fn:1] ~:ghook~ is one of the keywords added to \src_emacs-lisp{use-package} by /General/.
