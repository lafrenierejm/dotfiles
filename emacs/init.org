#+TITLE: Emacs Configuration
#+AUTHOR: Joseph LaFreniere (lafrenierejm)
#+EMAIL: joseph@lafreniere.xyz
#+PROPERTY: header-args+ :noweb yes

#+BEGIN_SRC emacs-lisp :tangle yes
;;; init.el --- Configure Emacs  -*- lexical-binding: t; -*-

;; Copyright (C) 2018 Joseph LaFreniere

;; Author: Joseph LaFreniere <joseph@lafreniere.xyz>
;; Version 0.1

;; <<license>>

;;; Commentary:
;; <<commentary>>

;;; Code:
<<dependencies>>
<<bootstrapping>>

;;; Customization:
<<customization>>

;;; Visual Interface:
<<interface>>

;;; Buffer Organization:
<<buffer-organization>>

;;; Literate Programming:
<<literate-programming>>

;;; Evil:
<<evil>>

;;; Minibuffer:
<<minibuffer>>

;;; TRAMP:
<<tramp>>

;;; Version Control:
<<version-control>>

;;; Completion
<<completion>>

;;; Diff:
<<diff>>

;;; Command Interpretation:
<<command-interpretation>>

;;; Static Analysis:
<<static-analysis>>

;;; Programming Languages:
<<programming-languages>>

;;; RESTful APIs:
<<restful-apis>>

;;; Windows and Frames
<<windows-and-frames>>

(provide 'init)
;;; init.el ends here
#+END_SRC

* License
** Code
All source code in this file is licensed under the [[http://www.gnu.org/licenses/gpl-3.0.html][GNU Public License v3]] or later.
#+BEGIN_SRC text :noweb-ref license
This file is not part of GNU Emacs.

Init is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

Init is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with GNU Emacs.
If not, see <https://www.gnu.org/licenses/>.
#+END_SRC

** Prose
All prose in this file is licensed under the [[http://www.gnu.org/licenses/fdl-1.3.html][GNU Free Documentation License (FDL) v1.3]].
#+BEGIN_SRC text
Copyright (C) 2019 Joseph LaFreniere.
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
#+END_SRC

* Commentary
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref commentary
:END:

#+BEGIN_SRC text
This is tangled source of Joseph LaFreniere (lafrenierejm)'s literate Emacs initialization file.
Please refer to `init.org' in this same file for full commentary.
#+END_SRC

* Bootstrapping
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref bootstrapping
:END:

GNU Emacs does not have the capability to use an Org file directly as its initialization file.
As such, this file needs to be tangled manually for its first use on a new system.
The following code ensures that this step is only needed once.

Before any other installed packages can be configured, Package must be loaded and \src_emacs-lisp{package-initialize} called.
#+BEGIN_SRC emacs-lisp :noweb-ref dependencies
(require 'package)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(package-initialize)
#+END_SRC

** Use Package

Next, Use Package is loaded.
This package provides the \src_emacs-lisp{use-package} macro for declarative loading of other packages.
#+BEGIN_SRC emacs-lisp
(require 'use-package)
#+END_SRC

Loading every package during Emacs's initialization is unnecessary and increases load time.
Instead, packages should only be loaded when a feature they provide is actually needed.
Use Package provides a feature to lazy-load packages by default:
#+BEGIN_SRC emacs-lisp
(setq use-package-always-defer t)
#+END_SRC

** Org
:PROPERTIES:
:CUSTOM_ID: bootstrap/org
:END:

After Use Package has been loaded, we can use it to configure all other packages.
Tangling this Org file for use as Emacs's initialization file requires features from the Org package.
As such, the below function is specified to belong to the =:config= section of Org's \src_emacs-lisp{use-package} declaration.
The process of tangling this file is to
1. Compare the modification time of this file to its tangled source, =./init.el=.
2. If this file is the more recent of the two, tangle this file then byte compile and load the result.
3. Otherwise the tangled file is the more recent, so byte compile and load it directly.

#+BEGIN_SRC emacs-lisp :noweb-ref org/config
(defun org-babel-tangle-init ()
  "Tangle Emacs's init file."
  (let ((el-file user-init-file)
        (org-file "~/.config/emacs/init.org")
        (load-byte-compile t))
    (if (not (file-exists-p el-file))
        ;; If the Emacs Lisp file does not exist, tangle the Org file.
        (org-babel-tangle-file org-file)
      ;; If the Emacs Lisp file does exist, compare the modification times.
      (let* ((org-modify (modify-time org-file))
             (el-modify (modify-time el-file)))
        ;; If the Org file was modified more recently, tangle it.
        (when (< el-modify org-modify)
          (org-babel-tangle-file org-file))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :noweb-ref org/config
(defun modify-time (file)
  (-> (file-attributes file)
      (file-attribute-modification-time)
      (float-time)))
#+END_SRC

** General
General provides convenience wrappers for setting keybindings and adding hooks.
It is highly compatible with Use Package and provides additional keywords to the \src_emacs-lisp{use-package} macro.
General is loaded now just so it can be used in all further \src_emacs-lisp{use-package} declarations.
The ~:demand~ keyword is used to ensure General is loaded eagerly.
#+BEGIN_SRC emacs-lisp
(use-package general
  :demand)
#+END_SRC

* Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref customization
:END:

Emacs has a customization system distinct from simply \src_emacs-lisp{setq}-ing variables.
By default, any customizations made using that system are appended to the bottom of Emacs's init file.
This is controlled by the value of the \src_emacs-lisp{custom-file} variable.
That variable is provided as part of the Cus Edit package, so we will perform modifications inside the \src_emacs-lisp{use-package} declaration of Cus Edit.

Viewing the help documentation for \src_emacs-lisp{custom-file} (via =C-h v custom-file RET=) tells us
#+BEGIN_QUOTE
The default is nil, which means to use your init file as specified by \src_emacs-lisp{user-init-file}.
If the value is not \src_emacs-lisp{nil}, it should be an absolute file name.

You can set this option through Custom, if you carefully read the last paragraph below.
However, usually it is simpler to write something like the following in your init file:

#+BEGIN_EXAMPLE emacs-lisp
(setq custom-file "~/.emacs-custom.el")
(load custom-file)
#+END_EXAMPLE
#+END_QUOTE

That \src_emacs-lisp{setq} and \src_emacs-lisp{load} need to be evaluated /after/ Cus Edit has been loaded, so the expressions should go in the ~:config~ block of the \src_emacs-lisp{use-package} declaration.
Additionally, \src_emacs-lisp{custom-file} needs to exist before it is loaded.
The file can be created with the function \src_emacs-lisp{f-touch}.

\src_emacs-lisp{f-touch}, in turn, is provided by the package F.
Since we are relying a function from an external package when we're loading Cus Edit, we need to inform \src_emacs-lisp{use-package} of that fact and tell it to load Cus Edit only after F has been loaded.
This is done with the ~:after~ keyword of \src_emacs-lisp{use-package}.

Additionally, we want Cus Edit to always be loaded (not just when we interactively use something it provides).
\src_emacs-lisp{use-package} needs to told to load Cus Edit eagerly (as opposed to lazily), which is accomplished with the ~:demand~ keyword.

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :after f

  :demand

  :config
  (let ((path (expand-file-name
               "custom.el"
               (file-name-directory user-init-file))))
    (f-touch path)
    (setq custom-file path)
    (load custom-file)))
#+END_SRC

/F/ is not built-in to GNU Emacs, so it must be downloaded by some package manager separately.
Further \src_emacs-lisp{f-touch} is not marked as an auto-loaded function in /F/ (this too can be discovered by viewing the function's help), so /F/ must also be loaded eagerly.

#+BEGIN_SRC emacs-lisp
(use-package f
  :demand)
#+END_SRC

* Visual Interface
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref interface
:END:

Emacs is fundamentally a user interface built around plain text.
Given the focus on plain text, several of Emacs's default modes can be disabled.
These are
- \src_emacs-lisp{menu-bar-mode},
- \src_emacs-lisp{tool-bar-mode}, and
- \src_emacs-lisp{scroll-bar-mode}.


#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

The splash screen, startup message, and scratch message also serve little use, so they too can be disabled.
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      inhibit-startup-message t
      initial-scratch-message nil)
#+END_SRC

** Font
What are colloquially known as "fonts" Emacs refers to "faces".
Google's Noto family of has the best glyph coverage that I am aware of, so I try to use it everywhere I can.
Alan Third has a nice write-up in his [[https://idiocy.org/emacs-fonts-and-fontsets.html]["Emacs, fonts and fontsets" post on idiocy.org]] of how to enable Noto fonts everywhere and simultaneously reduce Emacs's need to scour the system for fallback font sets.
The /Faces/ package provides this functionality, so all font setup can can occur within /Faces/'s \src_emacs-lisp{use-package}.

#+BEGIN_SRC emacs-lisp
(use-package faces
  :demand

  :config
  (when (member "Noto Sans" (font-family-list))
    (set-face-attribute 'default nil :font "Noto Sans Mono")
    (set-fontset-font t 'latin "Noto Sans")

    ;; East Asia: 你好, 早晨, こんにちは, 안녕하세요
    (set-fontset-font t 'han "Noto Sans CJK SC Regular")
    (set-fontset-font t 'kana "Noto Sans CJK JP Regular")
    (set-fontset-font t 'hangul "Noto Sans CJK KR Regular")
    (set-fontset-font t 'cjk-misc "Noto Sans CJK KR Regular")

    ;; South East Asia: ជំរាបសួរ, ສະບາຍດີ, မင်္ဂလာပါ, สวัสดีครับ
    (set-fontset-font t 'khmer "Noto Sans Khmer")
    (set-fontset-font t 'lao "Noto Sans Lao")
    (set-fontset-font t 'burmese "Noto Sans Myanmar")
    (set-fontset-font t 'thai "Noto Sans Thai")

    ;; Africa: ሠላም
    (set-fontset-font t 'ethiopic "Noto Sans Ethiopic")

    ;; Middle/Near East: שלום, السّلام عليكم
    (set-fontset-font t 'hebrew "Noto Sans Hebrew")
    (set-fontset-font t 'arabic "Noto Sans Arabic")

    ;;  South Asia: નમસ્તે, नमस्ते, ನಮಸ್ಕಾರ, നമസ്കാരം, ଶୁଣିବେ,
    ;;              ආයුබෝවන්, வணக்கம், నమస్కారం, བཀྲ་ཤིས་བདེ་ལེགས༎
    (set-fontset-font t 'gujarati "Noto Sans Gujarati")
    (set-fontset-font t 'devanagari "Noto Sans Devanagari")
    (set-fontset-font t 'kannada "Noto Sans Kannada")
    (set-fontset-font t 'malayalam "Noto Sans Malayalam")
    (set-fontset-font t 'oriya "Noto Sans Oriya")
    (set-fontset-font t 'sinhala "Noto Sans Sinhala")
    (set-fontset-font t 'tamil "Noto Sans Tamil")
    (set-fontset-font t 'telugu "Noto Sans Telugu")
    (set-fontset-font t 'tibetan "Noto Sans Tibetan")))
#+END_SRC

When working with prose, I prefer to use a variable-pitch (as opposed to monospace) face.
Frequently, though, some aspects of a mostly-prose document are better presented in monospace.
An example of this is the code blocks in this Org file.
For mixing the two pitches I use the /Mixed Pitch/ package by Alex Branham.

#+BEGIN_SRC emacs-lisp
(use-package mixed-pitch
  :ghook
  ('(org-mode-hook text-mode-hook) #'mixed-pitch-mode))
#+END_SRC

** Rainbow Identifiers
Rainbow Identifiers provides a minor mode that highlights identifiers based on their names.
The highlight color of each identifier is chosen based on the hash of the identifier's name.
The package's source is available at [[https://github.com/Fanael/rainbow-identifiers][github.com/Fanael/rainbow-identifiers]].

I want this package to be enabled when programming, so I enable it for \src_emacs-lisp{prog-mode} and all major modes that inherit from \src_emacs-lisp{prog-mode}, which effectively covers all programming language major modes.
This is done by adding \src_emacs-lisp{rainbow-identifiers-mode} to \src_emacs-mode{prog-mode-hook}, performed below by the arguments to the ~:ghook~ keyword[fn:1].

#+BEGIN_SRC emacs-lisp
(use-package rainbow-identifiers
  :ghook
  ('prog-mode-hook #'rainbow-identifiers-mode)

  :custom
  <<rainbow-identifiers/custom>>)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref rainbow-identifiers/custom
:END:

Only use Rainbow Identifiers to highlight (read: color) variable names.

#+BEGIN_SRC emacs-lisp
(rainbow-identifiers-faces-to-override
 '(font-lock-constant-face
   font-lock-type-face
   font-lock-function-name-face
   font-lock-variable-name-face
   font-lock-keyword-face
   font-lock-builtin-face))
#+END_SRC

** Rainbow Delimiters
Rainbow Delimters provides a minor mode that highlights delimeters such as parantheses based on their depth.
The highlight color of each level is distinct.
The package's source is available at [[https://github.com/Fanael/rainbow-delimiters][github.com/Fanael/rainbow-delimeters]].

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  ;; Load this package eagerly.
  :demand

  :ghook
  ('prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Line Wrapping
Out of the box, Emacs will fill paragraph to 72 characters.
Most projects that care about line width adhere to an 80 character (79 + line feed) maximum width, so to reduce the amount of per-project customization we can set the default value to 80.
#+BEGIN_SRC emacs-lisp
(custom-set-default 'fill-column 80)
#+END_SRC

** Display Line Numbers

#+BEGIN_SRC emacs-lisp
(use-package display-line-numbers
  ;; Only load this package if the following code evaluates to non-nil.
  :if
  <<display-line-numbers/if>>

  ;; Add the following auto-loading hooks.
  :ghook
  ('prog-mode-hook #'display-line-numbers-mode))
#+END_SRC

*** Conditional Loading
:PROPERTIES:
:DESCRIPTION: Define condition for loading ~display-line-numbers~.
:HEADER-ARGS+: :noweb-ref display-line-numbers/if
:END:

~display-line-numbers~ was added in GNU Emacs 26.1.

#+BEGIN_SRC emacs-lisp
(version< "26.1" emacs-version)
#+END_SRC

* Buffer Organization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref buffer-organization
:END:

** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  <<projectile/general>>

  ;; Customize the following variables.
  :custom
  <<projectile/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<projectile/config>>)
   #+END_SRC

*** Auto-Loading Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref projectile/general
:END:

#+BEGIN_SRC emacs-lisp
(:keymaps 'projectile-mode-map
 "C-c p" 'projectile-command-map)
#+END_SRC

*** Variable Customizations (~:custom~)
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref projectile/custom
:END:

Enable ~projectile-mode~ globally.
#+BEGIN_SRC emacs-lisp
(projectile-mode t)
#+END_SRC

When switching projects, default to opening the ~vc-dir~ at the root of the project.
#+BEGIN_SRC emacs-lisp
(projectile-switch-project-action #'projectile-vc)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref projectile/config
:END:

Use Ivy's integration.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ivy
  (setq projectile-completion-system 'ivy))
#+END_SRC

** Counsel Projectile

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  ;; Load this package after the following packages.
  :after (:all counsel projectile)

  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  (:keymaps 'projectile-mode-map
            "C-x C-f" #'counsel-projectile-find-file
            "C-x C-b" #'counsel-projectile-switch-to-buffer
            "C-x C-d" #'counsel-projectile-find-dir)

  ;; Customize the following variables.
  :custom
  <<counsel-projectile/custom>>)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref counsel-projectile/custom
:END:

Enable ~counsel-projectile-mode~ globally.
#+BEGIN_SRC emacs-lisp
(counsel-projectile-mode t)
#+END_SRC

** Perspective

/Perspective/ provides tagged workspaces.
#+BEGIN_SRC emacs-lisp
(use-package perspective
  ;; Load this package eagerly.
  :demand

  ;; Customize variables.
  :custom
  (persp-mode t "Enable perspective mode globally"))
#+END_SRC

** Operations on Current Buffer
*** Rename
:PROPERTIES:
:DESCRIPTION: Rename a buffer and its visited file, if any.
:END:

#+BEGIN_SRC emacs-lisp
(defun current-buffer/rename (new-file-name &optional buffer ok-if-already-exists)
  "Rename a buffer and the file it's visiting, if any, to NEW-FILE-NAME.

If BUFFER is not provided, use the current buffer.
If BUFFER is a string, use that string as the name of the buffer to rename.
If BUFFER is a buffer object, use it as the subject of the rename.

OK-IF-ALREADY-EXISTS is passed directly to `rename-file'."
  ;; If called interactively...
  (interactive (let* ((buffer (current-buffer~get-buffer "rename"))
                      (new-file-name
                       (current-buffer~read-file-name "rename"
                                                      (buffer-name buffer)))
                      (ok-if-already-exists 1)) ; Request confirmation before overwrite.
                 (list new-file-name buffer ok-if-already-exists)))
  (let* ((buffer (current-buffer~obj-to-buffer buffer))
         (file (buffer-file-name buffer))
         (orig-buffer-name (buffer-name buffer))
         (new-buffer-name nil))
    (cond
     ;; If FILE is tracked in VC...
     ((vc-backend file)
      ;; Rename FILE through VC.
      (vc-rename-file file new-file-name))
     ;; Else if FILE exists at all...
     ((file-exists-p file)
      ;; Rename FILE normally.
      (rename-file file new-file-name ok-if-already-exists)))
    ;; Rename BUFFER, using `generate-new-buffer-name' if necessary.
    ;; Record the name actually assigned.
    (setq new-buffer-name (rename-buffer new-file-name t))
    (set-visited-file-name new-file-name t t)
    (message "Renamed buffer %s to %s and its file to %s."
             orig-buffer-name new-buffer-name
             new-file-name)))
#+END_SRC

Now bind the above function.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-r") #'current-buffer/rename)
#+END_SRC

*** Delete
:PROPERTIES:
:DESCRIPTION: Delete a buffer and its visited file, if any.
:END:

#+BEGIN_SRC emacs-lisp
(defun current-buffer/delete (&optional buffer)
  "Delete the file a buffer is visiting, if any, then kill the buffer.

If no optional BUFFER is provided, use the current buffer.
If the optional BUFFER is a string, use that string as the name of the buffer to use.
If the optional BUFFER is a symbol, prompt the user for the name of the buffer to use."
  ;; If called interactively...
  (interactive (list (current-buffer~get-buffer "delete")))
  (let* ((buffer (current-buffer~obj-to-buffer buffer))
         (file (buffer-file-name buffer)))
    (when file
      (cond
       ;; If FILE is tracked in VC, delete it through VC.
       ((vc-backend file)
        (vc-delete-file file))
       ;; Else if FILE exists, delete it normally.
       ((file-exists-p file)
        (delete-file file 'trash)))
      (message "Deleted file %s" file))
    (kill-buffer buffer)))
#+END_SRC

Now bind the above function.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-S-d") #'current-buffer/delete)
#+END_SRC

*** Copy

#+BEGIN_SRC emacs-lisp
(defun current-buffer/copy
    (new-file-name
     &optional buffer confirm-overwrite keep-time preserve-uid-gid perserve-permissions)
  "Copy the file a buffer is visiting, if any, to NEW-FILE-NAME and open the copy in a new buffer.

If BUFFER is not provided, use the current buffer.
If BUFFER is a string, use that string as the name of the buffer to rename.
If BUFFER is a buffer object, use it as the subject of the rename.

If the specified buffer is not visiting a file, write the buffer's contents to NEW-FILE-NAME.

If CONFIRM-OVERWRITE is non-nil, this function asks for confirmation before overwiting an existing file at NEW-FILE-NAME.
Interactively, confirmation is required unless a prefix argument is supplied.

KEEP-TIME, PRESERVE-UID-GID, and PRESERVE-PERMISSIONS are passed directly to `copy-file'."
  ;; If called interactively...
  (interactive (let* ((buffer (current-buffer~get-buffer "copy"))
                      (new-file-name (current-buffer~read-file-name "copy" (buffer-name buffer)))
                      ;; Request confirmation before overwriting an existing file, unless called with a prefix argument.
                      (confirm-overwrite (if current-prefix-arg t 1)))
                 (list new-file-name buffer confirm-overwrite)))
  (let* ((buffer (current-buffer~obj-to-buffer buffer))
         (file (buffer-file-name buffer))
         (new-buffer-name (buffer-name buffer)))
    ;; If BUFFER is not visiting a file...
    (if (not (file-exists-p file))
        ;; Write the content of BUFFER to NEW-FILE-NAME.
        (write-file new-file-name confirm-overwrite)
      ;; Else...
      ;; Copy the visited file FILE to NEW-FILE-NAME.
      (copy-file file
                 new-file-name
                 ;; If CONFIRM-OVERWRITE is non-nil...
                 (if confirm-overwrite
                     ;; Ask for confirmation before overwriting.
                     1
                   ;; Else overwrite without prompting.
                   t)
                 keep-time
                 preserve-uid-gid
                 perserve-permissions)
      ;; Open NEW-FILE-NAME in a separate buffer.
      (setq new-buffer-name (buffer-name (find-file-noselect new-file-name))))
    (message "Wrote buffer %s to %s and opened the new file as %s."
             (buffer-name buffer) new-file-name new-buffer-name)))
#+END_SRC

Now bind the above function.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-c") #'current-buffer/copy)
#+END_SRC

*** Revert

#+BEGIN_SRC emacs-lisp
(defun current-buffer/revert (&optional noconfirm)
  "Replace current buffer text with the text of the visited file on disk.

If NOCONFIRM is nil, prompt the user before reverting a modified buffer.
NOCONFIRM is set to t when called interactively with a prefix argument."
  (interactive (list current-prefix-arg))
  (revert-buffer :ignore-auto (or noconfirm (not (buffer-modified-p)))))
#+END_SRC

Now bind the above function.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-g") #'current-buffer/revert)
#+END_SRC

*** Kill

**** Define Function
:PROPERTIES:
:DESCRIPTION: Kill the current buffer.
:END:

#+BEGIN_SRC emacs-lisp
(defun current-buffer/kill (&optional ignore-buffer-modified-p)
  "Kill the current buffer.

If IGNORE-BUFFER-MODIFIED-P is nil, prompt the user before killing a modified buffer.
IGNORE-BUFFER-MODIFIED-P is set to t when called interactively with a prefix argument."
  (interactive (list current-prefix-arg))
  (when ignore-buffer-modified-p
    (set-buffer-modified-p nil))
  (kill-this-buffer))
#+END_SRC

**** Bind Function

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-k") #'current-buffer/kill)
#+END_SRC

*** Place Visited File Name on Kill Ring

**** Define Function

#+BEGIN_SRC emacs-lisp
(defun current-buffer/yank-path ()
  "Place the path of the current buffer's visited file on the kill ring."
  (interactive)
  (when-let* ((filepath (or (buffer-file-name) default-directory))
              (expanded-filename (expand-file-name filepath)))
    (kill-new expanded-filename)
    (message "Copied buffer path '%s' to the clipboard." expanded-filename)))
#+END_SRC

**** Bind Function

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-y") #'current-buffer/yank-path)
#+END_SRC

*** Visit Current Directory in Dired

**** Define Function

#+BEGIN_SRC emacs-lisp
(defun current-buffer/dired ()
  "Open the current directory in Dired."
  (interactive)
  (when-let* ((file-path (or (buffer-file-name) default-directory))
              (directory-path (file-name-directory file-path)))
    (dired directory-path)))
#+END_SRC

**** Bind Function

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-d") #'current-buffer/dired)
#+END_SRC

* Literate Programming
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref literate-programming
:END:

The [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] programming is a programming paradigm introduced by Donald Knuth in which the standard precedence of code and explanatory prose are flipped.
Whereas the standard programming paradigm has a source documents' text "defaulting" to source code, literate programming assumes that text is intended for human consumption (the role normally filled by comments) unless it is explicitly demarcated as source code.
A literate document can then be /tangled/ into a source-only file.

** Polymode
:PROPERTIES:
:CUSTOM_ID: polymode
:END:

Polymode is a framework for supporting multiple major modes (MMM) inside a single Emacs buffer.
This can benefit both literate and traditional programming by allowing one to code blocks and docstrings, respectively, with the full features of dedicated major modes.

#+BEGIN_SRC emacs-lisp
(use-package polymode
  :demand)
#+END_SRC

** Org Mode
Strong support for literate programming is provided by Org mode's features.

*** Org
:PROPERTIES:
:CUSTOM_ID: bootstrap/org
:END:

Note that although \src_emacs-lisp{use-package} is used below, the /Org/ package should already be loaded due to the \src_emacs-lisp{require} call in [[#bootstrap/org]].

#+BEGIN_SRC emacs-lisp
(use-package org
  :demand

  :gfhook
  <<org/gfhook>>

  :config
  <<org/config>>)
#+END_SRC

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref org/gfhook
:END:

Enable the following minor modes in all Org buffers:
- \src_emacs-lisp{flyspell-mode} for on-the-fly spell checking.
- \src_emacs-lisp{org-indent-mode} to indent text according to outline structure.
- \src_emacs-lisp{visual-line-mode} to naturally wrap long lines.


#+BEGIN_SRC emacs-lisp
('org-mode-hook (list #'flyspell-mode #'org-indent-mode #'visual-line-mode))
#+END_SRC

**** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref org/custom
:END:

Determine how leading whitespace characters in source blocks are treated.
#+BEGIN_SRC emacs-lisp
(org-src-preserve-indentation t "Preserve source blocks' indentation.")
(org-edit-src-content-indentation 0 "Do not add any additional indentation to source blocks in Org buffers.")
#+END_SRC

Determine where source blocks are opened.
Note that this is effectively deprecated by Polymode;  I set it here only as a fallback.
#+BEGIN_SRC emacs-lisp
(org-src-window-setup 'current-window "Edit source blocks in the current window.")
#+END_SRC

Determine what is required to follow links.
#+BEGIN_SRC emacs-lisp
(org-return-follows-link t "Follow links with just RET.")
#+END_SRC

Set whether confirmation is required before evaluating source blocks.
#+BEGIN_SRC emacs-lisp
(org-confirm-babel-evaluate nil "Do not require confirmation before evaluating source blocks.")
#+END_SRC

Set the workflow states.
#+BEGIN_SRC emacs-lisp
(org-todo-keywords '((sequence "TODO" "FEEDBACK" "VERIFY" "|"
                               "DELEGATED" "DONE(d!/!)" "|"
                               "CANCELED")))
#+END_SRC

*** Poly Org

/Poly Org/ provides Polymode definitions for Org buffers.
#+BEGIN_SRC
(use-package poly-org)
#+END_SRC

*** Ox LaTeX

/Ox/ (Org eXport) allows exporting Org files such as this one.
/Ox LaTeX/ builds uses that framework to export to (La)TeX.

#+BEGIN_SRC emacs-lisp
(use-package ox-latex
  :config
  <<ox-latex/config>>)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ox-latex/config
:END:

If =latexmk= and its Perl dependency exist in =PATH=, use =latexmk= with a LuaLaTeX backend to compile TeX files.
#+BEGIN_SRC emacs-lisp
(when (and (executable-find "latexmk")
           (executable-find "perl"))
  (general-setq-default org-latex-pdf-process '("latexmk -lualatex -f %f")))
#+END_SRC

*** Smartparens
:PROPERTIES:
:END:

:PROPERTIES:
:HEADER-ARGS+: smartparents/config
:END:

The equals sign (\=), tilde (\~), and forward slash (/) are used by Org syntax to wrap inline monospace, code, text, and italics respectively.
I want them to be automatically paired in Org buffers.
#+BEGIN_SRC emacs-lisp
(sp-local-pair 'org-mode "=" "=")
(sp-local-pair 'org-mode "~" "~")
(sp-local-pair 'org-mode "/" "/")
#+END_SRC

Meanwhile, when writing prose I tend to use the single prime (') primarily as an apostrophe in English prose so I want it to /not/ be paired.
#+BEGIN_SRC emacs-lisp
(sp-local-pair 'org-mode "'" nil :actions nil)
#+END_SRC

*** Evil Org

/Evil Org/ adds a minor mode that provides [[Evil]] keybindings for common Org mode actions.
#+BEGIN_SRC emacs-lisp
(use-package evil-org
  ;; Load this package after the following packages.
  :after (:all evil org)

  ;; Add the following auto-loading hooks.
  :ghook
  <<evil-org/ghook>>

  ;; Inform the bytecode compiler of the following functions.
  :functions
  (evil-org-set-key-theme)

  ;; Apply the following variable customizations.
  :custom
  <<evil-org/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<evil-org/config>>)
#+END_SRC

**** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/ghook
:END:

Enable Evil Org mode in all Org mode buffers.
#+BEGIN_SRC emacs-lisp
('org-mode-hook #'evil-org-mode)
#+END_SRC

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/custom
:END:

Specify the key themes to enable.
#+BEGIN_SRC emacs-lisp
(evil-org-key-theme
 '(calendar
   navigation
   insert
   textobjects))
#+END_SRC

Retain selection after typing =<= or =>= in visual state.
#+BEGIN_SRC emacs-lisp
(evil-org-retain-visual-state-on-shift t)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/config
:END:

Apply the keybindings specified in ~evil-org-key-theme~.
#+BEGIN_SRC emacs-lisp
(evil-org-set-key-theme)
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  ;; Inform the bytecode compiler of the following variables.
  :defines markdown-mode-hook

  ;; Inform the bytecode compiler of the following functions.
  :functions markdown-mode-spaces-only

  ;; Established deferred binding within `auto-mode-alist'.
  :mode
  (("README\\.md\\'" . gfm-mode)
   ("\\.md\\'" . markdown-mode))

  ;; Add the following non-autoloading hooks.
  :gfhook
  ('markdown-mode-hook #'markdown-mode-spaces)

  :config
  (defun markdown-mode-spaces-only ()
    (setq indent-tabs-mode nil)))
#+END_SRC

* Evil
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil
:CUSTOM_ID: evil
:END:

/Evil/ aims to implement Vi's user features, most notably Vi's modal keyboard interface, in Emacs Lisp for use in Emacs.
I prefer Vi's keybindings to Emacs's, so I enable Evil everywhere I can.
#+BEGIN_SRC emacs-lisp
(use-package evil
  ;; Load this package eagerly.
  :demand

  ;; Add the following autoloading hooks.
  :ghook
  <<evil/ghook>>

  ;; Apply the following variable customizations.
  :custom
  <<evil/custom>>

  ;; Set the following keybindings.
  :general
  <<evil/general>>

  ;; Evaluate the following code before loading this package.
  :init
  <<evil/init>>

  ;; Evaluate the following code after loading this package.
  :config
  <<evil/config>>)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/custom
:END:

Determine whether to enable Evil in minibuffers.
#+BEGIN_SRC emacs-lisp
(evil-want-minibuffer t "Enable Evil in minibuffers.")
#+END_SRC

*** Set Keybindings (~:general~)
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/general
:END:

Do not allow =C-z= to enter Emacs mode.
Instead, make it a noop as far as Evil is concerned.
#+BEGIN_SRC emacs-lisp
(:states (list 'normal 'insert 'visual 'replace 'operator 'motion)
 "C-z" nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(:states '(motion normal visual)
 "H" #'init-evil/beginning-of-maybe-line
 "L" #'init-evil/end-of-maybe-line
 (kbd "SPC") #'evil-toggle-fold)
#+END_SRC

Bind =:= to ~eval-expression~ to evaluate one-off Emacs Lisp expressions.

#+BEGIN_SRC emacs-lisp
(:states '(motion normal replace visual)
 ":" #'eval-expression)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(:states 'normal
 "Y" #'init-evil/evil-yank-to-end-of-line)
#+END_SRC

*** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/init
:END:

Allow use of Evil Collection.
#+BEGIN_SRC emacs-lisp
(setq-default evil-want-integration t)
(setq-default evil-want-keybinding nil)
#+END_SRC

*** Post-Load Evaluation (~:config~)
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/config
:END:

Enable Evil by default in all modes.
#+BEGIN_SRC emacs-lisp
(evil-mode 1)
#+END_SRC

**** Define =evil-yank-to-end-of-line=
#+BEGIN_SRC emacs-lisp
(defun init-evil/evil-yank-to-end-of-line ()
  "Yank the characters from point to the end of the current line."
  (interactive)
  (evil-yank (point) (point-at-eol)))
#+END_SRC

**** Semantic Movement Within Lines
***** Define ~back-to-comment~
The following code is based on [[http://stackoverflow.com/a/14245964%0A][a StackOverflow answer]] by user [[https://stackoverflow.com/users/387076/gilles][Gilles]].
All code posted to StackOverflow.com is licensed under CC BY-SA 3.0, so the following derived code is also CC BY-SA 3.0-licensed.

#+BEGIN_SRC emacs-lisp
(defun init-evil/back-to-comment ()
  "Move point to the beginning of the comment in the current line.

If the current line does not contain a comment, then point will stay
in place and the function will return nil.  Otherwise the function
will return t."
  (interactive "^")
  (save-match-data
    ;; Record the position of the beginning of the line.
    (let ((old-point (point))
          (bol (progn
                 (beginning-of-line)
                 (point))))
      ;; Go to the end of the line.
      (end-of-line)
      ;; Look backward from there for a comment.
      (if (and comment-start-skip
               (comment-search-backward bol 'noerror))
          (progn
            (message "Comment found")
            ;; Go to the start of the comment's delimeter.
            (search-backward-regexp comment-start-skip bol 'noerror)
            ;; Go the start of any immediately prior whitespace.
            (skip-syntax-backward " \t" bol)
            ;; Return t.
            t)
        ;; Return point to its previous location.
        (goto-char old-point)
        ;; Return nil.
        nil))))
#+END_SRC

***** Define ~init-evil/back-totext~
#+BEGIN_SRC emacs-lisp
(defun init-evil/back-totext ()
  "Move point to the last non-whitespace character on this line."
  (interactive)
  ;; Move point to the last character on this line.
  (move-end-of-line nil)
  ;; Move backward for non-whitesapce character.
  (re-search-backward "^\\|[^[:space:]]")
  ;; Move forward one character.
  (forward-char))
#+END_SRC

***** Define ~beginning-of-maybe-line~
~beginning-of-maybe-line~ moves ~point~ toward the beginning of the current line incrementally by semantic region.
The following semantic elements are considered:
1. Comment
2. Source code
3. Indentation (leading whitespace)

The following code is based on [[https://stackoverflow.com/a/145359/8468492][a StackOverflow answer]] by user [[https://stackoverflow.com/users/8355/cjm][cjm]].
All code posted to StackOverflow.com is licensed under CC BY-SA 3.0, so the following derived code is also CC BY-SA 3.0-licensed.

#+BEGIN_SRC emacs-lisp
(defun init-evil/beginning-of-maybe-line ()
  "Move point to first non-whitespace character or beginning of the line.

Move point to the first non-whitespace character on the line.  If the
point was already at that position, move point to the beginning of the
line."
  (interactive)
  (let ((old-point (point)))            ; current position
    ;; Go to the beginning of a comment.  If there is not comment or
    ;; if point is already at or to the left of the comment...
    (when (or (not (init-evil/back-to-comment))
              (<= old-point (point)))
      ;; Go to the first non-whitespace column.
      (back-to-indentation)
      ;; If already at or to the left of the first non-whitespace character...
      (when (<= old-point (point))
        ;; Go to the beginning of the line.
        (beginning-of-line)))))
#+END_SRC

***** Define ~end-of-maybe-line~
~end-of-maybe-line~ incrementally moves ~point~ to the right within a line by semantic region.
The following semantic elements are considered in ~end-of-maybe-line~'s movement:
1. Source code
2. Comments
3. Trailing whitespace


The following is licensed CC BY-SA 3.0-licensed by StackOverflow user [[https://stackoverflow.com/users/387076/gilles][Gilles]].
It is based on [[http://stackoverflow.com/a/14245964][Gilles's StackOverflow answer]].

#+BEGIN_SRC emacs-lisp
(defun init-evil/end-of-maybe-line ()
  "Incrementally move point to the ends of syntactic blocks within the line.

The syntactic blocks are as follows, ordered from right to left:
1. Source code
2. Inline comment"
  (interactive "^")
  ;; Record point's current position.
  (let ((old-point (point)))
    ;; Go to the beginning of an inline comment (if any).
    (init-evil/back-to-comment)
    ;; If already at or after the start of the comment...
    (when (>= old-point (point))
      ;; ...then go to the beginning of trailing whitespace.
      (init-evil/back-totext))))
#+END_SRC

** Evil Collection

/Evil Collection/ offers a collection of Evil keybindings for modes that Evil does not support by default.

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  ;; Load this package eagerly.
  :demand

  ;; Load this package afer the following packages.
  :after evil

  ;; Apply the following variable customizations.
  :custom
  <<evil-collection/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<evil-collection/config>>)
#+END_SRC

*** Apply Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-collection/custom
:END:

Set up autocompletion to be similar to Vim's YouCompleteMe.
#+BEGIN_SRC emacs-lisp
(evil-collection-company-use-tng t)
#+END_SRC

Enable =TAB=-based bindings in Outline mode.
#+BEGIN_SRC emacs-lisp
(evil-collection-outline-bind-tab t)
#+END_SRC

*** Conditional Loading

Synchronize insert and normal states with char and line modes, respectively, in Term mode.
#+BEGIN_SRC emacs-lisp
(evil-collection-term-sync-state-and-mode-p t)
#+END_SRC

Set up Vim-style keybindings in the minibuffer.
#+BEGIN_SRC emacs-lisp
(evil-collection-setup-minibuffer t)
#+END_SRC

Set up debugger keys.
#+BEGIN_SRC emacs-lisp
(evil-collection-setup-debugger-keys t)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-collection/config
:END:

Enable Evil Collection globally.
#+BEGIN_SRC emacs-lisp
(evil-collection-init)
#+END_SRC

** Evil Matchit

[[https://github.com/redguardtoo/evil-matchit][Evil Matchit]] is a port of Tim Pope's [[http://www.vim.org/scripts/script.php?script_id%3D39][matchit.vim]] to Evil.
It enables jumping between matched tags, e.g. =<div>= and =</div>=.
#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  (:keymaps 'evil-matchit-mode-map
   :states 'motion
   "%" #'evilmi-jump-items)

  :config
  (global-evil-matchit-mode 1))
#+END_SRC

** Evil Surround

[[https://github.com/emacs-evil/evil-surround][Evil Surround]] is a port of [[https://github.com/tpope/vim-surround][vim-surround]] to Evil.
It adds a "surround" verb to Evil's modal editing.
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  ;; Load eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  (global-evil-surround-mode 1))
#+END_SRC

** Evil Indent Plus
=[[https://github.com/TheBB/evil-indent-plus]]= adds indentation levels as a text object for Evil.

- =i= is same or higher indentation.
- =I= is same or higher indentation, including the first line above with less indentation.
- =J= is same or higher indentation, including the first line above and below with less indentation.


#+BEGIN_SRC emacs-lisp
(use-package evil-indent-plus
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  (evil-indent-plus-default-bindings))
#+END_SRC

* Minibuffer
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref minibuffer
:END:

The minibuffer is a persistent buffer in Emacs that is used for interactive input and messages.

** Recursive Minibuffers

Allowing one to have more than one minibuffer active allows for more sophisticated workflows.
#+BEGIN_SRC emacs-lisp
(setq enable-recursive-minibuffers t)
#+END_SRC

Once having multiple active minibuffers is possible, it is helpful to keep track of the depth of recursion.
#+BEGIN_SRC emacs-lisp
(minibuffer-depth-indicate-mode +1)
#+END_SRC

** Flx

/Flx/ provides fuzzy searching algorithms.
Ivy's fuzzy finding will use Flx's scoring mechanism if /Flx/ is loaded.

#+BEGIN_SRC emacs-lisp
(use-package flx
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code before loading this package.
  :init
  <<flx/config>>)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref flx/config
:DESCRIPTION: Code to evaluated after ~flx~ has been loaded.
:END:

Run Emacs's garbage collector only when at least 20 MB have been allocated.
Doing so greatly improves ~flx~'s performance when working with large sets.

#+BEGIN_SRC emacs-lisp
(when (> 20000000 gc-cons-threshold)
  (setq gc-cons-threshold 20000000))
#+END_SRC

** Ivy
From the project's readme:
#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs.
While it operates similarly to other completion schemes such as =icomplete-mode=, Ivy aims to be more efficient, smaller, simpler, and smoother to use yet highly customizable.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package ivy
  ;; Load this package after the following packages.
  :after (flx)

  ;; Load this package eagerly.
  :demand

  ;; Inform the byte-compiler of the following interactive functions.
  :commands
  (ivy-mode)

  ;; Inform the byte-code compiler of the following non-interactive functions.
  :functions
  (ivy-format-function-line)

  ;; Add the following keybindings.
  :general
  <<ivy/general>>

  ;; Apply the following customizations.
  :custom
  <<ivy/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<ivy/config>>)
#+END_SRC

*** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy/general
:END:

Shadow ~switch-to-buffer~ with ~ivy-switch-buffer~.
#+BEGIN_SRC emacs-lisp
("C-x C-b" #'ivy-switch-buffer)
#+END_SRC

When in an Ivy buffer:
- =M-<return>= sends the current input verbatim.
- =C-u= restarts the minibuffer with a prefix argument.


#+BEGIN_SRC emacs-lisp
(:keymaps 'ivy-minibuffer-map
 "M-<return>" #'ivy-immediate-done
 "C-u" #'init-minibuffer/restart-with-prefix)
#+END_SRC

When in the minibuffer:
- =C-u= restarts the minibuffer with a prefix argument.


#+BEGIN_SRC emacs-lisp
(:keymaps 'minibuffer-inactive-mode-map
 "C-u" #'init-minibuffer/restart-with-prefix)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy/custom
:END:

Determine how matched parts of the options are highlighted.
#+BEGIN_SRC emacs-lisp
(ivy-display-style 'fancy "Highlight the matching parts of the regexp in the minibuffer.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-use-virtual-buffers t "Show recently killed buffers when calling `ivy-switch-buffer'.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-re-builders-alist '((t . ivy--regex-plus)) "Use `ivy--regex-plus' as the default matching function.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-extra-directories nil "Do not show './' or '../' in the filename completion list.")
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to evaluate after ~ivy~ has been loaded.
:HEADER-ARGS+: :noweb-ref ivy/config
:END:

Enable ~ivy-mode~ globally.
#+BEGIN_SRC emacs-lisp
(ivy-mode +1)
#+END_SRC

Do not include TRAMP buffers in Ivy's buffer lists.
#+BEGIN_SRC emacs-lisp
(setq ivy-ignore-buffers
      (cons (rx line-start "*tramp/"
                (one-or-more (not whitespace))
                whitespace
                (one-or-more anything)
                "*" line-end)
            ivy-ignore-buffers))
#+END_SRC

**** Restart the Minibuffer with a Prefix Argument
:PROPERTIES:
:AUTHOR: Clemens Radermacher (clemera) <clemera@posteo.net>
:COPYRIGHT: Copyright (C) 2019 Clemens Radermacher
:END:

Out of the box, Emacs does not provide a graceful way to add a prefix argument after the user has already started entering a command.
The following code posted by u/clemera on Reddit provides a workaround by restarting the minibuffer with same text.

First, a variable is defined to hold the minibuffer contents that were typed before entering a prefix.
#+BEGIN_SRC emacs-lisp
(defvar init-minibuffer/original-command nil
  "Command the minibuffer was started with.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun init-minibuffer/restart-with-prefix ()
  "Restart the minibuffer with a prefix argument."
  (interactive)
  (let ((input (ivy--input)))
    (cond ((memq #'ivy--queue-exhibit post-command-hook)
           (ivy-quit-and-run
             (let ((current-prefix-arg '(4))
                   (ivy-initial-inputs-alist `((,(ivy-state-caller ivy-last) . ,input))))
               (call-interactively (ivy-state-caller ivy-last))))
           (t
            (ivy-quit-and-run
              (let ((current-prefix-arg '(4)))
                (minibuffer-with-setup-hook
                    (lambda ()
                      (insert input)
                      (minibuffer-message "C-u"))
                  (call-interactively init-minibuffer/current-command)))))))))
#+END_SRC

** Counsel
#+BEGIN_SRC emacs-lisp
(use-package counsel

  ;; Load this package after the following packages.
  :after (ivy)

  ;; Load this package eagerly.
  :demand

  ;; Perform the following keybindings.
  :general
  ("C-h k" #'counsel-descbinds)
  ("C-x C-4 C-b" #'switch-to-buffer-other-window)
  ("C-x C-4 C-f" #'find-file-other-window)
  ("C-x C-4 b" #'switch-to-buffer-other-window)
  ("C-x C-f" #'counsel-find-file)
  ("C-x f" #'counsel-find-file)
  ("M-x" #'counsel-M-x)
  (:keymaps '(minibuffer-local-map minibuffer-inactive-mode-map)
   :states '(insert movement)
   "C-r" #'counsel-minibuffer-history)
  (:keymaps 'shell-mode-map
   "C-r" #'counsel-shell-history))
#+END_SRC

** Swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper
  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after ivy

  ;; Perform the following keybindings.
  :general
  ("C-s" #'swiper-isearch)
  (:keymaps '(normal movement visual)
   "/" #'swiper-isearch))
#+END_SRC

** Ivy Rich
#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  ;; Load this package after the following packages.
  :after ivy

  ;; Load this package eagerly.
  :demand

  ;; Apply the following customizations.
  :custom
  <<ivy-rich/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<ivy-rich/config>>)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy-rich/custom
:END:

#+BEGIN_SRC emacs-lisp
(ivy-virtual-abbreviate 'abbreviate "Abbreviate virtual buffer names.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-rich-path-style 'relative "Show paths relative their the project home.")
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to evaluate after loading ~ivy-rich~.
:HEADER-ARGS+: :noweb-ref ivy-rich/config
:END:

Enable ~ivy-rich-mode~ globally.
#+BEGIN_SRC emacs-lisp
(ivy-rich-mode 1)
#+END_SRC

Add support for ~counsel-projectile-switch-to-buffer~, mirroring that of ~ivy-switch-buffer~.
#+BEGIN_SRC emacs-lisp
(setq ivy-rich--display-transformers-list
      (plist-put
       ivy-rich--display-transformers-list
       'counsel-projectile-switch-to-buffer
       (plist-get ivy-rich--display-transformers-list 'ivy-switch-buffer)))
#+END_SRC

** Minibuffer Line
:PROPERTIES:
:DESCRIPTION: Display status info in the minibuffer
:END:

From /Minibuffer Line/'s readme:
#+BEGIN_QUOTE
This package lets you display various status information in the minibuffer window instead of the mode-line.
Of course, this is only displayed when the minibuffer window is not already used for other things (e.g. a minibuffer or an each area message).
The contents and aspect is controlled by the src_emacs-lisp{minibuffer-line-format} variable and the src_emacs-lisp{minibuffer-line} face.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package minibuffer-line
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code before loading this package.
  :init
  <<minibuffer-line/init>>

  ;; Inform the bytecode compiler of the following non-autoloading functions.
  :functions
  (format-time-string-8601 minibuffer-line-align)

  ;; Inform the bytecode compiler of the following autoloading functions.
  :commands
  minibuffer-line-mode

  ;; Apply the following variable customizations.
  :custom
  <<minibuffer-line/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  (minibuffer-line-mode))
#+END_SRC

*** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref minibuffer-line/init
:DESCRIPTION: Code to evaluate before loading src_emacs-lisp{minibuffer-line}
:END:

Define a function to print the date and time in ISO 8601 format.
#+BEGIN_SRC emacs-lisp
(defun format-time-string-minibuffer-line ()
  "Print the current date and time in ISO 8601-like format."
  (format-time-string "%Y-%m-%d %T"))
#+END_SRC

Define a function to left- and right-align elements using mode-line formatting.
#+BEGIN_SRC emacs-lisp
(defun minibuffer-line-align (left right)
  "Return a string containing LEFT and RIGHT aligned across the frame."
  (let* ((width-total (frame-text-cols))
         (width-space (- width-total
                         (+ (string-width (format-mode-line left))
                            (string-width (format-mode-line right))))))
    (append left
            (list (propertize
                   (format (format "%%%ds" width-space) "")
                   'face 'default))
            right)))
#+END_SRC

Define a the format to use for displaying battery information in the minibuffer.
#+BEGIN_SRC emacs-lisp
(defvar minibuffer-line-battery-format
  "battery %L %p%%"
  "Control string formatting the battery status to display in the minibuffer.")
#+END_SRC

*** Variable Customization
:PROPERTIES:
:DESCRIPTION: Variable customizations to apply when loading src_emacs-lisp{minibuffer-line}
:HEADER-ARGS+: :noweb-ref minibuffer-line/custom
:END:

Determine how frequently the string in src_emacs-lisp{minibuffer-line-format} is recalculated.
#+BEGIN_SRC emacs-lisp
(minibuffer-line-refresh-interval 1 "Refresh the minibuffer-line every second.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(minibuffer-line-format
 '((:eval
    (minibuffer-line-align
     '()
     '((:eval (propertize
               (battery-format
                minibuffer-line-battery-format
                (funcall battery-status-function))
               'face 'default))
       (:eval (propertize " | " 'face 'default))
       (:eval (propertize system-name 'face 'default))
       (:eval (propertize " | " 'face 'default))
       (:eval (propertize (format-time-string-minibuffer-line) 'face 'default)))))))
#+END_SRC

** McFly
:PROPERTIES:
:COPYRIGHT_YEAR: 2019
:COPYRIGHT_AUTHOR: Vincent Zhang (seagle0128)
:COPYRIGHT_EMAIL: seagle0128@gmail.com
:LICENSE: GPLv3+
:END:

#+BEGIN_SRC emacs-lisp
(defvar my-ivy-fly-commands '(query-replace-regexp
                              flush-lines
                              keep-lines
                              ivy-read
                              swiper
                              swiper-backward
                              swiper-all
                              swiper-isearch
                              swiper-isearch-backward
                              counsel-grep-or-swiper
                              counsel-grep-or-swiper-backward
                              counsel-grep
                              counsel-ack
                              counsel-ag
                              counsel-rg
                              counsel-pt))

(defun my-ivy-fly-back-to-present ()
  ;; (remove-hook 'pre-command-hook 'my-ivy-fly-back-to-present t)
  (cond ((and (memq last-command my-ivy-fly-commands)
              (equal (this-command-keys-vector) (kbd "M-p")))
         ;; repeat one time to get straight to the first history item
         (setq unread-command-events
               (append unread-command-events
                       (listify-key-sequence (kbd "M-p")))))
        ((or (memq this-command '(self-insert-command
                                  yank
                                  ivy-yank-word
                                  counsel-yank-pop))
             (equal (this-command-keys-vector) (kbd "M-n")))
         (delete-region (point)
                        (point-max)))))

(defun my-ivy-fly-time-travel ()
  (when (memq this-command my-ivy-fly-commands)
    (let* ((kbd (kbd "M-n"))
           (cmd (key-binding kbd))
           (future (and cmd
                        (with-temp-buffer
                          (when (ignore-errors
                                  (call-interactively cmd) t)
                            (buffer-string))))))
      (when future
        (save-excursion
          (insert (propertize (replace-regexp-in-string
                               "\\\\_<" ""
                               (replace-regexp-in-string
                                "\\\\_>" ""
                                future))
                              'face 'shadow)))
        (add-hook 'pre-command-hook 'my-ivy-fly-back-to-present nil t)))))

(add-hook 'minibuffer-setup-hook #'my-ivy-fly-time-travel)
#+END_SRC

* TRAMP
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref tramp
:END:

TRAMP allows Emacs to transparently access remote files as if they were local files.
#+BEGIN_SRC emacs-lisp
(use-package tramp
  ;; Load this package eagerly.
  :demand

  ;; Apply the following variable customizations.
  :custom
  <<tramp/custom>>)
#+END_SRC

** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref tramp/custom
:END:

Determine where Emacs creates backups for files edited via TRAMP.
#+BEGIN_SRC emacs-lisp
(tramp-backup-directory-alist backup-directory-alist "Create TRAMP backups locally.")
#+END_SRC
* Version Control
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref version-control
:END:

** Autorevert

#+BEGIN_SRC emacs-lisp
(use-package autorevert
  ;; Customize the following variables.
  :custom
  (auto-revert-verbose nil "Do not display messages when buffers are reverted."))
#+END_SRC

** Diff HL

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  ;; Only load this package if the following condition is met.
  :if
  <<diff-hl/if>>

  ;; Load this package eagerly.
  :demand

  ;; Add the following auto-loading hooks.
  :ghook
  <<diff-hl/ghook>>

  ;; Inform the bytecode compiler about the following functions.
  :commands
  (global-diff-hl-mode)

  ;; Evaluate the following code before loading this package.
  :init
  <<diff-hl/init>>

  ;; Evaluate the following code after loading this package.
  :config
  <<diff-hl/config>>)
#+END_SRC

*** Conditional Loading
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/if
:END:

Diff HL depends on features added in Emacs 24.3.
#+BEGIN_SRC emacs-lisp
(version<= "24.3" emacs-version)
#+END_SRC

*** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/ghook
:END:

Enable Diff HL in Dired buffers.
#+BEGIN_SRC emacs-lisp
('dired-mode-hook #'diff-hl-dired-mode)
#+END_SRC

Update Diff HL's status when refreshing with modern versions of Magit.
#+BEGIN_SRC emacs-lisp
('magit-post-refresh-hook #'diff-hl-magit-post-refresh)
#+END_SRC

*** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/init
:END:

Enable Diff HL's base minor mode globally.
#+BEGIN_SRC emacs-lisp
(global-diff-hl-mode)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff-hl/config
:END:

Perform Diff HL highlighting on-the-fly.
#+BEGIN_SRC emacs-lisp
(diff-hl-flydiff-mode)
#+END_SRC

** Git
*** Git Attributes Mode

#+BEGIN_SRC
(use-package gitattributes-mode)
#+END_SRC

*** Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  ;; Load this package if the following code evaluates to non-nil.
  :if
  <<magit/if>>

  ;; Inform the bytecode compiler of the following autoloaded functions.
  :commands magit-clone-to-xdg-source

  ;; Perform the following customizations.
  :custom
  <<magit/custom>>

  ;; Add the following keybindings.
  :general
  <<magit/general>>

  ;; Evaluate the following code after loading `magit'.
  :config
  <<magit/config>>)
#+END_SRC

**** Conditional Loading
:PROPERTIES:
:DESCRIPTION: Only load ~magit~ if this code evaluates to non-~nil~.
:HEADER-ARGS+: :noweb-ref magit/if
:END:

/Magit/ provides an interface for Git.
As such, the package is unusable is worthless if =git= is not in the user's ~PATH~.
#+BEGIN_SRC emacs-lisp
(executable-find "git")
#+END_SRC

**** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref magit/general
:END:

#+BEGIN_SRC emacs-lisp
("C-x g" #'magit-status)
#+END_SRC

**** Customize Variables
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref magit/custom
:END:

Set the list of messages Magit should not display.
#+BEGIN_SRC emacs-lisp
(magit-no-message '("Turning on magit-auto-revert-mode...") "Suppress messages")
#+END_SRC

Hide the stash and ignored file sections by default in status buffers.
#+BEGIN_SRC emacs-lisp
(magit-section-initial-visibility-alist
 '((ignored . hide)
   (stashes . hide)
   (untracked . hide)))
#+END_SRC

Set the sections to be displayed in status buffers.
#+BEGIN_SRC emacs-lisp
(magit-status-sections-hook
 '(magit-insert-status-headers
   magit-insert-merge-log
   magit-insert-rebase-sequence
   magit-insert-am-sequence
   magit-insert-sequencer-sequence
   magit-insert-bisect-output
   magit-insert-bisect-rest
   magit-insert-bisect-log
   magit-insert-ignored-files
   magit-insert-untracked-files
   magit-insert-unstaged-changes
   magit-insert-staged-changes
   magit-insert-stashes
   magit-insert-unpushed-to-pushremote
   magit-insert-unpushed-to-upstream-or-recent
   magit-insert-unpulled-from-pushremote
   magit-insert-unpulled-from-upstream))
#+END_SRC

**** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref magit/init
:DESCRIPTION: Code to evaluate before loading Magit.
:END:

Store the usernames used by the current user.
#+BEGIN_SRC emacs-lisp
(defconst magit-push-usernames '("lafrenierejm")
  "The Git forge usernames whose repos this Emacs user has push access to.")
#+END_SRC

Store the domains where this user has global Git push access.
#+BEGIN_SRC emacs-lisp
(defconst magit-push-domains '()
  "The domains where this Emacs user has global Git push access.")
#+END_SRC

**** Post-Load Execution
:PROPERTIES:
:DESCRIPTION: The code in this section shall be evaluated after ~magit~ has been loaded.
:HEADER-ARGS+: :noweb-ref magit/config
:END:

***** Return After Commit Message

Return to the main Magit window after closing a commit message, regardless of whether that message is committed or aborted.
#+BEGIN_SRC emacs-lisp
(advice-add 'git-commit-commit :after #'delete-window)
(advice-add 'git-commit-abort :after #'delete-window)
#+END_SRC

***** Automatically Register Repositories with Projectile

Define a function to perform the registration.
#+BEGIN_SRC emacs-lisp
(defun init-version-control/magit-add-known-project (&rest _)
  "Register the current repository's root with Projectile."
  (interactive)
  (when (and (fboundp #'projectile-add-known-project)
             magit--default-directory)
    (projectile-add-known-project magit--default-directory)))
#+END_SRC

Add the above function to be run after ~magit-status~.
#+BEGIN_SRC emacs-lisp
(advice-add
 'magit-status-internal
 :after
 #'init-version-control/magit-add-known-project)
#+END_SRC

***** Comparable Version Number

The function ~magit-version~ provided by Magit does not return a version string that is comparable using Emacs's built-in ~version<~.
However, Magit's semver is /par/ of the string returned by ~magit-version~;
it is everything before the first hyphen.

#+BEGIN_SRC emacs-lisp
(defun init-magit/version ()
  "Return Magit's version for use in comparisons."
  (car (split-string (magit-version) "-")))
#+END_SRC

*** Forge
From the project's README:
#+BEGIN_QUOTE
Work with Git forges, such as Github and Gitlab, from the comfort of Magit and the rest of Emacs.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package forge
  ;; Load this package after the following packages.
  :after magit

  ;; Load this package eagerly.
  :demand)
#+END_SRC

*** Evil Magit
~[[https://github.com/emacs-evil/evil-magit][evil-magit]]~ configures [[Evil]] and [[Magit]] to play well together.

#+BEGIN_SRC emacs-lisp
(use-package evil-magit
  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after (:all evil magit)

  :general
  (:keymaps 'magit-mode-map
   :states 'normal
   "C-z" nil
   [escape] nil)

  :ghook
  <<evil-magit/ghook>>

  :custom
  <<evil-magit/custom>>)
#+END_SRC

**** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-magit/ghook
:END:

#+BEGIN_SRC emacs-lisp
('magit-mode-hook #'evil-local-mode)
#+END_SRC

**** Customize Variables
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-magit/custom
:END:

Determine which Evil state Evil Magit starts in.
#+BEGIN_SRC emacs-lisp
(evil-magit-state 'motion "Start `evil-magit' in the motion state.")
#+END_SRC

Determine whether Evil Magit uses Evil's movement keys.
#+BEGIN_SRC emacs-lisp
(evil-magit-want-horizontal-movement t "Enable Evil's horizontal movement in Magit buffers.")
#+END_SRC

*** SSH Agency

#+BEGIN_SRC emacs-lisp
(use-package ssh-agency
  :after magit

  :demand

  :custom
  (ssh-agency-add-executable (executable-find "ssh-add"))
  (ssh-agency-agent-executable (executable-find "ssh-agent"))
  (ssh-agency-agent-exe-names '("ssh-agent")))
#+END_SRC

*** Determine Year Added

Define a function to determine when a file was first created.
This is useful when adding determining information.
#+BEGIN_SRC emacs-lisp
(defun git-lafrenierejm-year-added (filename)
  (interactive "f")
  "Determine the year when FILENAME was added to a Git repository.

If the file has not been added to the repository, use the current year."
  (if-let (((not (string-empty-p filename)))
           (git-output
            (shell-command-to-string
             (format "%s | tail -1 | head -c 4 -z"
                     (s-join " " `("git" "log"
                                   "--diff-filter=A"
                                   "--follow"
                                   "--format=%aI"
                                   "--"
                                   ,filename
                                   ,(format "2>%s" null-device))))))
           ((not (string-empty-p git-output))))
      git-output
    (format-time-string "%Y")))
#+END_SRC

Alias the above function to remove my username.
#+BEGIN_SRC
(defalias 'git-year-added #'git-lafrenierejm-year-added)
#+END_SRC
* Completion
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref completion
:END:

** Company

#+BEGIN_SRC emacs-lisp
(use-package company
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading.
  :config
  <<company/config>>)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to be evaluated after Company has been loaded.
:HEADER-ARGS+: :noweb-ref company/config
:END:

Enable ~company-mode~ globally.
#+BEGIN_SRC emacs-lisp
(global-company-mode)
#+END_SRC

** YASnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  ;; Load this package eagerly.
  :demand

  ;; Apply the following variable customizations.
  :custom
  ;; Enable `yas-minor-mode' globally.
  (yas-snippet-dirs
   (let ((dir (expand-file-name
               "~/.guix-profile/share/emacs/yasnippet-snippets/"))
         (append t))
     (if (file-directory-p dir)
         (add-to-list 'yas-snippet-dirs dir append)
       yas-snippet-dirs)))

  ;; Evaluate the following code after loading this package.
  :config
  (yas-global-mode 1))
#+END_SRC

** Ivy YASnippet

#+BEGIN_SRC emacs-lisp
(use-package ivy-yasnippet
  ;; Load this package after the following packages.
  :after (ivy yasnippet)

  ;; Load this package eagerly.
  :demand)
#+END_SRC
* Diff
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref diff
:END:

** Ediff

#+BEGIN_SRC emacs-lisp
(use-package ediff
  ;; Evaluate the following code after loading this package.
  :custom
  <<ediff/custom>>)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ediff/custom
:END:

Determine how Ediff windows are setup.
#+BEGIN_SRC emacs-lisp
(ediff-window-setup-function
 #'ediff-setup-windows-plain
 "Use a single frame for all buffers including the control panel.")
#+END_SRC
* Command Interpretation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref command-interpretation
:END:

** Comint

#+BEGIN_SRC emacs-lisp
(use-package comint
  :demand

  :commands
  (init-comint/clear-buffer)

  :general
  <<comint/general>>

  :config
  <<comint/config>>)
#+END_SRC

*** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref comint/general
:END:

Use =C-l= to clear the current buffer.
#+BEGIN_SRC emacs-lisp
(:keymaps 'comint-mode-map
 "C-l" #'init-comint/clear-buffer)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref comint/config
:END:

**** Clear Buffers

The following code is taken verbatim from [[https://emacsredux.com/blog/2015/01/18/clear-comint-buffers/]["Clear Comint Buffers"]] on /Emacs Redux/.
The only addition is the doc string.
#+BEGIN_SRC emacs-lisp
(defun init-comint/clear-buffer ()
  "Clear all scrollback for the current buffer."
  (interactive)
  (let ((comint-buffer-maximum-size 0))
    (comint-truncate-buffer)))
#+END_SRC

** Emacs Shell
*** Esh Mode
#+BEGIN_SRC emacs-lisp
(use-package esh-mode
  ;; Load this package eagerly.
  :demand

  :preface
  <<esh-mode/preface>>

  :config
  <<esh-mode/config>>)
#+END_SRC

**** Pre-Evaluation Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref esh-mode/preface
:END:

Define the format of the timestamp to prefix prompts with.
By default, this follows ISO 8601.
#+NAME: init-eshell/prompt-timestamp-format-string
#+BEGIN_SRC emacs-lisp
(defcustom init-eshell/prompt-timestamp-format-string
  "%FT%T%z"
  "The format-string used for Eshell prompts' timestamps.

See `help format-time-string' for the definition of the constructs.
The default value follows ISO 8601."
  :type '(string))
#+END_SRC

Define the regexp to match the result of the above format string.
#+NAME: init-eshell/prompt-timestamp-regexp
#+BEGIN_SRC emacs-lisp
(defcustom init-eshell/prompt-timestamp-regexp
  (rx
   (repeat 4 digit) ?- (repeat 2 digit) ?- (repeat 2 digit)
   ?T (repeat 2 digit) (repeat 2 (and ?: (repeat 2 digit)))
   (or ?- ?+) (repeat 4 digit))
  "A regular expression that matches `init-eshell/prompt-timestamp-format-string'."
  :type '(regexp))
#+END_SRC

**** Post-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref esh-mode/config
:END:

***** Define Eshell-Specific ~beginning-of-maybe-line~
[[../minor-mode/init-evil.org][init-evil.org]] defines ~init/beginning-of-maybe-line~.
That function acts as a do-what-I-mean alternative to the built-in =beginning-of-line= by incrementally jumping to the beginning of text sections within a line.

=init-eshell/beginning-of-maybe-line= moves =point= toward the beginning of the current line incrementally by semantic region.
1. If point is in the text of a command, point will be moved to the beginning of the command.
2. If the current line has leading whitespace and point is somewhere after that whitespace, point will be moved to the first non-whitespace character.
3. Point will be moved to the beginning of the line.

#+BEGIN_SRC emacs-lisp
(defun init-eshell/beginning-of-maybe-line ()
  "Move point to the start of the command beginning of the line."
  (interactive)
  (let ((old-point (point)))   ; Get current position.
    (eshell-bol)               ; Move to beginning of current command.
    (when (or (<= old-point (point))
              (= (point-at-bol) (point)))
      (back-to-indentation) ; Go to the first significant column
      ;; If already at or before the first significant column...
      (when (<= old-point (point))
        ;; Then go to the beginning of the line.
        (beginning-of-line)))))
#+END_SRC

***** Accurate Prompt Timestamp
:PROPERTIES:
:DESCRIPTION: Before sending input, update the current prompt with a timestamp.
:END:

A common practice among users of command line interface (CLI) shells is to include timestamps in their shells' prompts.

In Bash, for example, timestamping one's prompt is frequently accomplished by using the ~date~ command as part of the prompt variable.
For example, the prompt src_sh[:exports code]{PS1="(\$date +%H:%M:%S) $"} would result in a prompt such as =21:43:41 $=.

I find the information by such a prompt to be misleading, however.

****** The Problem
My motivation for timestamping my prompts was to be able to easily answer the question, "When did I run this command?"
But rather than providing context for when the corresponding command was submitted, most =PS1=-inserted timestamps actually indicate when the /previous/ command finished executing.

Answering the question about when an arbitrary command \(c_n\) was submitted, then, involves
1. ignoring the timestamp \(t_n\) that is next to \(c_n\);
2. scrolling down to where the next command \(c_{n+1}\) was entered;
3. removing the timestamp \(t_{n+1}\) that is next to \(c_{n+1}\) from the context conferred upon it by its proximity to \(c_{n+1}\); and
4. mentally linking \(t_{n+1}\) back to \(c_n\).

Clearly, the task is not so complicated as to be impossible.
It is far less efficient and more error-prone than it could be, though.
That inefficiency results from requiring the user to
- consciously splitting then re-pairing timestamps and
- visually --- and, if scrolling is required, phsyically --- navigate between two prompts.


****** The Solution
The primary difficulty in establishing accurate timestamps is that doing so requires modifying the prompt text /after/ its input has been sent.
Some shells have workaround for this, such as Zsh's ~preexec~.
Rather than implementing such a function for Eshell, we can instead take advantage of the fact that Eshell is written in Emacs Lisp and outputs directly to an Emacs buffer.

Define a function to update the most recent prompt's timestamp.
#+BEGIN_SRC emacs-lisp
(defun init-eshell/timestamp-prompt ()
  "Update the timestamp at the beginning of the current prompt."
  (interactive)
  (let ((cur-pos (point)))
    ;; Move to the end of the buffer.
    (goto-char (point-max))
    ;; Move POINT to the end of the previous prompt, then to end of the next prompt.
    ;; This handles cases of multi-line input and ensures POINT is at the most recent prompt.
    (eshell-previous-prompt 1)
    (eshell-next-prompt 1)
    ;; Move POINT to the beginning of the line.
    (forward-line 0)
    (let ((inhibit-read-only t)
          (prompt-properties
           (list 'font-lock-face 'eshell-prompt
                 'font-sticky '(font-lock-face 'read-only)
                 'read-only t
                 'rear-nonsticky '(font-lock-face read-only))))
      ;; Remove the existing timestamp.
      (when (re-search-forward init-eshell/prompt-timestamp-regexp)
        (replace-match ""))
      ;; Insert the timestamp, propertized to match the rest of the prompt.
      (insert (apply #'propertize
                     (format-time-string init-eshell/prompt-timestamp-format-string)
                     prompt-properties)))
    ;; Restore POINT to its original location.
    (goto-char cur-pos)))
#+END_SRC
Where ~init-eshell/prompt-timestamp-format-string~ and ~init-eshell/prompt-timestamp-regexp~ are defined in ref:init-eshell/prompt-timestamp-format-string and ref:init-eshell/prompt-timestamp-regexp, respectively.

Call the above function before sending input.
#+BEGIN_SRC emacs-lisp
(advice-add 'eshell-send-input :before #'init-eshell/timestamp-prompt)
#+END_SRC

***** Narrow to Command

Narrow the buffer to the context ~point~ is currently in:
- command output :: narrow to the preceding command and the current output
- last prompt/command :: do nothing
- other prompt/command :: narrow to the prompt, command, and the command's output

#+BEGIN_SRC emacs-lisp
(defun init-eshell/narrow-to-command ()
  "Make text outside the current command invisible.

- If `point' is in the last prompt or last command, do nothing.
- If `point' is in command output, narrow to the output and the corresponding
  prompt and command.
- if `point' is in a prompt or command that's not the last, narrow to that
  prompt, command, and the corresponding output."
  (interactive)
  (let ((orig (point))
        (line-orig (line-number-at-pos (point)))
        (line-later-prompt (progn (eshell-next-prompt 2)
                                  (line-number-at-pos (point)))))
    ;; Restore original position.
    (goto-char orig)
    ;; If not in the last command...
    (if (not (= line-orig line-later-prompt))
        (let* ((command-beg (progn (eshell-bol) (point)))
               (line-beg (progn (beginning-of-line) (point)))
               (start (cond
                       ;; If not in a command...
                       ((= command-beg line-beg)
                        (eshell-previous-prompt 1)
                        (beginning-of-line)
                        (point))
                       ;; Else in a command...
                       (t
                        line-beg)))
               (end (progn
                      (eshell-next-prompt 2) ; next prompt
                      (previous-line 1) ; up one line
                      (end-of-line) ; end of line
                      (point))))
          (narrow-to-region start end)))))
#+END_SRC

*** Em Hist
#+BEGIN_SRC emacs-lisp
(use-package em-hist
  ;; Load eagerly.
  :demand

  ;; Customize the following variables.
  :custom
  <<em-hist/custom>>)
#+END_SRC

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-hist/custom
:END:

Determine whether duplicates are skipped when traversing command history.
#+BEGIN_SRC emacs-lisp
(eshell-hist-ignoredups t "Skip duplicates when traversing command history.")
#+END_SRC

*** Em Dirs
#+BEGIN_SRC emacs-lisp
(use-package em-dirs
  :config
  <<em-dirs/config>>)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-dirs/config
:END:

***** Return Path Relative to Project Root
#+BEGIN_SRC emacs-lisp
(defun init-eshell/pwd-relative-to-project (directory)
  "Print DIRECTORY relative to its Projectile root, if any.

If DIRECTORY is in a project as determined by Projectile, return DIRECTORY's
path starting starting at the project's root.

If DIRECTORY is _not_ in a project, return the abbreviated form of DIRECTORY's
path."
  (s-chop-suffix
   "/"
   (if-let (((fboundp #'projectile-project-name))
            ((fboundp #'projectile-project-root))
            (project-root (projectile-project-root directory))
            (project-name (projectile-project-name project-root)))
       ;; If in a project:
       (if (string=
            (file-name-as-directory (expand-file-name directory))
            project-root)
           ;; If at a project's root: use the project's name
           project-name
         ;; Else not at project's root: use path starting with project's root
         (concat (file-name-as-directory project-name)
                 (file-relative-name
                  (expand-file-name directory)
                  project-root)))
     ;; Else not in project: use abbreviated path
     (abbreviate-file-name directory))))
#+END_SRC

***** Abbreviate Path Elements
Printing the path to the current directory in the shell prompt helps me keep track of the context.
However, if the path is long this can result in unwieldy prompts.
The following functions can be used to abbreviate a path by shortening each element in the path to that element's first non-period character;
only the last directory in the path is shown in full.

#+BEGIN_SRC emacs-lisp
(defun init-eshell/abbreviate-dirname (filename)
  (cond
   ((string-empty-p filename)
    "")
   ((string= (substring filename 0 1) ".")
    (substring filename 0 2))
   (t
    (substring filename 0 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun init-eshell/abbreviate-path (path)
  "Abbreviate each element in PATH except for the last.

Abbreviated path elements are represented by their first non-period
character. For example, the path \"/home/user/.config/curdir\" will become
\"/h/u/.c/curdir\"."
  (let* ((split-path (split-string path "/")))
    (if (< (length split-path) 2)
        (or (car split-path) "")
      (concat
       (file-name-as-directory
        (cl-reduce
         (lambda (directory filename)
           (concat (if (string-empty-p directory)
                       "/"
                     (file-name-as-directory directory))
                   filename))
         (mapcar
          #'init-eshell/abbreviate-dirname
          split-path)
         :end (- (length split-path) 1)))
       (car (last split-path)))
      path)))
#+END_SRC

***** Create Eshell Buffer Names
#+BEGIN_SRC emacs-lisp
(defun init-eshell/name-buffer (directory &optional process-name)
  "Create a name for an Eshell buffer in DIRECTORY."
  (concat "*eshell "
          (init-eshell/pwd-relative-to-project directory)
          (when process-name
            (concat " <" process-name ">"))
          "*"))
#+END_SRC

***** Prefer Changing Buffers to Changing Directories
Redefine ~eshell/cd~ to prefer switching to an Eshell buffer in the new directory (if such a buffer exists) over changing the directory of the buffer where ~eshell/cd~ was called.
Whether or not an Eshell buffer exists at the specified location is determined by the name of existing Eshell buffers.

The following code is derived directly from code in GNU Emacs's Em Dirs and Files packages.
As such, it is licensed under GPLv3.

#+BEGIN_SRC emacs-lisp
(defun eshell/cd (&rest args)
  "Alias to extend the behavior of `cd'.

If an Eshell buffer already exists at the target directory, switch to that
buffer.  Otherwise, change the working directory of the current buffer to the
target directory then rename the current buffer to reflect its new working
directory.

The presence of an existing Eshell buffer at the new location is determined by
comparing the name of buffers to the result of `init-eshell/name-buffer'."
  (setq args (eshell-flatten-list args))
  (let ((path (car args))
        (subpath (car (cdr args)))
        (case-fold-search (eshell-under-windows-p))
        handled)
    (if (numberp path)
        (setq path (number-to-string path)))
    (if (numberp subpath)
        (setq subpath (number-to-string subpath)))
    (cond
     (subpath
      (let ((curdir (eshell/pwd)))
        (if (string-match path curdir)
            (setq path (replace-match subpath nil nil curdir))
          (error "Path substring `%s' not found" path))))
     ((and path (string-match "^-\\([0-9]*\\)$" path))
      (let ((index (match-string 1 path)))
        (setq path
              (ring-remove eshell-last-dir-ring
                           (if index
                               (string-to-number index)
                             0)))))
     ((and path (string-match "^=\\(.*\\)$" path))
      (let ((oldpath (eshell-find-previous-directory
                      (match-string 1 path))))
        (if oldpath
            (setq path oldpath)
          (let ((len (ring-length eshell-last-dir-ring))
                (index 0))
            (if (= len 0)
                (error "Directory ring empty"))
            (eshell-init-print-buffer)
            (while (< index len)
              (eshell-buffered-print
               (concat (number-to-string index) ": "
                       (ring-ref eshell-last-dir-ring index) "\n"))
              (setq index (1+ index)))
            (eshell-flush)
            (setq handled t)))))
     (path
      (setq path (eshell-expand-multiple-dots path))))
    (unless handled
      (let* ((cd-path (or (parse-colon-path (getenv "CDPATH"))
                          (list "./")))
             (curdir (eshell/pwd))
             (newdir (expand-file-name (file-name-as-directory (or path "~"))))
             (newname (init-eshell/name-buffer newdir)))
        (unless (equal curdir newdir)
          (eshell-add-to-dir-ring curdir))
        ;; If an Eshell buffer already exists in the new directory...
        (if-let ((newbuf (get-buffer newname)))
            ;; Then switch to the existing Eshell buffer.
            (switch-to-buffer newbuf)
          ;; Else change to the new directory.
          (let ((result (cd newdir)))
            ;; Change the buffer's name.
            (rename-buffer newname)
            ;; If `eshell-cd-shows-directory' is non-nil...
            (when eshell-cd-shows-directory
              ;; Then print the new directory.
              (eshell-printn result))))
        (run-hooks 'eshell-directory-change-hook)
        (if eshell-list-files-after-cd
            ;; Let-bind eshell-last-command around this?
            (eshell-plain-command "ls" (cdr args)))
        nil))))
    #+END_SRC

*** Eshell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after (:all evil ivy)

  ;; Inform the bytecode compiler of the following functions.
  :commands
  (init-eshell/add-visual-commands
   init-eshell/beginning-of-maybe-line
   init-eshell/find-eshell
   init-eshell/find-eshell-here
   init-eshell/prompt)

  ;; Add the following keybindings.
  :general
  <<eshell/general>>

  ;; Add the following non-autoloading hooks.
  :gfhook
  <<eshell/gfhook>>

  ;; Customize the following variables.
  :custom
  <<eshell/custom>>

  ;; Execute the following code before loading this package.
  :init
  <<eshell/init>>

  ;; Execute the following code after loading this package.
  :config
  <<eshell/config>>)
#+END_SRC

**** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/general
:END:

Map the opening an Eshell buffer to =C-x z=.
This keybinding mirrors the defaults for ~find-file~ and ~dired~.

#+BEGIN_SRC emacs-lisp
("C-x z" #'init-eshell/find-eshell)
#+END_SRC

Map ~init-eshell/find-eshell-here~ to =C-z=.
This imitates the behavior of *NIX terminal applications.
In most terminal applications, =C-z= is the key combination to suspend the current process which usually results in the user being returned to their shell.

#+BEGIN_SRC emacs-lisp
("C-z" #'init-eshell/find-eshell-here)
#+END_SRC

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/gfhook
:END:

Build the list of commands to be run in Term mode buffers.

#+BEGIN_SRC emacs-lisp
(nil #'init-eshell/add-visual-commands)
#+END_SRC

Add the following keybindings:
- =C-l= :: clear the buffer's scrollback
- =C-x n c= :: narrow to the current command
- =C-z= :: "background" the current process

#+BEGIN_SRC emacs-lisp
(nil (lambda ()
       (general-define-key
        :keymaps 'eshell-mode-map
        "C-l" #'init-eshell/clear-scrollback
        "C-x n c" #'init-eshell/narrow-to-command
        "C-z" #'init-eshell/background-process-maybe
        :states '(insert)
        "C-r" #'counsel-esh-history)))
#+END_SRC

**** Customize Variables
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/custom
:END:

#+BEGIN_SRC emacs-lisp
(eshell-prefer-lisp-functions nil "Prefer external commands to Lisp functions.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(eshell-prefer-lisp-variables nil "Prefer environment variables to Lisp variables.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(eshell-prompt-function #'init-eshell/prompt)
#+END_SRC

**** Pre-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/init
:END:

***** Eshell Prompt
#+BEGIN_SRC emacs-lisp
(defun init-eshell/prompt ()
  "Prefix \"$USER@$(hostname):\" if on remote host."
  (concat
   (format-time-string
    (concat init-eshell/prompt-timestamp-format-string " "))
   (if (file-remote-p default-directory 'host)
       (with-parsed-tramp-file-name default-directory nil
         (concat
          (when user
            (concat user "@"))
          host ":"
          localname))
     (init-eshell/abbreviate-path
      (init-eshell/pwd-relative-to-project
       (expand-file-name default-directory))))
   (if (= (user-uid) 0)
       " # "
     " $ ")))
#+END_SRC

***** Set =$PAGER=
Because Eshell runs entirely within an Emacs buffer, Eshell does not need an external pager.
Instead, text can be dumped directly into the buffer.
This is accomplished by setting ~PAGER~ to ~cat~.

#+BEGIN_SRC emacs-lisp
(setenv "PAGER" "cat")
#+END_SRC

***** Use Magit for Some Git Commands
The code in this section is copyright Gergely Nagy [[mailto:algernon@bonehunter.rulez.org][<algernon@bonehunter.rulez.org>]] and shared under GPLv3.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'magit
  (defun eshell/git (command &rest args)
    (pcase command
      ;; Use magit's log.
      ("log" (apply #'algernon/git-log args))
      ;; Use magit's status.
      ("status" (progn
                  (magit-status)
                  (eshell/echo)))
      ;; Run all other commands directly in `git'.
      (_ (let ((command (s-join " " (append (list "git" command) args))))
           (message command)
           (shell-command-to-string command))))))
#+END_SRC

Run ~magit-log~ after determining if the argument to ~git log~ was a file or branch.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'magit
  (defun algernon/git-log (&rest args)
    (let* ((branch-or-file (car args))
           (file-list (if (and branch-or-file (f-file-p branch-or-file))
                          args
                        (cdr args)))
           (branch (if (and branch-or-file (f-file-p branch-or-file))
                       "HEAD"
                     branch-or-file)))
      (message branch-or-file)
      (if branch-or-file
          (magit-log (list branch)
                     '()
                     (mapcar
                      (lambda (f) (concat (file-name-as-directory (eshell/pwd)) f))
                      file-list))
        (magit-log-head)))
    (eshell/echo)))
#+END_SRC

**** Post-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref eshell/config
:END:

***** "Visual" Commands
Run the following commands in a =term= buffer:
#+NAME: visual-commands
- alsamixer
- ssh
- top
- tail

#+BEGIN_SRC emacs-lisp
(defun init-eshell/add-visual-commands ()
  "Add commands to `eshell-visual-commands'."
  (let ((commands (list "alsamixer" "ssh" "top" "tail")))
    (dolist (command commands)
      (add-to-list 'eshell-visual-commands command))))
#+END_SRC

***** Custom Functions
****** Open Eshell in a Given Directory
Open or switch to an Eshell buffer in a given directory.

#+BEGIN_SRC emacs-lisp
(defun init-eshell/find-eshell (directory)
  "Open Eshell in DIRECTORY.

If an Eshell instance for the directory already exists, switch to it.  If no
such instance exists, start a new instance whose name includes the directory."
  (interactive "DOpen Eshell in: ")
  ;; Set the directory to open Eshell in.
  (let* ((eshell-buffer-name (init-eshell/name-buffer directory))
         (buffer (get-buffer-create eshell-buffer-name)))
    (pop-to-buffer-same-window buffer)
    (unless (derived-mode-p 'eshell-mode)
      (eshell-mode))
    buffer))
#+END_SRC

****** Open Eshell in the Current Directory

Define a function to open an Eshell instance in the current directory.
If an Eshell instance already exists in that directory, switch to its buffer.

#+BEGIN_SRC emacs-lisp
(defun init-eshell/find-eshell-here ()
  "Open Eshell in the current working directory.

If an Eshell instance for the directory already exists, switch to it. If no such
instance exists, start a new instance whose name includes the directory."
  (interactive)
  (let ((cwd (abbreviate-file-name (if (buffer-file-name)
                                       (file-name-directory (buffer-file-name))
                                     default-directory))))
    (init-eshell/find-eshell cwd)))
     #+END_SRC

****** "Background" the Current Process

If a long-running process is started from an Eshell prompt without explicitly backgrounding the process, that process will block any further input to the prompt.
Because having access to long-running processes' stdout and stderr is useful, there is a need for an interactive function that can
1. preserve the buffer belonging to that long-running process;
2. rename the buffer belonging to the process; and
3. open a new Eshell buffer in the same directory.


#+BEGIN_SRC emacs-lisp
(defun init-eshell/background-process-maybe ()
  "Rename the Eshell BUFFER with its process and reopen the directory."
  (interactive)
  (when-let ((path default-directory)
             (process (get-buffer-process (current-buffer)))
             (process-name (process-name process)))
    (rename-buffer (init-eshell/name-buffer path process-name))
    (init-eshell/find-eshell path)))
#+END_SRC

UNIX shells use the chord =C-z= to background the current process.

#+BEGIN_SRC emacs-lisp
(defun init-eshell/bind-background-process-maybe ()
  "Add a keybinding for `init-eshell/background-process-maybe'."
  (general-define-key
   :keymaps 'eshell-mode-map
   "C-z" #'init-eshell/background-process-maybe))
#+END_SRC

****** Clear Buffer

#+BEGIN_SRC emacs-lisp
(defun init-eshell/clear-scrollback ()
  "Clear the scrollback content of the eshell window."
  (interactive)
  (let ((input (eshell-get-old-input)))
    (eshell/clear-scrollback)
    (eshell-emit-prompt)
    (insert input)))
#+END_SRC

*** Esh Module

From the package group's docstring:
#+BEGIN_QUOTE
The ~eshell-module~ group is for Eshell extension modules, which provide optional behavior which the user can enable or disable by customizing the variable ~eshell-modules-list~.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package esh-module
  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after (validate)

  ;; Customize the following variables.
  :custom
  <<esh-module/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<esh-module/config>>)
#+END_SRC

**** Post-Load Execution
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref esh-module/config
:END:

Disable the greeting banner.

#+BEGIN_SRC emacs-lisp
(validate-setq eshell-modules-list (delq 'eshell-banner eshell-modules-list))
#+END_SRC

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref esh-module/custom
:END:

Determine whether input causes window to scroll.
#+BEGIN_SRC emacs-lisp
(eshell-scroll-to-bottom-on-input
 'this
 "On input, scroll the selected Eshell window to the bottom.")
#+END_SRC

*** Em Smart

Em Smart is an Eshell module that provides Eshell with Plan 9-like features.

#+BEGIN_SRC emacs-lisp
(use-package em-smart
  ;; Load this package after the following packages.
  :after (esh-module)

  :custom
  (eshell-where-to-jump 'begin)
  (eshell-review-quick-commands nil)

  :config
  <<em-smart/config>>)
#+END_SRC

**** Config
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-smart/config
:END:

#+BEGIN_SRC emacs-lisp
(add-to-list 'eshell-modules-list 'eshell-smart)
#+END_SRC

*** Em Tramp

Em Tramp is an Eshell modules that provides TRAMP features.

#+BEGIN_SRC emacs-lisp
(use-package em-tramp
  ;; Load this package after the following packages.
  :after (esh-module)

  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<em-tramp/config>>)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-tramp/config
:END:

Load Em Tramp as an Eshell module.

#+BEGIN_SRC emacs-lisp
(add-to-list 'eshell-modules-list 'eshell-tramp)
#+END_SRC

***** Redefine ~eshell/sudo~

For ease of use with Emacs's authentication mechanisms, the full hostname of the machine should be resolved in all cases, even when the Eshell prompt is running locally.

The following code is derived from the Em Tramp package distributed with GNU Emacs.
As such, it is licensed under the same conditions as GNU Emacs itself (namely, GPLv3 or later).

#+BEGIN_SRC emacs-lisp
(defun eshell/sudo (&rest args)
  "Alias \"sudo\" to call Tramp.

Uses the system sudo through TRAMP's sudo method."
  (setq args (eshell-stringify-list (eshell-flatten-list args)))
  (let ((orig-args (copy-tree args)))
    (eshell-eval-using-options
     "sudo" args
     '((?h "help" nil nil "show this usage screen")
       (?u "user" t user "execute a command as another USER")
       :show-usage
       :usage "[(-u | --user) USER] COMMAND
      Execute a COMMAND as the superuser or another USER.")
     (throw 'eshell-external
            (let ((user (or user "root"))
                  (host (or (file-remote-p default-directory 'host)
                            (system-name)))
                  (dir (file-local-name (expand-file-name default-directory)))
                  (prefix (file-remote-p default-directory)))
              ;; `eshell-eval-using-options' reads options of COMMAND.
              (while (and (stringp (car orig-args))
                          (member (car orig-args) '("-u" "--user")))
                (setq orig-args (cddr orig-args)))
              (let ((default-directory
                      (if (and prefix
                               (or
                                (not
                                 (string-equal
                                  "sudo"
                                  (file-remote-p default-directory 'method)))
                                (not
                                 (string-equal
                                  user
                                  (file-remote-p default-directory 'user)))))
                          (format "%s|sudo:%s@%s:%s"
                                  (substring prefix 0 -1) user host dir)
                        (format "/sudo:%s@%s:%s" user host dir))))
                (eshell-named-command (car orig-args) (cdr orig-args))))))))
#+END_SRC

*** Em Rebind

#+BEGIN_SRC emacs-lisp
(use-package em-rebind
  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after (esh-module)

  ;; Apply the following variable customizations.
  :custom
  <<em-rebind/custom>>

  ;; Evaluate the following code before loading this package.
  :init
  <<em-rebind/init>>

  ;; Evaluate the following code after loading this package.
  :config
  <<em-rebind/config>>)
#+END_SRC

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-rebind/custom
:END:

Determine whether movement commands can cause the point to leave the current input.
#+BEGIN_SRC emacs-lisp
(eshell-confine-point-to-input
 nil
 "Allow movement commands to move `point' out of the current input.")
#+END_SRC

**** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-rebind/init
:END:

Add this module to the list of Eshell modules to load.

#+BEGIN_SRC emacs-lisp
(push 'eshell-rebind eshell-modules-list)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref em-rebind/config
:DESCRIPTION: The code to be evaluated after ~em-rebind~ has been loaded.
:END:

Rebind Emacs's vertical movement keys to search through history.
Normal buffer movement is performed using keybindings provided by ~evil~.

#+BEGIN_SRC emacs-lisp
(push '([(control ?n)] . eshell-previous-matching-input-from-input)
      eshell-rebind-keys-alist)
#+END_SRC

*** Em Cmpl

#+BEGIN_SRC emacs-lisp
(use-package em-cmpl
  ;; Load this package eagerly.
  :demand

  ;; Apply the following variable customizations.
  :custom
  (eshell-cmpl-cycle-completions nil "Use zsh-like completion."))
#+END_SRC

* Static Analysis
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref static-analysis
:END:

** Flyspell

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ghook
  ('prog-mode-hook #'flyspell-prog-mode))
#+END_SRC

** Ispell

#+BEGIN_SRC emacs-lisp
(use-package ispell
  ;; Only load this package if the following code evaluates to non-nil.
  :if
  <<ispell/if>>

  ;; Do not load this package lazily.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  <<ispell/config>>)
#+END_SRC

*** Conditional Loading
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ispell/if
:DESCRIPTION: Define condition for loading Ispell.
:END:

Ispell provides interfaces for third-party spellchecking binaries.
If no such binaries exist, Ispell does not need to be downloaded.

#+BEGIN_SRC emacs-lisp
(executable-find "aspell")
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ispell/config
:DESCRIPTION: Code to be evaluated after Ispell has been loaded.
:END:

Set the executable to use for spellchecking.
If =aspell= is not available, disable Ispell.

#+BEGIN_SRC emacs-lisp
(cond
 ((executable-find "aspell")
  (setq ispell-program-name "aspell"))
 (t
  (setq ispell-program-name nil)))
#+END_SRC

** Flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  ;; Enable `flycheck-mode' globally.
  (global-flycheck-mode))
#+END_SRC

* Programming Languages
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref programming-languages
:END:

** Lisps
It is desirable to have slightly different character matching behavior when editing Lisps.
The following is a list of the Lisp modes I edit in.

#+BEGIN_SRC emacs-lisp
(defconst init-prog-lisp/major-modes
  '(cider-repl-mode
    clojure-mode
    emacs-lisp-mode
    ielm-mode
    lisp-mode
    minibuffer-inactive-mode
    scheme-mode)
  "A list of Lisp major modes.")
#+END_SRC

And the above modes' hooks:
#+BEGIN_SRC emacs-lisp
(defconst init-prog-lisp/major-mode-hooks
  (mapcar #'derived-mode-hook-name init-prog-lisp/major-modes)
  "A list of Lisp major mode hooks.")
#+END_SRC

The function \src_emacs-lisp{derived-mode-hook-name} is provided by /Derived/, which is a built-in package and can be \src_emacs-lisp{require}d.
#+BEGIN_SRC emacs-lisp :noweb-ref dependencies
(require 'derived)
#+END_SRC
** Indent Tabs Mode
For sexp-based languages it is desirable to disallow tabs for line indentation.

#+BEGIN_SRC emacs-lisp
(defun init-prog-lisp/use-spaces ()
  "Only use spaces (as opposed to tabs) for indentation."
  (setq indent-tabs-mode nil))
#+END_SRC

Add above function to all Lisp major modes' hooks.

#+BEGIN_SRC emacs-lisp
(general-add-hook init-prog-lisp/major-mode-hooks #'init-prog-lisp/use-spaces)
#+END_SRC

** Lisp Mode
#+BEGIN_SRC emacs-lisp
(use-package lisp-mode
  :config
  <<lisp-mode/config>>)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref lisp-mode/config
:END:

**** Fuco1's Indentation
:PROPERTIES:
:COPYRIGHT_AUTHOR: Matus Goljer (Fuco1)
:COPYRIGHT_EMAIL: matus.goljer@gmail.com
:COPYRIGHT_URL: https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94
:COPYRIGHT_YEAR: 2015
:END:

Redefine Lisp Mode's indentation function.
#+BEGIN_SRC emacs-lisp
(defun lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.

INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.

If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:

-`defun', meaning indent `defun'-style
  \(this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);

- an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;

- a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.

This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))
#+END_SRC

** Aggressive Indent
Aggressive Indent provides a minor mode to re-indent code after every change.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :ghook
  (init-prog-lisp/major-mode-hooks #'aggressive-indent-mode))
#+END_SRC

** Character Matching
*** Smartparens

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  ;; Evaluate the following code after loading this package.
  :config
  <<smartparens/config>>)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref smartparens/config
:END:

Lisps use the single quote (='=) for quoting, where it is not paired with a closing character.
#+BEGIN_SRC emacs-lisp
(sp-local-pair lisp-major-modes "'" nil :actions nil)
#+END_SRC

*** Evil Cleverparens
Author Llli Pieponnen (luxbock)'s describes Evil Cleverparens as providing an "Evil normal-state minor-mode for editing lisp-like languages".

#+BEGIN_SRC emacs-lisp
(use-package evil-cleverparens
  ;; Delay loading this package until after the following packages.
  :after
  (:all evil smartparens)

  ;; Inform the byte compiler of the following functions.
  :functions evil-move-beyond-eol

  ;; Add the following autoloading hooks.
  :ghook
  <<evil-cleverparens/ghook>>

  ;; Add the following non-autoloading hooks.
  :gfhook
  <<evil-cleverparens/gfhook>>

  :config
  <<evil-cleverparens/config>>)
#+END_SRC

**** Autoloading Hooks
:PROPERTIES:
:DESCRIPTION: Add auto-loading hooks related to Evil Cleverparens.
:HEADER-ARGS+: :noweb-ref evil-cleverparens/ghook
:END:

Enable ~evil-cleverparens-mode~ for Lisps.
#+BEGIN_SRC emacs-lisp
(lisp-major-mode-hooks #'evil-cleverparens-mode)
#+END_SRC

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-cleverparens/gfhook
:END:

Let the cursor move past the end of lines in Lisp source code.
#+BEGIN_SRC emacs-lisp
(lisp-major-mode-hooks #'init-prog-lisp/evil-move-beyond-eol)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-cleverparens/config
:END:

#+BEGIN_SRC emacs-lisp
(defun evil-move-beyond-eol ()
  "Allow the cursor to move beyond the end of the line."
  (setq evil-move-beyond-eol t))
#+END_SRC

** Lisp-1

Lisp-1 languages have a single namespace for all names.

*** Geiser Guile

#+BEGIN_SRC emacs-lisp
(use-package geiser-guile
  :config
  (when-let ((path (expand-file-name
                    "org.gnu.savannah.git/guix/"
                    (or (getenv "XDG_SOURCE_DIR") "~/source")))
             ((file-directory-p path)))
    (add-to-list 'geiser-guile-load-path path)))
#+END_SRC

*** Guix

From the package's commentary:
#+BEGIN_QUOTE
Emacs-Guix (aka "guix.el") provides featureful visual interface for the GNU Guix package manager.
It allows you:
- to search for packages and to look at their code (package recipes);
- to manage your Guix profile(s) by installing/removing packages;
- to look at, compare and remove profile generations;
- to look at system services and generations (if you use [Guix System]);
- to do many other things.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package guix
  ;; Load this package if the following code evaluates to non-nil.
  :if
  <<guix/if>>

  ;; Add the following auto-loading hooks.
  :ghook
  <<guix/ghook>>

  ;; Evaluate the following code after loading this package.
  :custom
  (guix-load-path
   (when-let ((path (expand-file-name
                     "org.gnu.savannah.git/guix/"
                     (or (getenv "XDG_SOURCE_DIR") "~/source")))
              ((file-directory-p path)))
     path)
   "Directory or directories to prepend to Guile's `%load-path' and `load-compiled-path'."))
#+END_SRC

**** Conditions for Loading
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref guix/if
:END:

The package relies on =guix= being available on =$PATH=.
#+BEGIN_SRC emacs-lisp
(executable-find "guix")
#+END_SRC

**** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref guix/ghook
:END:

Replace hash symbols with ellipses.
#+BEGIN_SRC emacs-lisp
('(dired-mode-hook shell-mode-hook) #'guix-prettify-mode)
#+END_SRC

** Lisp-2
Lisp-2 languages have a separate namespace for functions.

*** Superior Lisp Interaction Mode (SLIME)

#+BEGIN_SRC emacs-lisp
(use-package slime
  :init
  (defvar init-prog-lisp/slime-extra
    '(slime-indentation slime-fancy)
    "The contrib packages for SLIME to load")

  :config
  (setq slime-lisp-implementations
        '((sbcl ("sbcl" "--noinform"))))
  (slime-setup init-prog-lisp/slime-extra))
#+END_SRC

*** Emacs Lisp

#+BEGIN_SRC emacs-lisp
(use-package elisp-mode
  ;; Add the following keybindings.
  :general
  (:keymaps 'emacs-lisp-mode-map
   "C-c C-c" #'eval-buffer))
#+END_SRC

**** Helpful

From the package's README:
#+BEGIN_QUOTE
Helpful is an alternative to the built-in Emacs help that provides much more contextual information.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :general
  ("C-h c" #'helpful-command
   "C-h f" #'helpful-callable
   "C-h k" #'helpful-key
   "C-h v" #'helpful-variable)

  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable))
#+END_SRC

* RESTful APIs
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref restful-apis
:END:

** REST Client

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :preface
  (defconst init-web/http-extension
    (rx ".http" string-end)
    "The filename extension \".http\".")

  :mode
  ("\\.http\\'" . restclient-mode))
#+END_SRC

** Company REST Client

#+BEGIN_SRC emacs-lisp
(use-package company-restclient
  :after (:all company restclient)

  :demand

  :config
  (add-to-list 'company-backends 'company-restclient))
#+END_SRC

** Polymode for REST Client

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref polymode/config
:END:

**** Emacs Lisp Inner Mode
Define the inner mode for Emacs Lisp sections of REST Client buffers.

#+BEGIN_SRC emacs-lisp
(define-innermode poly-restclient/emacs-lisp-innermode
  :mode 'emacs-lisp-mode
  :head-mode 'host
  :tail-mode 'host)
#+END_SRC

Define a matcher for single-line expressions.
#+BEGIN_SRC emacs-lisp
(define-innermode poly-restclient/emacs-lisp/single-line-innermode poly-restclient/emacs-lisp-innermode
  :head-matcher (rx line-start ":" (one-or-more (not (any " "))) " :=")
  :tail-matcher (rx "\n"))
#+END_SRC

Define a matcher for multi-line expressions.
#+BEGIN_SRC emacs-lisp
(define-innermode poly-restclient/emacs-lisp/multi-line-innermode poly-restclient/emacs-lisp-innermode
  :head-matcher (rx line-start ":" (one-or-more (not (any " "))) " := <<\n")
  :tail-matcher (rx line-start "#\n"))
#+END_SRC

**** JSON Inner Mode
Define the inner mode for JSON sections.

#+BEGIN_SRC emacs-lisp
(define-innermode poly-restclient/json-innermode
  :mode 'json-mode
  :head-mode 'body
  :tail-mode 'body
  :head-matcher (rx line-start "{" line-end)
  :tail-matcher (rx line-start "}" line-end))
#+END_SRC

**** Rest Client Parent Mode
#+BEGIN_SRC emacs-lisp
(define-hostmode poly-restclient-hostmode
  :mode 'restclient-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-polymode poly-restclient-mode
  :hostmode 'poly-restclient-hostmode
  :innermodes '(poly-restclient/emacs-lisp/single-line-innermode
                poly-restclient/emacs-lisp/multi-line-innermode
                poly-restclient/json-innermode))
#+END_SRC

* Windows and Frames
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref windows-and-frames
:END:

** Minions
#+BEGIN_QUOTE
A minor-mode menu for the mode line.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package minions
  ;; Load this package eagerly.
  :demand

  ;; Apply the following variable customizations.
  :custom
  (minions-mode-line-lighter "…")
  (minions-mode t "Enable `minions-mode' globally."))
#+END_SRC

** EXWM
From the package's README:
#+BEGIN_QUOTE
EXWM (Emacs X Window Manager) is a full-featured tiling X window manager for Emacs built on top of XELB.
It features:

- Fully keyboard-driven operations
- Hybrid layout modes (tiling & stacking)
- Dynamic workspace support
- ICCCM/EWMH compliance
- (Optional) RandR (multi-monitor) support
- (Optional) Built-in system tray
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package exwm
  ;; Do not load the package lazily.
  :demand

  ;; Inform the bytecode compiler of the following functions.
  :commands
  (init-window-and-frame/start-process)

  ;; Customize the following variables.
  :custom
  <<exwm/custom>>

  ;; Add the following function hooks.
  :gfhook
  <<exwm/gfhook>>

  ;; Execute the following code after the package has been loaded.
  :config
  <<exwm/config>>)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref exwm/custom
:END:

Only enable a single workspace.
Buffer switching with e.g. Counsel is preferred to using multiple workspaces.

#+BEGIN_SRC emacs-lisp
(exwm-workspace-number 1)
#+END_SRC

*** Non-Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref exwm/gfhook
:END:

Use Firefox windows' names as the windows' buffers names.

#+BEGIN_SRC emacs-lisp
('exwm-update-title-hook
 (defun init-window-and-frame/update-title ()
   "Use Firefox windows' names as the windows' buffers names."
   (when (or (string-match "Icecat" exwm-class-name)
             (string-match "Next" exwm-class-name))
     (exwm-workspace-rename-buffer exwm-title))))
   #+END_SRC

Add simulation keys for Firefox windows.

#+BEGIN_SRC emacs-lisp
('exwm-manage-finish-hook
 (defun init-window-and-frame/set-firefox-simulation-keys ()
   (when (and exwm-class-name (string= exwm-class-name "Icecat"))
     (exwm-input-set-local-simulation-keys
      '(([?\C-s] . [?\C-f])
        ([?\C-q] . [?\C-w])
        ([?\C-t] . [?\C-n]))))))
   #+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref exwm/config
:END:

Define a function to launch applications from the shell.
Launching applications is performed by calling ~start-process-shell-command~.

#+BEGIN_SRC emacs-lisp
(defun init-window-and-frame/start-process (command)
  "Start a process via a shell COMMAND."
  (interactive (list (read-shell-command "$ ")))
  (start-process-shell-command command nil command))
#+END_SRC

**** Keybindings
Effective use of EXWM requires the ability to return from ~char-mode~ to ~line-mode~.
This will be performed with =s-r=.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-r") #'exwm-reset)
#+END_SRC

Hide all windows except the current one.
#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-o") #'delete-other-windows)
#+END_SRC

Close the current window and kill its buffer.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "C-s-x") #'kill-buffer-and-window)
#+END_SRC

Close the current window without killing its buffer.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-x") #'delete-window)
#+END_SRC

Run a shell command.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "<s-return>") #'init-window-and-frame/start-process)
#+END_SRC

Open an Eshell buffer in the current buffer's location.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "C-z") #'init-eshell/find-eshell-here)
#+END_SRC

Move =point= to the windows immediately around the current window.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-h") #'windmove-left)
(exwm-input-set-key (kbd "s-j") #'windmove-down)
(exwm-input-set-key (kbd "s-k") #'windmove-up)
(exwm-input-set-key (kbd "s-l") #'windmove-right)
#+END_SRC

** Ace Window
From the README of Oleh Krehel (abo-abo)'s Ace Window package:
#+BEGIN_QUOTE
This package aims to take the speed and predictability of ~windmove~ and pack it into a single key binding, similar to ~other-window~.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  ("s-a" #'ace-window)

  ;; Apply the following customizations.
  :custom
  <<ace-window/custom>>

  ;; Evaluate the following code before loading this package.
  :init
  <<ace-window/init>>)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ace-window/custom
:END:

Use home row characters to label windows.

#+BEGIN_SRC emacs-lisp
(aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
#+END_SRC

Issue a read-char even for one window.
This allows more flexibility in what action is performed, i.e. more than just changing focus, at the cost of requiring more keystrokes for the single most common task of changing focus.

#+BEGIN_SRC emacs-lisp
(aw-dispatch-always t)
#+END_SRC

Show the ace window key in the mode line.
This is useful for EXWM buffers which cannot display keys in the buffer itself.

#+BEGIN_SRC emacs-lisp
(ace-window-display-mode t)
#+END_SRC

*** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ace-window/init
:END:

Bind Ace Window to =s-a= in EXWM.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'exwm
  (exwm-input-set-key (kbd "s-a") #'ace-window))
#+END_SRC

* Footnotes

[fn:1] ~:ghook~ is one of the keywords added to \src_emacs-lisp{use-package} by /General/.
