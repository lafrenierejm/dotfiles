#+TITLE: Emacs Configuration
#+AUTHOR: Joseph LaFreniere (lafrenierejm)
#+EMAIL: joseph@lafreniere.xyz
#+PROPERTY: header-args+ :noweb yes

#+BEGIN_SRC emacs-lisp :tangle yes
;;; init.el --- Configure Emacs  -*- lexical-binding: t; -*-

;; Copyright (C) 2018 Joseph LaFreniere

;; Author: Joseph LaFreniere <joseph@lafreniere.xyz>
;; Version 0.1

;; <<license>>

;;; Commentary:
;; <<commentary>>

;;; Code:
<<bootstrapping>>

;;; Customization:
<<customization>>

;;; Visual Interface:
<<interface>>

;;; Literate Programming:
<<literate-programming>>

;;; Evil:
<<evil>>

;;; Minibuffer:
<<minibuffer>>

(provide 'init)
;;; init.el ends here
#+END_SRC

* License
** Code
All source code in this file is licensed under the [[http://www.gnu.org/licenses/gpl-3.0.html][GNU Public License v3]] or later.
#+BEGIN_SRC text :noweb-ref license
This file is not part of GNU Emacs.

Init is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

Init is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with GNU Emacs.
If not, see <https://www.gnu.org/licenses/>.
#+END_SRC

** Prose
All prose in this file is licensed under the [[http://www.gnu.org/licenses/fdl-1.3.html][GNU Free Documentation License (FDL) v1.3]].
#+BEGIN_SRC text
Copyright (C) 2019 Joseph LaFreniere.
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
#+END_SRC

* Commentary
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref commentary
:END:

#+BEGIN_SRC text
This is tangled source of Joseph LaFreniere (lafrenierejm)'s literate Emacs initialization file.
Please refer to `init.org' in this same file for full commentary.
#+END_SRC

* Bootstrapping
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref bootstrapping
:END:

GNU Emacs does not have the capability to use an Org file directly as its initialization file.
As such, this file needs to be tangled manually for its first use on a new system.
The following code ensures that this step is only needed once.

Before any other installed packages can be configured, Package must be loaded and \src_emacs-lisp{package-initialize} called.
#+BEGIN_SRC emacs-lisp :noweb-ref dependencies
(require 'package)
(package-initialize)
#+END_SRC

** Use Package

Next, Use Package is loaded.
This package provides the \src_emacs-lisp{use-package} macro for declarative loading of other packages.
#+BEGIN_SRC emacs-lisp
(require 'use-package)
#+END_SRC

Loading every package during Emacs's initialization is unnecessary and increases load time.
Instead, packages should only be loaded when a feature they provide is actually needed.
Use Package provides a feature to lazy-load packages by default:
#+BEGIN_SRC emacs-lisp
(setq use-package-always-defer t)
#+END_SRC

** Org
:PROPERTIES:
:CUSTOM_ID: bootstrap/org
:END:

After Use Package has been loaded, we can use it to configure all other packages.
Tangling this Org file for use as Emacs's initialization file requires features from the Org package.
As such, the below function is specified to belong to the =:config= section of Org's \src_emacs-lisp{use-package} declaration.
The process of tangling this file is to
1. Compare the modification time of this file to its tangled source, =./init.el=.
2. If this file is the more recent of the two, tangle this file then byte compile and load the result.
3. Otherwise the tangled file is the more recent, so byte compile and load it directly.

#+BEGIN_SRC emacs-lisp :noweb-ref org/config
(defun org-babel-tangle-init ()
  "Tangle Emacs's init file."
  (let ((el-file user-init-file)
        (org-file "~/.config/emacs/init.org")
        (load-byte-compile t))
    (if (not (file-exists-p el-file))
        ;; If the Emacs Lisp file does not exist, tangle the Org file.
        (org-babel-tangle-file org-file)
      ;; If the Emacs Lisp file does exist, compare the modification times.
      (let* ((org-modify (modify-time org-file))
             (el-modify (modify-time el-file)))
        ;; If the Org file was modified more recently, tangle it.
        (when (< el-modify org-modify)
          (org-babel-tangle-file org-file))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :noweb-ref org/config
(defun modify-time (file)
  (-> (file-attributes file)
      (file-attribute-modification-time)
      (float-time)))
#+END_SRC

** General
General provides convenience wrappers for setting keybindings and adding hooks.
It is highly compatible with Use Package and provides additional keywords to the \src_emacs-lisp{use-package} macro.
General is loaded now just so it can be used in all further \src_emacs-lisp{use-package} declarations.
The ~:demand~ keyword is used to ensure General is loaded eagerly.
#+BEGIN_SRC emacs-lisp
(use-package general
  :demand)
#+END_SRC

* Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref customization
:END:

Emacs has a customization system distinct from simply \src_emacs-lisp{setq}-ing variables.
By default, any customizations made using that system are appended to the bottom of Emacs's init file.
This is controlled by the value of the \src_emacs-lisp{custom-file} variable.
That variable is provided as part of the Cus Edit package, so we will perform modifications inside the \src_emacs-lisp{use-package} declaration of Cus Edit.

Viewing the help documentation for \src_emacs-lisp{custom-file} (via =C-h v custom-file RET=) tells us
#+BEGIN_QUOTE
The default is nil, which means to use your init file as specified by \src_emacs-lisp{user-init-file}.
If the value is not \src_emacs-lisp{nil}, it should be an absolute file name.

You can set this option through Custom, if you carefully read the last paragraph below.
However, usually it is simpler to write something like the following in your init file:

#+BEGIN_EXAMPLE emacs-lisp
(setq custom-file "~/.emacs-custom.el")
(load custom-file)
#+END_EXAMPLE
#+END_QUOTE

That \src_emacs-lisp{setq} and \src_emacs-lisp{load} need to be evaluated /after/ Cus Edit has been loaded, so the expressions should go in the ~:config~ block of the \src_emacs-lisp{use-package} declaration.
Additionally, \src_emacs-lisp{custom-file} needs to exist before it is loaded.
The file can be created with the function \src_emacs-lisp{f-touch}.

\src_emacs-lisp{f-touch}, in turn, is provided by the package F.
Since we are relying a function from an external package when we're loading Cus Edit, we need to inform \src_emacs-lisp{use-package} of that fact and tell it to load Cus Edit only after F has been loaded.
This is done with the ~:after~ keyword of \src_emacs-lisp{use-package}.

Additionally, we want Cus Edit to always be loaded (not just when we interactively use something it provides).
\src_emacs-lisp{use-package} needs to told to load Cus Edit eagerly (as opposed to lazily), which is accomplished with the ~:demand~ keyword.

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :after f

  :demand

  :config
  (let ((path (expand-file-name
               "custom.el"
               (file-name-directory user-init-file))))
    (f-touch path)
    (setq custom-file path)
    (load custom-file)))
#+END_SRC

/F/ is not built-in to GNU Emacs, so it must be downloaded by some package manager separately.
Further \src_emacs-lisp{f-touch} is not marked as an auto-loaded function in /F/ (this too can be discovered by viewing the function's help), so /F/ must also be loaded eagerly.

#+BEGIN_SRC emacs-lisp
(use-package f
  :demand)
#+END_SRC

* Visual Interface
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref interface
:END:

Emacs is fundamentally a user interface built around plain text.
Given the focus on plain text, several of Emacs's default modes can be disabled.
These are
- \src_emacs-lisp{menu-bar-mode},
- \src_emacs-lisp{tool-bar-mode}, and
- \src_emacs-lisp{scroll-bar-mode}.


#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

The splash screen, startup message, and scratch message also serve little use, so they too can be disabled.
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      inhibit-startup-message t
      initial-scratch-message nil)
#+END_SRC

** Font
What are colloquially known as "fonts" Emacs refers to "faces".
Google's Noto family of has the best glyph coverage that I am aware of, so I try to use it everywhere I can.
Alan Third has a nice write-up in his [[https://idiocy.org/emacs-fonts-and-fontsets.html]["Emacs, fonts and fontsets" post on idiocy.org]] of how to enable Noto fonts everywhere and simultaneously reduce Emacs's need to scour the system for fallback font sets.
The /Faces/ package provides this functionality, so all font setup can can occur within /Faces/'s \src_emacs-lisp{use-package}.

#+BEGIN_SRC emacs-lisp
(use-package faces
  :demand

  :config
  (when (member "Noto Sans" (font-family-list))
    (set-face-attribute 'default nil :font "Noto Sans Mono")
    (set-fontset-font t 'latin "Noto Sans")

    ;; East Asia: 你好, 早晨, こんにちは, 안녕하세요
    (set-fontset-font t 'han "Noto Sans CJK SC Regular")
    (set-fontset-font t 'kana "Noto Sans CJK JP Regular")
    (set-fontset-font t 'hangul "Noto Sans CJK KR Regular")
    (set-fontset-font t 'cjk-misc "Noto Sans CJK KR Regular")

    ;; South East Asia: ជំរាបសួរ, ສະບາຍດີ, မင်္ဂလာပါ, สวัสดีครับ
    (set-fontset-font t 'khmer "Noto Sans Khmer")
    (set-fontset-font t 'lao "Noto Sans Lao")
    (set-fontset-font t 'burmese "Noto Sans Myanmar")
    (set-fontset-font t 'thai "Noto Sans Thai")

    ;; Africa: ሠላም
    (set-fontset-font t 'ethiopic "Noto Sans Ethiopic")

    ;; Middle/Near East: שלום, السّلام عليكم
    (set-fontset-font t 'hebrew "Noto Sans Hebrew")
    (set-fontset-font t 'arabic "Noto Sans Arabic")

    ;;  South Asia: નમસ્તે, नमस्ते, ನಮಸ್ಕಾರ, നമസ്കാരം, ଶୁଣିବେ,
    ;;              ආයුබෝවන්, வணக்கம், నమస్కారం, བཀྲ་ཤིས་བདེ་ལེགས༎
    (set-fontset-font t 'gujarati "Noto Sans Gujarati")
    (set-fontset-font t 'devanagari "Noto Sans Devanagari")
    (set-fontset-font t 'kannada "Noto Sans Kannada")
    (set-fontset-font t 'malayalam "Noto Sans Malayalam")
    (set-fontset-font t 'oriya "Noto Sans Oriya")
    (set-fontset-font t 'sinhala "Noto Sans Sinhala")
    (set-fontset-font t 'tamil "Noto Sans Tamil")
    (set-fontset-font t 'telugu "Noto Sans Telugu")
    (set-fontset-font t 'tibetan "Noto Sans Tibetan")))
#+END_SRC

When working with prose, I prefer to use a variable-pitch (as opposed to monospace) face.
Frequently, though, some aspects of a mostly-prose document are better presented in monospace.
An example of this is the code blocks in this Org file.
For mixing the two pitches I use the /Mixed Pitch/ package by Alex Branham.

#+BEGIN_SRC emacs-lisp
(use-package mixed-pitch
  :ghook
  ('(org-mode-hook text-mode-hook) #'mixed-pitch-mode))
#+END_SRC

** Rainbow Identifiers
Rainbow Identifiers provides a minor mode that highlights identifiers based on their names.
The highlight color of each identifier is chosen based on the hash of the identifier's name.
The package's source is available at [[https://github.com/Fanael/rainbow-identifiers][github.com/Fanael/rainbow-identifiers]].

I want this package to be enabled when programming, so I enable it for \src_emacs-lisp{prog-mode} and all major modes that inherit from \src_emacs-lisp{prog-mode}, which effectively covers all programming language major modes.
This is done by adding \src_emacs-lisp{rainbow-identifiers-mode} to \src_emacs-mode{prog-mode-hook}, performed below by the arguments to the ~:ghook~ keyword[fn:1].

#+BEGIN_SRC emacs-lisp
(use-package rainbow-identifiers
  :ghook
  ('prog-mode-hook #'rainbow-identifiers-mode)

  :custom
  <<rainbow-identifiers/custom>>)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref rainbow-identifiers/custom
:END:

Only use Rainbow Identifiers to highlight (read: color) variable names.

#+BEGIN_SRC emacs-lisp
(rainbow-identifiers-faces-to-override
 '(font-lock-constant-face
   font-lock-type-face
   font-lock-function-name-face
   font-lock-variable-name-face
   font-lock-keyword-face
   font-lock-builtin-face))
#+END_SRC

** Rainbow Delimiters
Rainbow Delimters provides a minor mode that highlights delimeters such as parantheses based on their depth.
The highlight color of each level is distinct.
The package's source is available at [[https://github.com/Fanael/rainbow-delimiters][github.com/Fanael/rainbow-delimeters]].

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  ;; Load this package eagerly.
  :demand

  :ghook
  ('prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Line Wrapping
Out of the box, Emacs will fill paragraph to 72 characters.
Most projects that care about line width adhere to an 80 character (79 + line feed) maximum width, so to reduce the amount of per-project customization we can set the default value to 80.
#+BEGIN_SRC emacs-lisp
(custom-set-default 'fill-column 80)
#+END_SRC

** Display Line Numbers

#+BEGIN_SRC emacs-lisp
(use-package display-line-numbers
  ;; Only load this package if the following code evaluates to non-nil.
  :if
  <<display-line-numbers/if>>

  ;; Add the following auto-loading hooks.
  :ghook
  ('prog-mode-hook #'display-line-numbers-mode))
#+END_SRC

*** Conditional Loading
:PROPERTIES:
:DESCRIPTION: Define condition for loading ~display-line-numbers~.
:HEADER-ARGS+: :noweb-ref display-line-numbers/if
:END:

~display-line-numbers~ was added in GNU Emacs 26.1.

#+BEGIN_SRC emacs-lisp
(version< "26.1" emacs-version)
#+END_SRC

* Literate Programming
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref literate-programming
:END:

The [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] programming is a programming paradigm introduced by Donald Knuth in which the standard precedence of code and explanatory prose are flipped.
Whereas the standard programming paradigm has a source documents' text "defaulting" to source code, literate programming assumes that text is intended for human consumption (the role normally filled by comments) unless it is explicitly demarcated as source code.
A literate document can then be /tangled/ into a source-only file.

** Polymode
:PROPERTIES:
:CUSTOM_ID: polymode
:END:

Polymode is a framework for supporting multiple major modes (MMM) inside a single Emacs buffer.
This can benefit both literate and traditional programming by allowing one to code blocks and docstrings, respectively, with the full features of dedicated major modes.

#+BEGIN_SRC emacs-lisp
(use-package polymode
  :demand)
#+END_SRC

** Org Mode
Strong support for literate programming is provided by Org mode's features.

*** Org
:PROPERTIES:
:CUSTOM_ID: bootstrap/org
:END:

Note that although \src_emacs-lisp{use-package} is used below, the /Org/ package should already be loaded due to the \src_emacs-lisp{require} call in [[#bootstrap/org]].

#+BEGIN_SRC emacs-lisp
(use-package org
  :demand

  :gfhook
  <<org/gfhook>>

  :config
  <<org/config>>)
#+END_SRC

**** Non-Autoloading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref org/gfhook
:END:

Enable the following minor modes in all Org buffers:
- \src_emacs-lisp{flyspell-mode} for on-the-fly spell checking.
- \src_emacs-lisp{org-indent-mode} to indent text according to outline structure.
- \src_emacs-lisp{visual-line-mode} to naturally wrap long lines.


#+BEGIN_SRC emacs-lisp
('org-mode-hook (list #'flyspell-mode #'org-indent-mode #'visual-line-mode))
#+END_SRC

**** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref org/custom
:END:

Determine how leading whitespace characters in source blocks are treated.
#+BEGIN_SRC emacs-lisp
(org-src-preserve-indentation t "Preserve source blocks' indentation.")
(org-edit-src-content-indentation 0 "Do not add any additional indentation to source blocks in Org buffers.")
#+END_SRC

Determine where source blocks are opened.
Note that this is effectively deprecated by Polymode;  I set it here only as a fallback.
#+BEGIN_SRC emacs-lisp
(org-src-window-setup 'current-window "Edit source blocks in the current window.")
#+END_SRC

Determine what is required to follow links.
#+BEGIN_SRC emacs-lisp
(org-return-follows-link t "Follow links with just RET.")
#+END_SRC

Set whether confirmation is required before evaluating source blocks.
#+BEGIN_SRC emacs-lisp
(org-confirm-babel-evaluate nil "Do not require confirmation before evaluating source blocks.")
#+END_SRC

Set the workflow states.
#+BEGIN_SRC emacs-lisp
(org-todo-keywords '((sequence "TODO" "FEEDBACK" "VERIFY" "|"
                               "DELEGATED" "DONE(d!/!)" "|"
                               "CANCELED")))
#+END_SRC

*** Poly Org

/Poly Org/ provides Polymode definitions for Org buffers.
#+BEGIN_SRC
(use-package poly-org)
#+END_SRC

*** Ox LaTeX

/Ox/ (Org eXport) allows exporting Org files such as this one.
/Ox LaTeX/ builds uses that framework to export to (La)TeX.

#+BEGIN_SRC emacs-lisp
(use-package ox-latex
  :config
  <<ox-latex/config>>)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ox-latex/config
:END:

If =latexmk= and its Perl dependency exist in =PATH=, use =latexmk= with a LuaLaTeX backend to compile TeX files.
#+BEGIN_SRC emacs-lisp
(when (and (executable-find "latexmk")
           (executable-find "perl"))
  (general-setq-default org-latex-pdf-process '("latexmk -lualatex -f %f")))
#+END_SRC

*** Smartparens
:PROPERTIES:
:END:

:PROPERTIES:
:HEADER-ARGS+: smartparents/config
:END:

The equals sign (\=), tilde (\~), and forward slash (/) are used by Org syntax to wrap inline monospace, code, text, and italics respectively.
I want them to be automatically paired in Org buffers.
#+BEGIN_SRC emacs-lisp
(sp-local-pair 'org-mode "=" "=")
(sp-local-pair 'org-mode "~" "~")
(sp-local-pair 'org-mode "/" "/")
#+END_SRC

Meanwhile, when writing prose I tend to use the single prime (') primarily as an apostrophe in English prose so I want it to /not/ be paired.
#+BEGIN_SRC emacs-lisp
(sp-local-pair 'org-mode "'" nil :actions nil)
#+END_SRC

*** Evil Org

/Evil Org/ adds a minor mode that provides [[Evil]] keybindings for common Org mode actions.
#+BEGIN_SRC emacs-lisp
(use-package evil-org
  ;; Load this package after the following packages.
  :after (:all evil org)

  ;; Add the following auto-loading hooks.
  :ghook
  <<evil-org/ghook>>

  ;; Inform the bytecode compiler of the following functions.
  :functions
  (evil-org-set-key-theme)

  ;; Apply the following variable customizations.
  :custom
  <<evil-org/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<evil-org/config>>)
#+END_SRC

**** Auto-Loading Hooks
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/ghook
:END:

Enable Evil Org mode in all Org mode buffers.
#+BEGIN_SRC emacs-lisp
('org-mode-hook #'evil-org-mode)
#+END_SRC

**** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/custom
:END:

Specify the key themes to enable.
#+BEGIN_SRC emacs-lisp
(evil-org-key-theme
 '(calendar
   navigation
   insert
   textobjects))
#+END_SRC

Retain selection after typing =<= or =>= in visual state.
#+BEGIN_SRC emacs-lisp
(evil-org-retain-visual-state-on-shift t)
#+END_SRC

**** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-org/config
:END:

Apply the keybindings specified in ~evil-org-key-theme~.
#+BEGIN_SRC emacs-lisp
(evil-org-set-key-theme)
#+END_SRC

* Evil
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil
:CUSTOM_ID: evil
:END:

/Evil/ aims to implement Vi's user features, most notably Vi's modal keyboard interface, in Emacs Lisp for use in Emacs.
I prefer Vi's keybindings to Emacs's, so I enable Evil everywhere I can.
#+BEGIN_SRC emacs-lisp
(use-package evil
  ;; Load this package eagerly.
  :demand

  ;; Add the following autoloading hooks.
  :ghook
  <<evil/ghook>>

  ;; Apply the following variable customizations.
  :custom
  <<evil/custom>>

  ;; Set the following keybindings.
  :general
  <<evil/general>>

  ;; Evaluate the following code before loading this package.
  :init
  <<evil/init>>

  ;; Evaluate the following code after loading this package.
  :config
  <<evil/config>>)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/custom
:END:

Determine whether to enable Evil in minibuffers.
#+BEGIN_SRC emacs-lisp
(evil-want-minibuffer t "Enable Evil in minibuffers.")
#+END_SRC

*** Set Keybindings (~:general~)
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/general
:END:

Do not allow =C-z= to enter Emacs mode.
Instead, make it a noop as far as Evil is concerned.
#+BEGIN_SRC emacs-lisp
(:states (list 'normal 'insert 'visual 'replace 'operator 'motion)
 "C-z" nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(:states '(motion normal visual)
 "H" #'init-evil/beginning-of-maybe-line
 "L" #'init-evil/end-of-maybe-line
 (kbd "SPC") #'evil-toggle-fold)
#+END_SRC

Bind =:= to ~eval-expression~ to evaluate one-off Emacs Lisp expressions.

#+BEGIN_SRC emacs-lisp
(:states '(motion normal replace visual)
 ":" #'eval-expression)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(:states 'normal
 "Y" #'init-evil/evil-yank-to-end-of-line)
#+END_SRC

*** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/init
:END:

Allow use of Evil Collection.
#+BEGIN_SRC emacs-lisp
(setq-default evil-want-integration t)
(setq-default evil-want-keybinding nil)
#+END_SRC

*** Post-Load Evaluation (~:config~)
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil/config
:END:

Enable Evil by default in all modes.
#+BEGIN_SRC emacs-lisp
(evil-mode 1)
#+END_SRC

**** Define =evil-yank-to-end-of-line=
#+BEGIN_SRC emacs-lisp
(defun init-evil/evil-yank-to-end-of-line ()
  "Yank the characters from point to the end of the current line."
  (interactive)
  (evil-yank (point) (point-at-eol)))
#+END_SRC

**** Semantic Movement Within Lines
***** Define ~back-to-comment~
The following code is based on [[http://stackoverflow.com/a/14245964%0A][a StackOverflow answer]] by user [[https://stackoverflow.com/users/387076/gilles][Gilles]].
All code posted to StackOverflow.com is licensed under CC BY-SA 3.0, so the following derived code is also CC BY-SA 3.0-licensed.

#+BEGIN_SRC emacs-lisp
(defun init-evil/back-to-comment ()
  "Move point to the beginning of the comment in the current line.

If the current line does not contain a comment, then point will stay
in place and the function will return nil.  Otherwise the function
will return t."
  (interactive "^")
  (save-match-data
    ;; Record the position of the beginning of the line.
    (let ((old-point (point))
          (bol (progn
                 (beginning-of-line)
                 (point))))
      ;; Go to the end of the line.
      (end-of-line)
      ;; Look backward from there for a comment.
      (if (and comment-start-skip
               (comment-search-backward bol 'noerror))
          (progn
            (message "Comment found")
            ;; Go to the start of the comment's delimeter.
            (search-backward-regexp comment-start-skip bol 'noerror)
            ;; Go the start of any immediately prior whitespace.
            (skip-syntax-backward " \t" bol)
            ;; Return t.
            t)
        ;; Return point to its previous location.
        (goto-char old-point)
        ;; Return nil.
        nil))))
#+END_SRC

***** Define ~init-evil/back-totext~
#+BEGIN_SRC emacs-lisp
(defun init-evil/back-totext ()
  "Move point to the last non-whitespace character on this line."
  (interactive)
  ;; Move point to the last character on this line.
  (move-end-of-line nil)
  ;; Move backward for non-whitesapce character.
  (re-search-backward "^\\|[^[:space:]]")
  ;; Move forward one character.
  (forward-char))
#+END_SRC

***** Define ~beginning-of-maybe-line~
~beginning-of-maybe-line~ moves ~point~ toward the beginning of the current line incrementally by semantic region.
The following semantic elements are considered:
1. Comment
2. Source code
3. Indentation (leading whitespace)

The following code is based on [[https://stackoverflow.com/a/145359/8468492][a StackOverflow answer]] by user [[https://stackoverflow.com/users/8355/cjm][cjm]].
All code posted to StackOverflow.com is licensed under CC BY-SA 3.0, so the following derived code is also CC BY-SA 3.0-licensed.

#+BEGIN_SRC emacs-lisp
(defun init-evil/beginning-of-maybe-line ()
  "Move point to first non-whitespace character or beginning of the line.

Move point to the first non-whitespace character on the line.  If the
point was already at that position, move point to the beginning of the
line."
  (interactive)
  (let ((old-point (point)))            ; current position
    ;; Go to the beginning of a comment.  If there is not comment or
    ;; if point is already at or to the left of the comment...
    (when (or (not (init-evil/back-to-comment))
              (<= old-point (point)))
      ;; Go to the first non-whitespace column.
      (back-to-indentation)
      ;; If already at or to the left of the first non-whitespace character...
      (when (<= old-point (point))
        ;; Go to the beginning of the line.
        (beginning-of-line)))))
#+END_SRC

***** Define ~end-of-maybe-line~
~end-of-maybe-line~ incrementally moves ~point~ to the right within a line by semantic region.
The following semantic elements are considered in ~end-of-maybe-line~'s movement:
1. Source code
2. Comments
3. Trailing whitespace


The following is licensed CC BY-SA 3.0-licensed by StackOverflow user [[https://stackoverflow.com/users/387076/gilles][Gilles]].
It is based on [[http://stackoverflow.com/a/14245964][Gilles's StackOverflow answer]].

#+BEGIN_SRC emacs-lisp
(defun init-evil/end-of-maybe-line ()
  "Incrementally move point to the ends of syntactic blocks within the line.

The syntactic blocks are as follows, ordered from right to left:
1. Source code
2. Inline comment"
  (interactive "^")
  ;; Record point's current position.
  (let ((old-point (point)))
    ;; Go to the beginning of an inline comment (if any).
    (init-evil/back-to-comment)
    ;; If already at or after the start of the comment...
    (when (>= old-point (point))
      ;; ...then go to the beginning of trailing whitespace.
      (init-evil/back-totext))))
#+END_SRC

** Evil Collection

/Evil Collection/ offers a collection of Evil keybindings for modes that Evil does not support by default.

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  ;; Load this package eagerly.
  :demand

  ;; Load this package afer the following packages.
  :after evil

  ;; Apply the following variable customizations.
  :custom
  <<evil-collection/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<evil-collection/config>>)
#+END_SRC

*** Apply Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-collection/custom
:END:

Set up autocompletion to be similar to Vim's YouCompleteMe.
#+BEGIN_SRC emacs-lisp
(evil-collection-company-use-tng t)
#+END_SRC

Enable =TAB=-based bindings in Outline mode.
#+BEGIN_SRC emacs-lisp
(evil-collection-outline-bind-tab t)
#+END_SRC

*** Conditional Loading

Synchronize insert and normal states with char and line modes, respectively, in Term mode.
#+BEGIN_SRC emacs-lisp
(evil-collection-term-sync-state-and-mode-p t)
#+END_SRC

Set up Vim-style keybindings in the minibuffer.
#+BEGIN_SRC emacs-lisp
(evil-collection-setup-minibuffer t)
#+END_SRC

Set up debugger keys.
#+BEGIN_SRC emacs-lisp
(evil-collection-setup-debugger-keys t)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref evil-collection/config
:END:

Enable Evil Collection globally.
#+BEGIN_SRC emacs-lisp
(evil-collection-init)
#+END_SRC

** Evil Matchit

[[https://github.com/redguardtoo/evil-matchit][Evil Matchit]] is a port of Tim Pope's [[http://www.vim.org/scripts/script.php?script_id%3D39][matchit.vim]] to Evil.
It enables jumping between matched tags, e.g. =<div>= and =</div>=.
#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  ;; Load this package eagerly.
  :demand

  ;; Add the following keybindings.
  :general
  (:keymaps 'evil-matchit-mode-map
   :states 'motion
   "%" #'evilmi-jump-items)

  :config
  (global-evil-matchit-mode 1))
#+END_SRC

** Evil Surround

[[https://github.com/emacs-evil/evil-surround][Evil Surround]] is a port of [[https://github.com/tpope/vim-surround][vim-surround]] to Evil.
It adds a "surround" verb to Evil's modal editing.
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  ;; Load eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  (global-evil-surround-mode 1))
#+END_SRC

** Evil Indent Plus
=[[https://github.com/TheBB/evil-indent-plus]]= adds indentation levels as a text object for Evil.

- =i= is same or higher indentation.
- =I= is same or higher indentation, including the first line above with less indentation.
- =J= is same or higher indentation, including the first line above and below with less indentation.


#+BEGIN_SRC emacs-lisp
(use-package evil-indent-plus
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code after loading this package.
  :config
  (evil-indent-plus-default-bindings))
#+END_SRC

* Minibuffer
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref minibuffer
:END:

The minibuffer is a persistent buffer in Emacs that is used for interactive input and messages.

** Recursive Minibuffers

Allowing one to have more than one minibuffer active allows for more sophisticated workflows.
#+BEGIN_SRC emacs-lisp
(setq enable-recursive-minibuffers t)
#+END_SRC

Once having multiple active minibuffers is possible, it is helpful to keep track of the depth of recursion.
#+BEGIN_SRC emacs-lisp
(minibuffer-depth-indicate-mode +1)
#+END_SRC

** Flx

/Flx/ provides fuzzy searching algorithms.
Ivy's fuzzy finding will use Flx's scoring mechanism if /Flx/ is loaded.

#+BEGIN_SRC emacs-lisp
(use-package flx
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code before loading this package.
  :init
  <<flx/config>>)
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref flx/config
:DESCRIPTION: Code to evaluated after ~flx~ has been loaded.
:END:

Run Emacs's garbage collector only when at least 20 MB have been allocated.
Doing so greatly improves ~flx~'s performance when working with large sets.

#+BEGIN_SRC emacs-lisp
(when (> 20000000 gc-cons-threshold)
  (setq gc-cons-threshold 20000000))
#+END_SRC

** Ivy
From the project's readme:
#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs.
While it operates similarly to other completion schemes such as =icomplete-mode=, Ivy aims to be more efficient, smaller, simpler, and smoother to use yet highly customizable.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package ivy
  ;; Load this package after the following packages.
  :after (flx)

  ;; Load this package eagerly.
  :demand

  ;; Inform the byte-compiler of the following interactive functions.
  :commands
  (ivy-mode)

  ;; Inform the byte-code compiler of the following non-interactive functions.
  :functions
  (ivy-format-function-line)

  ;; Add the following keybindings.
  :general
  <<ivy/general>>

  ;; Apply the following customizations.
  :custom
  <<ivy/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<ivy/config>>)
#+END_SRC

*** Keybindings
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy/general
:END:

Shadow ~switch-to-buffer~ with ~ivy-switch-buffer~.
#+BEGIN_SRC emacs-lisp
("C-x C-b" #'ivy-switch-buffer)
#+END_SRC

When in an Ivy buffer:
- =M-<return>= sends the current input verbatim.
- =C-u= restarts the minibuffer with a prefix argument.


#+BEGIN_SRC emacs-lisp
(:keymaps 'ivy-minibuffer-map
 "M-<return>" #'ivy-immediate-done
 "C-u" #'init-minibuffer/restart-with-prefix)
#+END_SRC

When in the minibuffer:
- =C-u= restarts the minibuffer with a prefix argument.


#+BEGIN_SRC emacs-lisp
(:keymaps 'minibuffer-inactive-mode-map
 "C-u" #'init-minibuffer/restart-with-prefix)
#+END_SRC

*** Variable Customization
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy/custom
:END:

Determine how matched parts of the options are highlighted.
#+BEGIN_SRC emacs-lisp
(ivy-display-style 'fancy "Highlight the matching parts of the regexp in the minibuffer.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-use-virtual-buffers t "Show recently killed buffers when calling `ivy-switch-buffer'.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-re-builders-alist '((t . ivy--regex-plus)) "Use `ivy--regex-plus' as the default matching function.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-extra-directories nil "Do not show './' or '../' in the filename completion list.")
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to evaluate after ~ivy~ has been loaded.
:HEADER-ARGS+: :noweb-ref ivy/config
:END:

Enable ~ivy-mode~ globally.
#+BEGIN_SRC emacs-lisp
(ivy-mode +1)
#+END_SRC

Do not include TRAMP buffers in Ivy's buffer lists.
#+BEGIN_SRC emacs-lisp
(setq ivy-ignore-buffers
      (cons (rx line-start "*tramp/"
                (one-or-more (not whitespace))
                whitespace
                (one-or-more anything)
                "*" line-end)
            ivy-ignore-buffers))
#+END_SRC

**** Restart the Minibuffer with a Prefix Argument
:PROPERTIES:
:AUTHOR: Clemens Radermacher (clemera) <clemera@posteo.net>
:COPYRIGHT: Copyright (C) 2019 Clemens Radermacher
:END:

Out of the box, Emacs does not provide a graceful way to add a prefix argument after the user has already started entering a command.
The following code posted by u/clemera on Reddit provides a workaround by restarting the minibuffer with same text.

First, a variable is defined to hold the minibuffer contents that were typed before entering a prefix.
#+BEGIN_SRC emacs-lisp
(defvar init-minibuffer/original-command nil
  "Command the minibuffer was started with.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun init-minibuffer/restart-with-prefix ()
  "Restart the minibuffer with a prefix argument."
  (interactive)
  (let ((input (ivy--input)))
    (cond ((memq #'ivy--queue-exhibit post-command-hook)
           (ivy-quit-and-run
             (let ((current-prefix-arg '(4))
                   (ivy-initial-inputs-alist `((,(ivy-state-caller ivy-last) . ,input))))
               (call-interactively (ivy-state-caller ivy-last))))
           (t
            (ivy-quit-and-run
              (let ((current-prefix-arg '(4)))
                (minibuffer-with-setup-hook
                    (lambda ()
                      (insert input)
                      (minibuffer-message "C-u"))
                  (call-interactively init-minibuffer/current-command)))))))))
#+END_SRC

** Counsel
#+BEGIN_SRC emacs-lisp
(use-package counsel

  ;; Load this package after the following packages.
  :after (ivy)

  ;; Load this package eagerly.
  :demand

  ;; Perform the following keybindings.
  :general
  ("C-h k" #'counsel-descbinds)
  ("C-x C-4 C-b" #'switch-to-buffer-other-window)
  ("C-x C-4 C-f" #'find-file-other-window)
  ("C-x C-4 b" #'switch-to-buffer-other-window)
  ("C-x C-f" #'counsel-find-file)
  ("C-x f" #'counsel-find-file)
  ("M-x" #'counsel-M-x)
  (:keymaps '(minibuffer-local-map minibuffer-inactive-mode-map)
   :states '(insert movement)
   "C-r" #'counsel-minibuffer-history)
  (:keymaps 'shell-mode-map
   "C-r" #'counsel-shell-history))
#+END_SRC

** Swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper
  ;; Load this package eagerly.
  :demand

  ;; Load this package after the following packages.
  :after ivy

  ;; Perform the following keybindings.
  :general
  ("C-s" #'swiper-isearch)
  (:keymaps '(normal movement visual)
   "/" #'swiper-isearch))
#+END_SRC

** Ivy Rich
#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  ;; Load this package after the following packages.
  :after ivy

  ;; Load this package eagerly.
  :demand

  ;; Apply the following customizations.
  :custom
  <<ivy-rich/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  <<ivy-rich/config>>)
#+END_SRC

*** Variable Customizations
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref ivy-rich/custom
:END:

#+BEGIN_SRC emacs-lisp
(ivy-virtual-abbreviate 'abbreviate "Abbreviate virtual buffer names.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ivy-rich-path-style 'relative "Show paths relative their the project home.")
#+END_SRC

*** Post-Load Evaluation
:PROPERTIES:
:DESCRIPTION: Code to evaluate after loading ~ivy-rich~.
:HEADER-ARGS+: :noweb-ref ivy-rich/config
:END:

Enable ~ivy-rich-mode~ globally.
#+BEGIN_SRC emacs-lisp
(ivy-rich-mode 1)
#+END_SRC

Add support for ~counsel-projectile-switch-to-buffer~, mirroring that of ~ivy-switch-buffer~.
#+BEGIN_SRC emacs-lisp
(setq ivy-rich--display-transformers-list
      (plist-put
       ivy-rich--display-transformers-list
       'counsel-projectile-switch-to-buffer
       (plist-get ivy-rich--display-transformers-list 'ivy-switch-buffer)))
#+END_SRC

** Minibuffer Line
:PROPERTIES:
:DESCRIPTION: Display status info in the minibuffer
:END:

From /Minibuffer Line/'s readme:
#+BEGIN_QUOTE
This package lets you display various status information in the minibuffer window instead of the mode-line.
Of course, this is only displayed when the minibuffer window is not already used for other things (e.g. a minibuffer or an each area message).
The contents and aspect is controlled by the src_emacs-lisp{minibuffer-line-format} variable and the src_emacs-lisp{minibuffer-line} face.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package minibuffer-line
  ;; Load this package eagerly.
  :demand

  ;; Evaluate the following code before loading this package.
  :init
  <<minibuffer-line/init>>

  ;; Inform the bytecode compiler of the following non-autoloading functions.
  :functions
  (format-time-string-8601 minibuffer-line-align)

  ;; Inform the bytecode compiler of the following autoloading functions.
  :commands
  minibuffer-line-mode

  ;; Apply the following variable customizations.
  :custom
  <<minibuffer-line/custom>>

  ;; Evaluate the following code after loading this package.
  :config
  (minibuffer-line-mode))
#+END_SRC

*** Pre-Load Evaluation
:PROPERTIES:
:HEADER-ARGS+: :noweb-ref minibuffer-line/init
:DESCRIPTION: Code to evaluate before loading src_emacs-lisp{minibuffer-line}
:END:

Define a function to print the date and time in ISO 8601 format.
#+BEGIN_SRC emacs-lisp
(defun format-time-string-minibuffer-line ()
  "Print the current date and time in ISO 8601-like format."
  (format-time-string "%Y-%m-%d %T"))
#+END_SRC

Define a function to left- and right-align elements using mode-line formatting.
#+BEGIN_SRC emacs-lisp
(defun minibuffer-line-align (left right)
  "Return a string containing LEFT and RIGHT aligned across the frame."
  (let* ((width-total (frame-text-cols))
         (width-space (- width-total
                         (+ (string-width (format-mode-line left))
                            (string-width (format-mode-line right))))))
    (append left
            (list (propertize
                   (format (format "%%%ds" width-space) "")
                   'face 'default))
            right)))
#+END_SRC

Define a the format to use for displaying battery information in the minibuffer.
#+BEGIN_SRC emacs-lisp
(defvar minibuffer-line-battery-format
  "battery %L %p%%"
  "Control string formatting the battery status to display in the minibuffer.")
#+END_SRC

*** Variable Customization
:PROPERTIES:
:DESCRIPTION: Variable customizations to apply when loading src_emacs-lisp{minibuffer-line}
:HEADER-ARGS+: :noweb-ref minibuffer-line/custom
:END:

Determine how frequently the string in src_emacs-lisp{minibuffer-line-format} is recalculated.
#+BEGIN_SRC emacs-lisp
(minibuffer-line-refresh-interval 1 "Refresh the minibuffer-line every second.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(minibuffer-line-format
 '((:eval
    (minibuffer-line-align
     '()
     '((:eval (propertize
               (battery-format
                minibuffer-line-battery-format
                (funcall battery-status-function))
               'face 'default))
       (:eval (propertize " | " 'face 'default))
       (:eval (propertize system-name 'face 'default))
       (:eval (propertize " | " 'face 'default))
       (:eval (propertize (format-time-string-minibuffer-line) 'face 'default)))))))
#+END_SRC

** McFly
:PROPERTIES:
:COPYRIGHT_YEAR: 2019
:COPYRIGHT_AUTHOR: Vincent Zhang (seagle0128)
:COPYRIGHT_EMAIL: seagle0128@gmail.com
:LICENSE: GPLv3+
:END:

#+BEGIN_SRC emacs-lisp
(defvar my-ivy-fly-commands '(query-replace-regexp
                              flush-lines
                              keep-lines
                              ivy-read
                              swiper
                              swiper-backward
                              swiper-all
                              swiper-isearch
                              swiper-isearch-backward
                              counsel-grep-or-swiper
                              counsel-grep-or-swiper-backward
                              counsel-grep
                              counsel-ack
                              counsel-ag
                              counsel-rg
                              counsel-pt))

(defun my-ivy-fly-back-to-present ()
  ;; (remove-hook 'pre-command-hook 'my-ivy-fly-back-to-present t)
  (cond ((and (memq last-command my-ivy-fly-commands)
              (equal (this-command-keys-vector) (kbd "M-p")))
         ;; repeat one time to get straight to the first history item
         (setq unread-command-events
               (append unread-command-events
                       (listify-key-sequence (kbd "M-p")))))
        ((or (memq this-command '(self-insert-command
                                  yank
                                  ivy-yank-word
                                  counsel-yank-pop))
             (equal (this-command-keys-vector) (kbd "M-n")))
         (delete-region (point)
                        (point-max)))))

(defun my-ivy-fly-time-travel ()
  (when (memq this-command my-ivy-fly-commands)
    (let* ((kbd (kbd "M-n"))
           (cmd (key-binding kbd))
           (future (and cmd
                        (with-temp-buffer
                          (when (ignore-errors
                                  (call-interactively cmd) t)
                            (buffer-string))))))
      (when future
        (save-excursion
          (insert (propertize (replace-regexp-in-string
                               "\\\\_<" ""
                               (replace-regexp-in-string
                                "\\\\_>" ""
                                future))
                              'face 'shadow)))
        (add-hook 'pre-command-hook 'my-ivy-fly-back-to-present nil t)))))

(add-hook 'minibuffer-setup-hook #'my-ivy-fly-time-travel)
#+END_SRC
* Footnotes

[fn:1] ~:ghook~ is one of the keywords added to \src_emacs-lisp{use-package} by /General/.
